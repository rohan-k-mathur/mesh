<!DOCTYPE html>
<html>
<head>
<title>ARTICLE_EXTRACTION_PIPELINE_SPEC.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<link rel="stylesheet" href="print-styles.css" media="print">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="article-to-argument-extraction-pipeline">Article-to-Argument Extraction Pipeline</h1>
<h2 id="technical-specification---part-1-architecture--data-model">Technical Specification - Part 1: Architecture &amp; Data Model</h2>
<p><strong>Version:</strong> 0.1 (Draft)<br>
<strong>Last Updated:</strong> December 15, 2025<br>
<strong>Scope:</strong> Bidirectional claim/argument extraction from Article objects<br>
<strong>Prerequisite Reading:</strong> ARTICLE_SYSTEM_ARCHITECTURE.md, ASPIC_SYSTEM_ARCHITECTURE.md</p>
<hr>
<h2 id="table-of-contents-full-document">Table of Contents (Full Document)</h2>
<h3 id="part-1-architecture--data-model">Part 1: Architecture &amp; Data Model</h3>
<ol>
<li><a href="#1-executive-summary">Executive Summary</a></li>
<li><a href="#2-problem-statement">Problem Statement</a></li>
<li><a href="#3-system-architecture-overview">System Architecture Overview</a></li>
<li><a href="#4-data-model-extensions">Data Model Extensions</a></li>
<li><a href="#5-extraction-pipeline-stages">Extraction Pipeline Stages</a></li>
</ol>
<h3 id="part-2-extraction-engine-design">Part 2: Extraction Engine Design</h3>
<ol start="6">
<li>Claim Detection &amp; Extraction</li>
<li>Argument Structure Inference</li>
<li>Scheme Recognition</li>
<li>Evidence &amp; Citation Linking</li>
</ol>
<h3 id="part-3-ontology-conversion--export">Part 3: Ontology Conversion &amp; Export</h3>
<ol start="10">
<li>AIF Conversion Layer</li>
<li>ASPIC+ Theory Generation</li>
<li>CEG (Carneades Evidence Graph) Export</li>
<li>Interoperability Standards</li>
</ol>
<h3 id="part-4-user-interface--workflows">Part 4: User Interface &amp; Workflows</h3>
<ol start="14">
<li>Extraction UI Components</li>
<li>Human-in-the-Loop Verification</li>
<li>Integration with ArticleReaderWithPins</li>
</ol>
<hr>
<h2 id="1-executive-summary">1. Executive Summary</h2>
<h3 id="11-vision">1.1 Vision</h3>
<p>Transform Mesh from a platform where <strong>arguments exist only through manual construction</strong> to one where <strong>arguments can be discovered, extracted, and converted</strong> from existing content—particularly Article objects.</p>
<pre class="hljs"><code><div>┌─────────────────────────────────────────────────────────────────────────────┐
│                    CURRENT STATE → TARGET STATE                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  CURRENT:                                                                    │
│  ┌────────────┐                      ┌────────────────────────────┐         │
│  │  Article   │                      │     Deliberation           │         │
│  │  (prose)   │     MANUAL ONLY      │  ┌───────┐  ┌──────────┐  │         │
│  │            │  ─────────────────▶  │  │ Claim │──│ Argument │  │         │
│  │  No struct │                      │  └───────┘  └──────────┘  │         │
│  │  reasoning │                      │                            │         │
│  └────────────┘                      └────────────────────────────┘         │
│                                                                              │
│  TARGET:                                                                     │
│  ┌────────────┐                      ┌────────────────────────────┐         │
│  │  Article   │                      │     Deliberation           │         │
│  │  (prose)   │     EXTRACTION       │  ┌───────┐  ┌──────────┐  │         │
│  │            │  ═══════════════▶    │  │ Claim │──│ Argument │  │         │
│  │  astJson   │     PIPELINE         │  └───────┘  └──────────┘  │         │
│  │            │                      │        ▲                   │         │
│  └────────────┘                      └────────┼───────────────────┘         │
│        ▲                                      │                              │
│        │              ◀═══════════════════════╯                              │
│        │                  BIDIRECTIONAL                                      │
│        │               (Thesis → Article)                                    │
│        ▼                                                                     │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │                    ONTOLOGY EXPORT LAYER                                │ │
│  │                                                                         │ │
│  │   ┌─────────┐   ┌───────────┐   ┌─────────┐   ┌──────────────────────┐ │ │
│  │   │   AIF   │   │  ASPIC+   │   │   CEG   │   │  Other (OWL, JSON-LD)│ │ │
│  │   │  Graph  │   │  Theory   │   │  Graph  │   │                      │ │ │
│  │   └─────────┘   └───────────┘   └─────────┘   └──────────────────────┘ │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
</div></code></pre>
<h3 id="12-key-capabilities">1.2 Key Capabilities</h3>
<table>
<thead>
<tr>
<th>Capability</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Claim Extraction</strong></td>
<td>Identify and extract claim-like statements from article prose</td>
</tr>
<tr>
<td><strong>Argument Discovery</strong></td>
<td>Infer premise-conclusion structures from extracted claims</td>
</tr>
<tr>
<td><strong>Scheme Recognition</strong></td>
<td>Detect which Walton argumentation scheme(s) an argument instantiates</td>
</tr>
<tr>
<td><strong>Evidence Linking</strong></td>
<td>Connect claims to citations/sources already in the article</td>
</tr>
<tr>
<td><strong>Anchor Preservation</strong></td>
<td>Maintain DOM-level anchors linking extracted claims to source text</td>
</tr>
<tr>
<td><strong>Ontology Export</strong></td>
<td>Convert extracted structures to AIF, ASPIC+, CEG, and other standards</td>
</tr>
<tr>
<td><strong>Human Verification</strong></td>
<td>UI for reviewing, correcting, and approving extractions</td>
</tr>
<tr>
<td><strong>Bidirectional Sync</strong></td>
<td>Changes to arguments update article annotations and vice versa</td>
</tr>
</tbody>
</table>
<h3 id="13-design-principles">1.3 Design Principles</h3>
<ol>
<li><strong>Anchor-First</strong>: Every extracted claim maintains a precise link to its source text position</li>
<li><strong>Progressive Confidence</strong>: Extraction confidence scores flow through the entire pipeline</li>
<li><strong>Human-in-the-Loop</strong>: AI-assisted extraction with mandatory human verification for publication</li>
<li><strong>Standard Ontologies</strong>: Native support for AIF, ASPIC+, and CEG from the ground up</li>
<li><strong>Minimal Schema Changes</strong>: Extend existing models rather than replacing them</li>
</ol>
<hr>
<h2 id="2-problem-statement">2. Problem Statement</h2>
<h3 id="21-the-gap-in-current-mesh-architecture">2.1 The Gap in Current Mesh Architecture</h3>
<pre class="hljs"><code><div>┌─────────────────────────────────────────────────────────────────────────────┐
│              CURRENT CONTENT FLOW IN MESH                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Article System                          Deliberation System                 │
│  ─────────────────                       ─────────────────────               │
│                                                                              │
│  ┌─────────────────┐                     ┌─────────────────────┐            │
│  │ TipTap Editor   │                     │  Claim Construction  │            │
│  │                 │                     │                      │            │
│  │ • Rich text     │      ──────▶        │  • Manual creation   │            │
│  │ • astJson       │    (deliberation    │  • DialogueMove      │            │
│  │ • No structure  │      panel only)    │  • No source anchor  │            │
│  └─────────────────┘                     └─────────────────────┘            │
│          │                                          │                        │
│          ▼                                          ▼                        │
│  ┌─────────────────┐                     ┌─────────────────────┐            │
│  │ CommentThread   │                     │  Argument Builder    │            │
│  │                 │       NO LINK       │                      │            │
│  │ • Anchor-based  │    ◀──────────▶     │  • Premises → Concl  │            │
│  │ • DOM path      │                     │  • Scheme annotation │            │
│  │ • No claim link │                     │  • No text anchor    │            │
│  └─────────────────┘                     └─────────────────────┘            │
│                                                                              │
│  GAP: Articles contain rich argumentative content, but there's no           │
│       pipeline to extract claims/arguments while preserving text anchors.   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
</div></code></pre>
<h3 id="22-why-this-matters">2.2 Why This Matters</h3>
<table>
<thead>
<tr>
<th>Stakeholder</th>
<th>Current Pain</th>
<th>Extraction Pipeline Value</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Researcher</strong></td>
<td>Must manually re-create claims from papers they read</td>
<td>Extract claims directly from uploaded articles</td>
</tr>
<tr>
<td><strong>Author</strong></td>
<td>Writes articles but deliberation is disconnected</td>
<td>Article prose auto-populates deliberation</td>
</tr>
<tr>
<td><strong>Reviewer</strong></td>
<td>Comments on text, but comments aren't structured</td>
<td>Annotations can become formal claims/attacks</td>
</tr>
<tr>
<td><strong>Platform</strong></td>
<td>Rich content exists but isn't machine-readable</td>
<td>AIF/ASPIC+ exports for analysis tools</td>
</tr>
</tbody>
</table>
<h3 id="23-existing-infrastructure-to-leverage">2.3 Existing Infrastructure to Leverage</h3>
<table>
<thead>
<tr>
<th>Component</th>
<th>Current Use</th>
<th>Extraction Pipeline Use</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Article.astJson</code></td>
<td>TipTap document AST</td>
<td>Source for text extraction</td>
</tr>
<tr>
<td><code>CommentThread.anchor</code></td>
<td>DOM path for annotations</td>
<td>Model for claim text anchors</td>
</tr>
<tr>
<td><code>Claim</code> model</td>
<td>Manual claim storage</td>
<td>Storage for extracted claims</td>
</tr>
<tr>
<td><code>ArgumentPremise</code></td>
<td>Links claims to arguments</td>
<td>Link extracted premises</td>
</tr>
<tr>
<td><code>ArgumentScheme</code></td>
<td>Walton scheme definitions</td>
<td>Scheme recognition targets</td>
</tr>
<tr>
<td><code>Citation</code> model</td>
<td>Links sources to targets</td>
<td>Evidence for extracted claims</td>
</tr>
<tr>
<td><code>Source</code> model</td>
<td>External source metadata</td>
<td>Link to article as source</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="3-system-architecture-overview">3. System Architecture Overview</h2>
<h3 id="31-high-level-pipeline-architecture">3.1 High-Level Pipeline Architecture</h3>
<pre class="hljs"><code><div>┌─────────────────────────────────────────────────────────────────────────────┐
│                    EXTRACTION PIPELINE ARCHITECTURE                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                         INPUT LAYER                                    │  │
│  │                                                                        │  │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  │  │
│  │  │   Article   │  │ LibraryPost │  │ PDF (future)│  │  Web URL    │  │  │
│  │  │  (astJson)  │  │   (Stack)   │  │             │  │  (future)   │  │  │
│  │  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘  │  │
│  └─────────┼────────────────┼────────────────┼────────────────┼─────────┘  │
│            │                │                │                │             │
│            └────────────────┴────────────────┴────────────────┘             │
│                                     │                                        │
│                                     ▼                                        │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                      EXTRACTION ENGINE                                 │  │
│  │                                                                        │  │
│  │  ┌─────────────────────────────────────────────────────────────────┐  │  │
│  │  │  STAGE 1: TEXT PREPROCESSING                                    │  │  │
│  │  │  • AST → plaintext with position mapping                        │  │  │
│  │  │  • Sentence boundary detection                                  │  │  │
│  │  │  • Section/paragraph structure preservation                     │  │  │
│  │  └─────────────────────────────────────────────────────────────────┘  │  │
│  │                              │                                         │  │
│  │                              ▼                                         │  │
│  │  ┌─────────────────────────────────────────────────────────────────┐  │  │
│  │  │  STAGE 2: CLAIM DETECTION                                       │  │  │
│  │  │  • Claim indicator detection (hedges, assertions, conclusions)  │  │  │
│  │  │  • Named entity + relation extraction                           │  │  │
│  │  │  • Confidence scoring per candidate claim                       │  │  │
│  │  └─────────────────────────────────────────────────────────────────┘  │  │
│  │                              │                                         │  │
│  │                              ▼                                         │  │
│  │  ┌─────────────────────────────────────────────────────────────────┐  │  │
│  │  │  STAGE 3: ARGUMENT STRUCTURE INFERENCE                          │  │  │
│  │  │  • Premise-conclusion relation detection                        │  │  │
│  │  │  • Discourse connective analysis (therefore, because, since...) │  │  │
│  │  │  • Implicit premise reconstruction (enthymeme detection)        │  │  │
│  │  └─────────────────────────────────────────────────────────────────┘  │  │
│  │                              │                                         │  │
│  │                              ▼                                         │  │
│  │  ┌─────────────────────────────────────────────────────────────────┐  │  │
│  │  │  STAGE 4: SCHEME RECOGNITION                                    │  │  │
│  │  │  • Match argument patterns to Walton scheme templates           │  │  │
│  │  │  • Multi-scheme classification with confidence                  │  │  │
│  │  │  • Critical question generation                                 │  │  │
│  │  └─────────────────────────────────────────────────────────────────┘  │  │
│  │                              │                                         │  │
│  │                              ▼                                         │  │
│  │  ┌─────────────────────────────────────────────────────────────────┐  │  │
│  │  │  STAGE 5: EVIDENCE &amp; CITATION LINKING                           │  │  │
│  │  │  • Match claims to inline citations                             │  │  │
│  │  │  • Link to Source model via DOI/URL                             │  │  │
│  │  │  • Evidence type classification                                 │  │  │
│  │  └─────────────────────────────────────────────────────────────────┘  │  │
│  │                              │                                         │  │
│  │                              ▼                                         │  │
│  │  ┌─────────────────────────────────────────────────────────────────┐  │  │
│  │  │  STAGE 6: ANCHOR GENERATION                                     │  │  │
│  │  │  • Map extracted claims back to AST positions                   │  │  │
│  │  │  • Generate Anchor objects (startPath, endPath, offsets)        │  │  │
│  │  │  • Handle claim spans across multiple DOM nodes                 │  │  │
│  │  └─────────────────────────────────────────────────────────────────┘  │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                     │                                        │
│                                     ▼                                        │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                     VERIFICATION LAYER                                 │  │
│  │                                                                        │  │
│  │  ┌─────────────────────────────────────────────────────────────────┐  │  │
│  │  │  ExtractionJob                                                   │  │  │
│  │  │  • Stores raw extraction results                                 │  │  │
│  │  │  • Status: PENDING → IN_REVIEW → APPROVED → PUBLISHED           │  │  │
│  │  │  • Tracks human edits and corrections                            │  │  │
│  │  └─────────────────────────────────────────────────────────────────┘  │  │
│  │                                                                        │  │
│  │  ┌─────────────────────────────────────────────────────────────────┐  │  │
│  │  │  Human-in-the-Loop UI                                            │  │  │
│  │  │  • Review extracted claims in ArticleReaderWithPins context      │  │  │
│  │  │  • Accept / Reject / Edit individual claims                      │  │  │
│  │  │  • Adjust argument structure and scheme assignments              │  │  │
│  │  └─────────────────────────────────────────────────────────────────┘  │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                     │                                        │
│                                     ▼                                        │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                      OUTPUT LAYER                                      │  │
│  │                                                                        │  │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  │  │
│  │  │   Claim     │  │  Argument   │  │ ArticleClaim│  │  Ontology   │  │  │
│  │  │  (Prisma)   │  │  (Prisma)   │  │  Anchor     │  │   Export    │  │  │
│  │  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘  │  │
│  │         │               │               │               │             │  │
│  │         ▼               ▼               ▼               ▼             │  │
│  │  ┌───────────────────────────────────────────────────────────────┐   │  │
│  │  │                    DELIBERATION                                │   │  │
│  │  │  (extracted claims/arguments now part of structured debate)    │   │  │
│  │  └───────────────────────────────────────────────────────────────┘   │  │
│  │                                                                        │  │
│  │  ┌───────────────────────────────────────────────────────────────┐   │  │
│  │  │                    AIF / ASPIC+ / CEG EXPORT                   │   │  │
│  │  └───────────────────────────────────────────────────────────────┘   │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
</div></code></pre>
<h3 id="32-component-responsibilities">3.2 Component Responsibilities</h3>
<table>
<thead>
<tr>
<th>Component</th>
<th>Responsibility</th>
<th>Technology</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Text Preprocessor</strong></td>
<td>Convert astJson → sentences with position maps</td>
<td>TypeScript, AST traversal</td>
</tr>
<tr>
<td><strong>Claim Detector</strong></td>
<td>Identify claim-like statements</td>
<td>LLM (GPT-4/Claude) + heuristics</td>
</tr>
<tr>
<td><strong>Argument Assembler</strong></td>
<td>Infer premise→conclusion structures</td>
<td>LLM + discourse analysis</td>
</tr>
<tr>
<td><strong>Scheme Classifier</strong></td>
<td>Match to Walton schemes</td>
<td>ML classifier + rule-based</td>
</tr>
<tr>
<td><strong>Evidence Linker</strong></td>
<td>Connect claims to citations</td>
<td>Reference parsing, DOI lookup</td>
</tr>
<tr>
<td><strong>Anchor Generator</strong></td>
<td>Create DOM path anchors</td>
<td>AST position tracking</td>
</tr>
<tr>
<td><strong>Verification UI</strong></td>
<td>Human review interface</td>
<td>React, extends ArticleReader</td>
</tr>
<tr>
<td><strong>Ontology Exporter</strong></td>
<td>Convert to AIF/ASPIC+/CEG</td>
<td>TypeScript serializers</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="4-data-model-extensions">4. Data Model Extensions</h2>
<h3 id="41-new-models-for-extraction-pipeline">4.1 New Models for Extraction Pipeline</h3>
<pre class="hljs"><code><div>// ============================================================
// EXTRACTION JOB - Tracks extraction workflow state
// ============================================================

enum ExtractionJobStatus {
  QUEUED          // Job created, awaiting processing
  PROCESSING      // Extraction engine running
  PENDING_REVIEW  // Extraction complete, awaiting human review
  IN_REVIEW       // Human reviewer actively working
  APPROVED        // Human approved, ready to publish
  PUBLISHED       // Claims/arguments created in deliberation
  REJECTED        // Human rejected extraction
  FAILED          // Extraction engine error
}

model ExtractionJob {
  id            String              @id @default(cuid())
  
  // Source document
  sourceType    String              // 'article' | 'libraryPost' | 'pdf'
  sourceId      String              // Article.id, LibraryPost.id, etc.
  
  // Target deliberation
  deliberationId String?            // Optional: pre-specified target
  
  // Job metadata
  status        ExtractionJobStatus @default(QUEUED)
  startedAt     DateTime?
  completedAt   DateTime?
  error         String?             @db.Text
  
  // Extraction configuration
  configJson    Json?               // { model: 'gpt-4', sensitivity: 0.7, ... }
  
  // Raw extraction results (before human review)
  rawResultJson Json?               // Full extraction output
  
  // Human review tracking
  reviewerId    String?
  reviewStartedAt DateTime?
  reviewCompletedAt DateTime?
  reviewNotes   String?             @db.Text
  
  // Statistics
  claimsExtracted     Int           @default(0)
  claimsApproved      Int           @default(0)
  claimsRejected      Int           @default(0)
  claimsModified      Int           @default(0)
  argumentsExtracted  Int           @default(0)
  argumentsApproved   Int           @default(0)
  
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt
  createdById   String
  
  // Relations
  extractedClaims   ExtractedClaim[]
  extractedArguments ExtractedArgument[]
  
  @@index([sourceType, sourceId])
  @@index([status])
  @@index([deliberationId])
  @@index([createdById])
}

// ============================================================
// EXTRACTED CLAIM - Pre-approval claim with source anchor
// ============================================================

enum ExtractedClaimStatus {
  PENDING     // Awaiting review
  APPROVED    // Human approved, will create Claim
  REJECTED    // Human rejected
  MODIFIED    // Human edited before approval
  MERGED      // Merged with another extracted claim
  PUBLISHED   // Claim entity created
}

model ExtractedClaim {
  id              String               @id @default(cuid())
  jobId           String
  
  // Claim content
  text            String               @db.Text
  normalizedText  String?              @db.Text  // Cleaned/standardized version
  
  // Source anchor (reuses Anchor type from CommentThread)
  anchorJson      Json                 // { startPath, startOffset, endPath, endOffset }
  sourceText      String               @db.Text  // Original text span from article
  
  // Extraction confidence
  confidence      Float                @default(0.5)
  extractorModel  String?              // 'gpt-4', 'claude-3', 'rule-based'
  
  // Classification
  claimType       String?              // 'assertion', 'hypothesis', 'conclusion', 'premise'
  isImplicit      Boolean              @default(false)  // Reconstructed implicit claim
  
  // Review status
  status          ExtractedClaimStatus @default(PENDING)
  reviewNote      String?              @db.Text
  modifiedText    String?              @db.Text  // Human-edited version
  
  // Links
  mergedIntoId    String?              // If MERGED, points to surviving claim
  publishedClaimId String?             // After PUBLISHED, links to Claim.id
  
  createdAt       DateTime             @default(now())
  updatedAt       DateTime             @updatedAt
  
  // Relations
  job             ExtractionJob        @relation(fields: [jobId], references: [id], onDelete: Cascade)
  mergedInto      ExtractedClaim?      @relation(&quot;ClaimMerge&quot;, fields: [mergedIntoId], references: [id])
  mergedFrom      ExtractedClaim[]     @relation(&quot;ClaimMerge&quot;)
  
  asPremise       ExtractedArgumentPremise[]
  asConclusion    ExtractedArgument[]  @relation(&quot;ExtractedConclusion&quot;)
  evidenceLinks   ExtractedEvidence[]
  
  @@index([jobId])
  @@index([status])
  @@index([publishedClaimId])
}

// ============================================================
// EXTRACTED ARGUMENT - Pre-approval argument structure
// ============================================================

enum ExtractedArgumentStatus {
  PENDING
  APPROVED
  REJECTED
  MODIFIED
  PUBLISHED
}

model ExtractedArgument {
  id              String                  @id @default(cuid())
  jobId           String
  
  // Argument structure
  conclusionId    String                  // ExtractedClaim.id
  
  // Scheme classification
  primarySchemeId String?                 // ArgumentScheme.id (best match)
  schemeConfidence Float?
  alternativeSchemes Json?                // [{ schemeId, confidence }, ...]
  
  // Extraction metadata
  confidence      Float                   @default(0.5)
  extractorModel  String?
  inferenceText   String?                 @db.Text  // Warrant/inference explanation
  
  // Discourse indicators found
  discourseMarkers Json?                  // ['therefore', 'because', ...] with positions
  
  // Review status
  status          ExtractedArgumentStatus @default(PENDING)
  reviewNote      String?                 @db.Text
  
  // Published link
  publishedArgumentId String?             // After PUBLISHED, links to Argument.id
  
  createdAt       DateTime                @default(now())
  updatedAt       DateTime                @updatedAt
  
  // Relations
  job             ExtractionJob           @relation(fields: [jobId], references: [id], onDelete: Cascade)
  conclusion      ExtractedClaim          @relation(&quot;ExtractedConclusion&quot;, fields: [conclusionId], references: [id], onDelete: Cascade)
  premises        ExtractedArgumentPremise[]
  
  @@index([jobId])
  @@index([conclusionId])
  @@index([status])
}

model ExtractedArgumentPremise {
  id              String            @id @default(cuid())
  argumentId      String
  claimId         String
  order           Int               @default(0)
  isImplicit      Boolean           @default(false)  // Reconstructed premise
  
  argument        ExtractedArgument @relation(fields: [argumentId], references: [id], onDelete: Cascade)
  claim           ExtractedClaim    @relation(fields: [claimId], references: [id], onDelete: Cascade)
  
  @@unique([argumentId, claimId])
  @@index([argumentId])
  @@index([claimId])
}

// ============================================================
// EXTRACTED EVIDENCE - Links claims to citations in source
// ============================================================

model ExtractedEvidence {
  id              String          @id @default(cuid())
  claimId         String
  
  // Citation reference in source document
  citationText    String?         // &quot;[Smith 2023]&quot; as it appears
  citationAnchor  Json?           // Anchor to citation in source
  
  // Resolved source (if found)
  sourceId        String?         // Source.id if matched
  doi             String?         // DOI if extracted
  url             String?         // URL if extracted
  
  // Evidence classification
  evidenceType    String?         // 'citation', 'quotation', 'data', 'example'
  confidence      Float           @default(0.5)
  
  createdAt       DateTime        @default(now())
  
  claim           ExtractedClaim  @relation(fields: [claimId], references: [id], onDelete: Cascade)
  
  @@index([claimId])
  @@index([sourceId])
}

// ============================================================
// ARTICLE CLAIM ANCHOR - Persistent link between Claim and Article text
// ============================================================

model ArticleClaimAnchor {
  id            String    @id @default(cuid())
  articleId     String
  claimId       String
  
  // Anchor data (same structure as CommentThread.anchor)
  anchorJson    Json      // { startPath, startOffset, endPath, endOffset }
  
  // Source text at time of extraction (for drift detection)
  sourceText    String    @db.Text
  
  // Versioning for article updates
  articleRevisionId String?  // Revision.id when anchor was created
  isStale       Boolean   @default(false)  // True if article updated since
  
  // Extraction provenance
  extractionJobId String?
  wasManual     Boolean   @default(false)  // True if user created anchor directly
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  @@unique([articleId, claimId])
  @@index([articleId])
  @@index([claimId])
  @@index([extractionJobId])
}
</div></code></pre>
<h3 id="42-modifications-to-existing-models">4.2 Modifications to Existing Models</h3>
<pre class="hljs"><code><div>// Add to existing Article model
model Article {
  // ... existing fields ...
  
  // NEW: Extraction relations
  extractionJobs    ExtractionJob[]  @relation(&quot;ArticleExtractionJobs&quot;)
  claimAnchors      ArticleClaimAnchor[]
  
  // NEW: Flag for extraction availability
  extractionEnabled Boolean @default(true)
}

// Add to existing Claim model
model Claim {
  // ... existing fields ...
  
  // NEW: Article anchor relation
  articleAnchors    ArticleClaimAnchor[]
  
  // NEW: Extraction provenance
  extractedFromJobId String?
  extractionConfidence Float?
}

// Add to existing Source model
model Source {
  // ... existing fields ...
  
  // NEW: Link to Article if source is a Mesh article
  articleId         String?  @unique
  article           Article? @relation(fields: [articleId], references: [id])
}
</div></code></pre>
<h3 id="43-anchor-data-structure">4.3 Anchor Data Structure</h3>
<p>The <code>anchorJson</code> field stores the same structure used by <code>CommentThread</code> for text annotations, enabling seamless integration with <code>ArticleReaderWithPins</code>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// types/extraction.ts</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> Anchor {
  startPath: <span class="hljs-built_in">number</span>[];   <span class="hljs-comment">// DOM path from root to start node</span>
  startOffset: <span class="hljs-built_in">number</span>;   <span class="hljs-comment">// Character offset within start text node</span>
  endPath: <span class="hljs-built_in">number</span>[];     <span class="hljs-comment">// DOM path from root to end node</span>
  endOffset: <span class="hljs-built_in">number</span>;     <span class="hljs-comment">// Character offset within end text node</span>
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> ExtractedClaimData {
  id: <span class="hljs-built_in">string</span>;
  text: <span class="hljs-built_in">string</span>;
  normalizedText?: <span class="hljs-built_in">string</span>;
  anchor: Anchor;
  sourceText: <span class="hljs-built_in">string</span>;
  confidence: <span class="hljs-built_in">number</span>;
  claimType?: <span class="hljs-string">'assertion'</span> | <span class="hljs-string">'hypothesis'</span> | <span class="hljs-string">'conclusion'</span> | <span class="hljs-string">'premise'</span> | <span class="hljs-string">'evidence'</span>;
  isImplicit: <span class="hljs-built_in">boolean</span>;
  status: <span class="hljs-string">'PENDING'</span> | <span class="hljs-string">'APPROVED'</span> | <span class="hljs-string">'REJECTED'</span> | <span class="hljs-string">'MODIFIED'</span> | <span class="hljs-string">'MERGED'</span> | <span class="hljs-string">'PUBLISHED'</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> ExtractedArgumentData {
  id: <span class="hljs-built_in">string</span>;
  conclusionId: <span class="hljs-built_in">string</span>;
  premiseIds: <span class="hljs-built_in">string</span>[];
  primarySchemeId?: <span class="hljs-built_in">string</span>;
  schemeConfidence?: <span class="hljs-built_in">number</span>;
  alternativeSchemes?: { schemeId: <span class="hljs-built_in">string</span>; confidence: <span class="hljs-built_in">number</span> }[];
  confidence: <span class="hljs-built_in">number</span>;
  inferenceText?: <span class="hljs-built_in">string</span>;
  discourseMarkers?: { text: <span class="hljs-built_in">string</span>; anchor: Anchor }[];
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> ExtractionResult {
  jobId: <span class="hljs-built_in">string</span>;
  claims: ExtractedClaimData[];
  <span class="hljs-built_in">arguments</span>: ExtractedArgumentData[];
  evidence: ExtractedEvidenceData[];
  metadata: {
    sourceType: <span class="hljs-built_in">string</span>;
    sourceId: <span class="hljs-built_in">string</span>;
    extractorModel: <span class="hljs-built_in">string</span>;
    processingTimeMs: <span class="hljs-built_in">number</span>;
    tokenCount?: <span class="hljs-built_in">number</span>;
  };
}
</div></code></pre>
<hr>
<h2 id="5-extraction-pipeline-stages">5. Extraction Pipeline Stages</h2>
<h3 id="51-stage-1-text-preprocessing">5.1 Stage 1: Text Preprocessing</h3>
<p><strong>Goal</strong>: Convert TipTap AST to extractable text while preserving position mappings.</p>
<pre class="hljs"><code><div><span class="hljs-comment">// lib/extraction/preprocessor.ts</span>

<span class="hljs-keyword">import</span> { JSONContent } <span class="hljs-keyword">from</span> <span class="hljs-string">'@tiptap/core'</span>;

<span class="hljs-keyword">interface</span> TextSpan {
  text: <span class="hljs-built_in">string</span>;
  astPath: <span class="hljs-built_in">number</span>[];       <span class="hljs-comment">// Path to this node in astJson</span>
  charStart: <span class="hljs-built_in">number</span>;       <span class="hljs-comment">// Global character offset start</span>
  charEnd: <span class="hljs-built_in">number</span>;         <span class="hljs-comment">// Global character offset end</span>
  nodeType: <span class="hljs-built_in">string</span>;        <span class="hljs-comment">// 'paragraph', 'heading', 'listItem', etc.</span>
  metadata: {
    section?: <span class="hljs-built_in">string</span>;      <span class="hljs-comment">// Heading context</span>
    listDepth?: <span class="hljs-built_in">number</span>;    <span class="hljs-comment">// Nesting level</span>
    emphasis?: <span class="hljs-built_in">boolean</span>;    <span class="hljs-comment">// Bold/italic</span>
  };
}

<span class="hljs-keyword">interface</span> PreprocessedDocument {
  fullText: <span class="hljs-built_in">string</span>;
  spans: TextSpan[];
  sentences: SentenceSpan[];
  sections: SectionSpan[];
  
  <span class="hljs-comment">// Lookup methods</span>
  getSpanAtPosition(charPos: <span class="hljs-built_in">number</span>): TextSpan | <span class="hljs-literal">null</span>;
  getAnchorForRange(startChar: <span class="hljs-built_in">number</span>, endChar: <span class="hljs-built_in">number</span>): Anchor;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">preprocessArticle</span>(<span class="hljs-params">astJson: JSONContent</span>): <span class="hljs-title">PreprocessedDocument</span> </span>{
  <span class="hljs-keyword">const</span> spans: TextSpan[] = [];
  <span class="hljs-keyword">let</span> globalOffset = <span class="hljs-number">0</span>;
  
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traverse</span>(<span class="hljs-params">node: JSONContent, path: <span class="hljs-built_in">number</span>[], sectionContext: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span></span>) </span>{
    <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">'text'</span> &amp;&amp; node.text) {
      spans.push({
        text: node.text,
        astPath: [...path],
        charStart: globalOffset,
        charEnd: globalOffset + node.text.length,
        nodeType: <span class="hljs-string">'text'</span>,
        metadata: { section: sectionContext }
      });
      globalOffset += node.text.length;
    }
    
    <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">'paragraph'</span> || node.type === <span class="hljs-string">'heading'</span>) {
      <span class="hljs-comment">// Add space between blocks</span>
      <span class="hljs-keyword">if</span> (globalOffset &gt; <span class="hljs-number">0</span>) {
        globalOffset += <span class="hljs-number">1</span>; <span class="hljs-comment">// Implicit newline</span>
      }
      
      <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">'heading'</span> &amp;&amp; node.content?.[<span class="hljs-number">0</span>]?.text) {
        sectionContext = node.content[<span class="hljs-number">0</span>].text;
      }
    }
    
    <span class="hljs-keyword">if</span> (node.content) {
      node.content.forEach(<span class="hljs-function">(<span class="hljs-params">child, idx</span>) =&gt;</span> {
        traverse(child, [...path, idx], sectionContext);
      });
    }
  }
  
  traverse(astJson, [], <span class="hljs-literal">null</span>);
  
  <span class="hljs-keyword">const</span> fullText = spans.map(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> s.text).join(<span class="hljs-string">''</span>);
  
  <span class="hljs-keyword">return</span> {
    fullText,
    spans,
    sentences: detectSentences(spans),
    sections: detectSections(spans),
    getSpanAtPosition: <span class="hljs-function">(<span class="hljs-params">pos</span>) =&gt;</span> spans.find(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> pos &gt;= s.charStart &amp;&amp; pos &lt; s.charEnd) || <span class="hljs-literal">null</span>,
    getAnchorForRange: <span class="hljs-function">(<span class="hljs-params">start, end</span>) =&gt;</span> buildAnchorFromCharRange(spans, start, end),
  };
}
</div></code></pre>
<h3 id="52-stage-2-claim-detection">5.2 Stage 2: Claim Detection</h3>
<p><strong>Goal</strong>: Identify statements that function as claims within the document.</p>
<pre class="hljs"><code><div><span class="hljs-comment">// lib/extraction/claim-detector.ts</span>

<span class="hljs-keyword">interface</span> ClaimCandidate {
  text: <span class="hljs-built_in">string</span>;
  charStart: <span class="hljs-built_in">number</span>;
  charEnd: <span class="hljs-built_in">number</span>;
  confidence: <span class="hljs-built_in">number</span>;
  claimType: <span class="hljs-string">'assertion'</span> | <span class="hljs-string">'hypothesis'</span> | <span class="hljs-string">'conclusion'</span> | <span class="hljs-string">'premise'</span> | <span class="hljs-string">'evidence'</span>;
  indicators: ClaimIndicator[];
}

<span class="hljs-keyword">interface</span> ClaimIndicator {
  <span class="hljs-keyword">type</span>: <span class="hljs-string">'lexical'</span> | <span class="hljs-string">'syntactic'</span> | <span class="hljs-string">'discourse'</span> | <span class="hljs-string">'semantic'</span>;
  value: <span class="hljs-built_in">string</span>;
  position: <span class="hljs-built_in">number</span>;
  weight: <span class="hljs-built_in">number</span>;
}

<span class="hljs-comment">// Claim detection prompts for LLM</span>
<span class="hljs-keyword">const</span> CLAIM_DETECTION_SYSTEM_PROMPT = <span class="hljs-string">`You are an expert argumentation analyst. Your task is to identify claims (statements that can be true or false and are asserted as positions) within academic/argumentative text.

For each claim, provide:
1. The exact text of the claim
2. The character positions (start, end) in the source text
3. A confidence score (0.0-1.0)
4. The claim type: 'assertion', 'hypothesis', 'conclusion', 'premise', or 'evidence'

Claim indicators to look for:
- Thesis statements ("I argue that...", "This paper demonstrates...")
- Conclusions ("Therefore...", "Thus...", "We conclude...")
- Hypotheses ("We hypothesize that...", "It is proposed...")
- Factual assertions ("X is Y", "Studies show that...")
- Evidence statements ("Data indicates...", "Results show...")

Do NOT extract:
- Questions
- Definitions (unless used as claims)
- Pure methodology descriptions
- Acknowledgments or metadata

Return as JSON array.`</span>;

<span class="hljs-keyword">interface</span> ClaimDetectionConfig {
  model: <span class="hljs-string">'gpt-4'</span> | <span class="hljs-string">'gpt-4-turbo'</span> | <span class="hljs-string">'claude-3-opus'</span> | <span class="hljs-string">'claude-3-sonnet'</span>;
  sensitivity: <span class="hljs-built_in">number</span>;       <span class="hljs-comment">// 0.0-1.0, higher = more claims extracted</span>
  maxClaimsPerSection: <span class="hljs-built_in">number</span>;
  includeImplicitClaims: <span class="hljs-built_in">boolean</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">detectClaims</span>(<span class="hljs-params">
  doc: PreprocessedDocument,
  config: ClaimDetectionConfig
</span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">ClaimCandidate</span>[]&gt; </span>{
  <span class="hljs-comment">// Hybrid approach: LLM + rule-based indicators</span>
  
  <span class="hljs-keyword">const</span> llmCandidates = <span class="hljs-keyword">await</span> detectClaimsWithLLM(doc, config);
  <span class="hljs-keyword">const</span> ruleCandidates = detectClaimsWithRules(doc, config);
  
  <span class="hljs-comment">// Merge and deduplicate</span>
  <span class="hljs-keyword">return</span> mergeAndRankCandidates(llmCandidates, ruleCandidates, config.sensitivity);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">detectClaimsWithRules</span>(<span class="hljs-params">
  doc: PreprocessedDocument,
  config: ClaimDetectionConfig
</span>): <span class="hljs-title">ClaimCandidate</span>[] </span>{
  <span class="hljs-keyword">const</span> candidates: ClaimCandidate[] = [];
  
  <span class="hljs-comment">// Rule-based indicators</span>
  <span class="hljs-keyword">const</span> conclusionMarkers = <span class="hljs-regexp">/\b(therefore|thus|hence|consequently|we conclude|this shows|this demonstrates)\b/gi</span>;
  <span class="hljs-keyword">const</span> premiseMarkers = <span class="hljs-regexp">/\b(because|since|given that|as evidence|studies show|data indicates)\b/gi</span>;
  <span class="hljs-keyword">const</span> hypothesisMarkers = <span class="hljs-regexp">/\b(we hypothesize|it is proposed|we argue|I contend|this suggests)\b/gi</span>;
  
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> sentence of doc.sentences) {
    <span class="hljs-keyword">let</span> confidence = <span class="hljs-number">0.3</span>; <span class="hljs-comment">// Base confidence</span>
    <span class="hljs-keyword">let</span> claimType: ClaimCandidate[<span class="hljs-string">'claimType'</span>] = <span class="hljs-string">'assertion'</span>;
    <span class="hljs-keyword">const</span> indicators: ClaimIndicator[] = [];
    
    <span class="hljs-comment">// Check for conclusion markers</span>
    <span class="hljs-keyword">const</span> conclusionMatches = sentence.text.matchAll(conclusionMarkers);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> match of conclusionMatches) {
      confidence += <span class="hljs-number">0.2</span>;
      claimType = <span class="hljs-string">'conclusion'</span>;
      indicators.push({
        <span class="hljs-keyword">type</span>: <span class="hljs-string">'discourse'</span>,
        value: match[<span class="hljs-number">0</span>],
        position: sentence.charStart + (match.index || <span class="hljs-number">0</span>),
        weight: <span class="hljs-number">0.2</span>
      });
    }
    
    <span class="hljs-comment">// Check for premise markers</span>
    <span class="hljs-keyword">const</span> premiseMatches = sentence.text.matchAll(premiseMarkers);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> match of premiseMatches) {
      confidence += <span class="hljs-number">0.15</span>;
      claimType = <span class="hljs-string">'premise'</span>;
      indicators.push({
        <span class="hljs-keyword">type</span>: <span class="hljs-string">'discourse'</span>,
        value: match[<span class="hljs-number">0</span>],
        position: sentence.charStart + (match.index || <span class="hljs-number">0</span>),
        weight: <span class="hljs-number">0.15</span>
      });
    }
    
    <span class="hljs-comment">// Check for hypothesis markers</span>
    <span class="hljs-keyword">const</span> hypothesisMatches = sentence.text.matchAll(hypothesisMarkers);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> match of hypothesisMatches) {
      confidence += <span class="hljs-number">0.25</span>;
      claimType = <span class="hljs-string">'hypothesis'</span>;
      indicators.push({
        <span class="hljs-keyword">type</span>: <span class="hljs-string">'discourse'</span>,
        value: match[<span class="hljs-number">0</span>],
        position: sentence.charStart + (match.index || <span class="hljs-number">0</span>),
        weight: <span class="hljs-number">0.25</span>
      });
    }
    
    <span class="hljs-keyword">if</span> (confidence &gt; config.sensitivity) {
      candidates.push({
        text: sentence.text,
        charStart: sentence.charStart,
        charEnd: sentence.charEnd,
        confidence: <span class="hljs-built_in">Math</span>.min(confidence, <span class="hljs-number">1.0</span>),
        claimType,
        indicators
      });
    }
  }
  
  <span class="hljs-keyword">return</span> candidates;
}
</div></code></pre>
<hr>
<p><em>Continued in Part 2: Extraction Engine Design (Argument Structure Inference, Scheme Recognition, Evidence Linking)</em></p>
<hr>
<h2 id="part-1-summary">Part 1 Summary</h2>
<p>This first part establishes:</p>
<ol>
<li><strong>Vision</strong>: Bidirectional extraction between Article prose and structured Claims/Arguments</li>
<li><strong>Architecture</strong>: 6-stage pipeline from text to verified, ontology-exportable arguments</li>
<li><strong>Data Models</strong>: <code>ExtractionJob</code>, <code>ExtractedClaim</code>, <code>ExtractedArgument</code>, <code>ArticleClaimAnchor</code></li>
<li><strong>Anchor System</strong>: Reuses existing <code>CommentThread.anchor</code> structure for seamless UI integration</li>
<li><strong>Preprocessing</strong>: AST → text with position mapping</li>
<li><strong>Claim Detection</strong>: Hybrid LLM + rule-based approach with confidence scoring</li>
</ol>
<p><strong>Next in Part 2:</strong></p>
<ul>
<li>Argument structure inference (premise-conclusion detection)</li>
<li>Scheme recognition algorithms</li>
<li>Evidence and citation linking</li>
<li>Discourse connective analysis</li>
</ul>
<hr>
<h2 id="part-2-extraction-engine-design">Part 2: Extraction Engine Design</h2>
<h3 id="6-argument-structure-inference">6. Argument Structure Inference</h3>
<p><strong>Goal</strong>: Given extracted claims, infer which claims function as premises supporting which conclusions.</p>
<h4 id="61-discourse-connective-analysis">6.1 Discourse Connective Analysis</h4>
<p>Discourse connectives are the primary signals for argument structure in natural language:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// lib/extraction/discourse-analysis.ts</span>

<span class="hljs-keyword">interface</span> DiscourseConnective {
  text: <span class="hljs-built_in">string</span>;
  <span class="hljs-keyword">type</span>: <span class="hljs-string">'conclusion'</span> | <span class="hljs-string">'premise'</span> | <span class="hljs-string">'contrast'</span> | <span class="hljs-string">'elaboration'</span> | <span class="hljs-string">'condition'</span>;
  direction: <span class="hljs-string">'forward'</span> | <span class="hljs-string">'backward'</span>;  <span class="hljs-comment">// Does it introduce what follows or references what precedes?</span>
  strength: <span class="hljs-built_in">number</span>;  <span class="hljs-comment">// 0.0-1.0</span>
}

<span class="hljs-keyword">const</span> DISCOURSE_CONNECTIVES: DiscourseConnective[] = [
  <span class="hljs-comment">// Conclusion indicators (forward-looking)</span>
  { text: <span class="hljs-string">'therefore'</span>, <span class="hljs-keyword">type</span>: <span class="hljs-string">'conclusion'</span>, direction: <span class="hljs-string">'forward'</span>, strength: <span class="hljs-number">0.95</span> },
  { text: <span class="hljs-string">'thus'</span>, <span class="hljs-keyword">type</span>: <span class="hljs-string">'conclusion'</span>, direction: <span class="hljs-string">'forward'</span>, strength: <span class="hljs-number">0.90</span> },
  { text: <span class="hljs-string">'hence'</span>, <span class="hljs-keyword">type</span>: <span class="hljs-string">'conclusion'</span>, direction: <span class="hljs-string">'forward'</span>, strength: <span class="hljs-number">0.90</span> },
  { text: <span class="hljs-string">'consequently'</span>, <span class="hljs-keyword">type</span>: <span class="hljs-string">'conclusion'</span>, direction: <span class="hljs-string">'forward'</span>, strength: <span class="hljs-number">0.85</span> },
  { text: <span class="hljs-string">'so'</span>, <span class="hljs-keyword">type</span>: <span class="hljs-string">'conclusion'</span>, direction: <span class="hljs-string">'forward'</span>, strength: <span class="hljs-number">0.60</span> },
  { text: <span class="hljs-string">'it follows that'</span>, <span class="hljs-keyword">type</span>: <span class="hljs-string">'conclusion'</span>, direction: <span class="hljs-string">'forward'</span>, strength: <span class="hljs-number">0.95</span> },
  { text: <span class="hljs-string">'we can conclude'</span>, <span class="hljs-keyword">type</span>: <span class="hljs-string">'conclusion'</span>, direction: <span class="hljs-string">'forward'</span>, strength: <span class="hljs-number">0.95</span> },
  { text: <span class="hljs-string">'this shows that'</span>, <span class="hljs-keyword">type</span>: <span class="hljs-string">'conclusion'</span>, direction: <span class="hljs-string">'forward'</span>, strength: <span class="hljs-number">0.85</span> },
  { text: <span class="hljs-string">'this demonstrates'</span>, <span class="hljs-keyword">type</span>: <span class="hljs-string">'conclusion'</span>, direction: <span class="hljs-string">'forward'</span>, strength: <span class="hljs-number">0.85</span> },
  { text: <span class="hljs-string">'this proves'</span>, <span class="hljs-keyword">type</span>: <span class="hljs-string">'conclusion'</span>, direction: <span class="hljs-string">'forward'</span>, strength: <span class="hljs-number">0.90</span> },
  { text: <span class="hljs-string">'this implies'</span>, <span class="hljs-keyword">type</span>: <span class="hljs-string">'conclusion'</span>, direction: <span class="hljs-string">'forward'</span>, strength: <span class="hljs-number">0.80</span> },
  { text: <span class="hljs-string">'this suggests'</span>, <span class="hljs-keyword">type</span>: <span class="hljs-string">'conclusion'</span>, direction: <span class="hljs-string">'forward'</span>, strength: <span class="hljs-number">0.70</span> },
  
  <span class="hljs-comment">// Premise indicators (backward-looking - introduces evidence for prior claim)</span>
  { text: <span class="hljs-string">'because'</span>, <span class="hljs-keyword">type</span>: <span class="hljs-string">'premise'</span>, direction: <span class="hljs-string">'backward'</span>, strength: <span class="hljs-number">0.90</span> },
  { text: <span class="hljs-string">'since'</span>, <span class="hljs-keyword">type</span>: <span class="hljs-string">'premise'</span>, direction: <span class="hljs-string">'backward'</span>, strength: <span class="hljs-number">0.85</span> },
  { text: <span class="hljs-string">'for'</span>, <span class="hljs-keyword">type</span>: <span class="hljs-string">'premise'</span>, direction: <span class="hljs-string">'backward'</span>, strength: <span class="hljs-number">0.50</span> },
  { text: <span class="hljs-string">'given that'</span>, <span class="hljs-keyword">type</span>: <span class="hljs-string">'premise'</span>, direction: <span class="hljs-string">'backward'</span>, strength: <span class="hljs-number">0.90</span> },
  { text: <span class="hljs-string">'as'</span>, <span class="hljs-keyword">type</span>: <span class="hljs-string">'premise'</span>, direction: <span class="hljs-string">'backward'</span>, strength: <span class="hljs-number">0.40</span> },
  { text: <span class="hljs-string">'the reason is'</span>, <span class="hljs-keyword">type</span>: <span class="hljs-string">'premise'</span>, direction: <span class="hljs-string">'backward'</span>, strength: <span class="hljs-number">0.95</span> },
  { text: <span class="hljs-string">'this is because'</span>, <span class="hljs-keyword">type</span>: <span class="hljs-string">'premise'</span>, direction: <span class="hljs-string">'backward'</span>, strength: <span class="hljs-number">0.95</span> },
  { text: <span class="hljs-string">'due to'</span>, <span class="hljs-keyword">type</span>: <span class="hljs-string">'premise'</span>, direction: <span class="hljs-string">'backward'</span>, strength: <span class="hljs-number">0.80</span> },
  { text: <span class="hljs-string">'on the grounds that'</span>, <span class="hljs-keyword">type</span>: <span class="hljs-string">'premise'</span>, direction: <span class="hljs-string">'backward'</span>, strength: <span class="hljs-number">0.95</span> },
  
  <span class="hljs-comment">// Contrast (may indicate attack or alternative)</span>
  { text: <span class="hljs-string">'however'</span>, <span class="hljs-keyword">type</span>: <span class="hljs-string">'contrast'</span>, direction: <span class="hljs-string">'forward'</span>, strength: <span class="hljs-number">0.80</span> },
  { text: <span class="hljs-string">'but'</span>, <span class="hljs-keyword">type</span>: <span class="hljs-string">'contrast'</span>, direction: <span class="hljs-string">'forward'</span>, strength: <span class="hljs-number">0.70</span> },
  { text: <span class="hljs-string">'although'</span>, <span class="hljs-keyword">type</span>: <span class="hljs-string">'contrast'</span>, direction: <span class="hljs-string">'forward'</span>, strength: <span class="hljs-number">0.75</span> },
  { text: <span class="hljs-string">'nevertheless'</span>, <span class="hljs-keyword">type</span>: <span class="hljs-string">'contrast'</span>, direction: <span class="hljs-string">'forward'</span>, strength: <span class="hljs-number">0.80</span> },
  { text: <span class="hljs-string">'on the other hand'</span>, <span class="hljs-keyword">type</span>: <span class="hljs-string">'contrast'</span>, direction: <span class="hljs-string">'forward'</span>, strength: <span class="hljs-number">0.85</span> },
  
  <span class="hljs-comment">// Conditional (may indicate defeasible reasoning)</span>
  { text: <span class="hljs-string">'if'</span>, <span class="hljs-keyword">type</span>: <span class="hljs-string">'condition'</span>, direction: <span class="hljs-string">'forward'</span>, strength: <span class="hljs-number">0.70</span> },
  { text: <span class="hljs-string">'provided that'</span>, <span class="hljs-keyword">type</span>: <span class="hljs-string">'condition'</span>, direction: <span class="hljs-string">'forward'</span>, strength: <span class="hljs-number">0.85</span> },
  { text: <span class="hljs-string">'assuming'</span>, <span class="hljs-keyword">type</span>: <span class="hljs-string">'condition'</span>, direction: <span class="hljs-string">'forward'</span>, strength: <span class="hljs-number">0.80</span> },
  { text: <span class="hljs-string">'unless'</span>, <span class="hljs-keyword">type</span>: <span class="hljs-string">'condition'</span>, direction: <span class="hljs-string">'forward'</span>, strength: <span class="hljs-number">0.80</span> },
];

<span class="hljs-keyword">interface</span> DiscourseRelation {
  sourceClaimId: <span class="hljs-built_in">string</span>;
  targetClaimId: <span class="hljs-built_in">string</span>;
  relationType: <span class="hljs-string">'supports'</span> | <span class="hljs-string">'attacks'</span> | <span class="hljs-string">'conditions'</span> | <span class="hljs-string">'elaborates'</span>;
  connective?: DiscourseConnective;
  confidence: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inferDiscourseRelations</span>(<span class="hljs-params">
  claims: ExtractedClaimData[],
  doc: PreprocessedDocument
</span>): <span class="hljs-title">DiscourseRelation</span>[] </span>{
  <span class="hljs-keyword">const</span> relations: DiscourseRelation[] = [];
  
  <span class="hljs-comment">// Sort claims by position in document</span>
  <span class="hljs-keyword">const</span> sortedClaims = [...claims].sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> 
    a.anchor.startPath.join(<span class="hljs-string">','</span>).localeCompare(b.anchor.startPath.join(<span class="hljs-string">','</span>))
  );
  
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; sortedClaims.length; i++) {
    <span class="hljs-keyword">const</span> claim = sortedClaims[i];
    
    <span class="hljs-comment">// Check for connectives within claim text</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> connective of DISCOURSE_CONNECTIVES) {
      <span class="hljs-keyword">const</span> regex = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">`\\b<span class="hljs-subst">${escapeRegex(connective.text)}</span>\\b`</span>, <span class="hljs-string">'gi'</span>);
      <span class="hljs-keyword">const</span> match = regex.exec(claim.text);
      
      <span class="hljs-keyword">if</span> (match) {
        <span class="hljs-keyword">if</span> (connective.direction === <span class="hljs-string">'backward'</span> &amp;&amp; i &gt; <span class="hljs-number">0</span>) {
          <span class="hljs-comment">// This claim provides reason for previous claim</span>
          relations.push({
            sourceClaimId: claim.id,
            targetClaimId: sortedClaims[i - <span class="hljs-number">1</span>].id,
            relationType: <span class="hljs-string">'supports'</span>,
            connective,
            confidence: connective.strength * claim.confidence
          });
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (connective.direction === <span class="hljs-string">'forward'</span> &amp;&amp; i &lt; sortedClaims.length - <span class="hljs-number">1</span>) {
          <span class="hljs-comment">// Previous claims support this claim (it's a conclusion)</span>
          <span class="hljs-comment">// Look back for premises</span>
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, i - <span class="hljs-number">3</span>); j &lt; i; j++) {
            relations.push({
              sourceClaimId: sortedClaims[j].id,
              targetClaimId: claim.id,
              relationType: <span class="hljs-string">'supports'</span>,
              connective,
              confidence: connective.strength * <span class="hljs-number">0.7</span> <span class="hljs-comment">// Decay for distance</span>
            });
          }
        }
      }
    }
  }
  
  <span class="hljs-keyword">return</span> relations;
}
</div></code></pre>
<h4 id="62-argument-assembly-algorithm">6.2 Argument Assembly Algorithm</h4>
<pre class="hljs"><code><div><span class="hljs-comment">// lib/extraction/argument-assembler.ts</span>

<span class="hljs-keyword">interface</span> ArgumentCandidate {
  conclusionId: <span class="hljs-built_in">string</span>;
  premiseIds: <span class="hljs-built_in">string</span>[];
  confidence: <span class="hljs-built_in">number</span>;
  structureType: <span class="hljs-string">'serial'</span> | <span class="hljs-string">'convergent'</span> | <span class="hljs-string">'linked'</span> | <span class="hljs-string">'divergent'</span>;
  inferenceText?: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">interface</span> ArgumentAssemblyConfig {
  minPremises: <span class="hljs-built_in">number</span>;           <span class="hljs-comment">// Minimum premises per argument (default: 1)</span>
  maxPremises: <span class="hljs-built_in">number</span>;           <span class="hljs-comment">// Maximum premises per argument (default: 5)</span>
  minConfidence: <span class="hljs-built_in">number</span>;         <span class="hljs-comment">// Threshold for argument acceptance</span>
  allowImplicitPremises: <span class="hljs-built_in">boolean</span>;
  useLLMForAssembly: <span class="hljs-built_in">boolean</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assembleArguments</span>(<span class="hljs-params">
  claims: ExtractedClaimData[],
  relations: DiscourseRelation[],
  config: ArgumentAssemblyConfig
</span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">ArgumentCandidate</span>[]&gt; </span>{
  <span class="hljs-keyword">const</span> <span class="hljs-built_in">arguments</span>: ArgumentCandidate[] = [];
  
  <span class="hljs-comment">// Group relations by target (potential conclusions)</span>
  <span class="hljs-keyword">const</span> supportsByTarget = <span class="hljs-keyword">new</span> Map&lt;<span class="hljs-built_in">string</span>, DiscourseRelation[]&gt;();
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> rel of relations.filter(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> r.relationType === <span class="hljs-string">'supports'</span>)) {
    <span class="hljs-keyword">const</span> existing = supportsByTarget.get(rel.targetClaimId) || [];
    existing.push(rel);
    supportsByTarget.set(rel.targetClaimId, existing);
  }
  
  <span class="hljs-comment">// Identify claims that are conclusions (have incoming support)</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [conclusionId, supports] of supportsByTarget) {
    <span class="hljs-keyword">if</span> (supports.length &lt; config.minPremises) <span class="hljs-keyword">continue</span>;
    
    <span class="hljs-comment">// Determine structure type</span>
    <span class="hljs-keyword">let</span> structureType: ArgumentCandidate[<span class="hljs-string">'structureType'</span>] = <span class="hljs-string">'convergent'</span>;
    <span class="hljs-keyword">if</span> (supports.length === <span class="hljs-number">1</span>) {
      structureType = <span class="hljs-string">'serial'</span>;
    }
    
    <span class="hljs-comment">// Check if premises are linked (jointly required) or convergent (independently sufficient)</span>
    <span class="hljs-comment">// Heuristic: If premises are in same sentence/paragraph, likely linked</span>
    <span class="hljs-keyword">const</span> premiseClaims = supports.map(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> claims.find(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c.id === s.sourceClaimId)!);
    <span class="hljs-keyword">const</span> allSameParagraph = premiseClaims.every(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> 
      areSameParagraph(p.anchor, premiseClaims[<span class="hljs-number">0</span>].anchor)
    );
    <span class="hljs-keyword">if</span> (allSameParagraph &amp;&amp; supports.length &gt; <span class="hljs-number">1</span>) {
      structureType = <span class="hljs-string">'linked'</span>;
    }
    
    <span class="hljs-keyword">const</span> avgConfidence = supports.reduce(<span class="hljs-function">(<span class="hljs-params">sum, s</span>) =&gt;</span> sum + s.confidence, <span class="hljs-number">0</span>) / supports.length;
    
    <span class="hljs-keyword">if</span> (avgConfidence &gt;= config.minConfidence) {
      <span class="hljs-built_in">arguments</span>.push({
        conclusionId,
        premiseIds: supports.map(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> s.sourceClaimId).slice(<span class="hljs-number">0</span>, config.maxPremises),
        confidence: avgConfidence,
        structureType
      });
    }
  }
  
  <span class="hljs-comment">// Optionally use LLM to infer additional arguments and refine structure</span>
  <span class="hljs-keyword">if</span> (config.useLLMForAssembly) {
    <span class="hljs-keyword">const</span> llmArguments = <span class="hljs-keyword">await</span> inferArgumentsWithLLM(claims, <span class="hljs-built_in">arguments</span>);
    <span class="hljs-keyword">return</span> mergeArgumentCandidates(<span class="hljs-built_in">arguments</span>, llmArguments);
  }
  
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>;
}

<span class="hljs-comment">// LLM-assisted argument inference</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inferArgumentsWithLLM</span>(<span class="hljs-params">
  claims: ExtractedClaimData[],
  existingArguments: ArgumentCandidate[]
</span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">ArgumentCandidate</span>[]&gt; </span>{
  
  <span class="hljs-keyword">const</span> ARGUMENT_INFERENCE_PROMPT = <span class="hljs-string">`You are an expert in argumentation analysis. Given the following claims extracted from a document, identify argument structures.

Claims:
<span class="hljs-subst">${claims.map((c, i) =&gt; <span class="hljs-string">`[<span class="hljs-subst">${i}</span>] <span class="hljs-subst">${c.text}</span> (type: <span class="hljs-subst">${c.claimType}</span>, confidence: <span class="hljs-subst">${c.confidence}</span>)`</span>).join(<span class="hljs-string">'\n'</span>)}</span>

Existing argument hypotheses (may be incomplete or incorrect):
<span class="hljs-subst">${existingArguments.map(a =&gt; <span class="hljs-string">`  Conclusion: [<span class="hljs-subst">${claims.findIndex(c =&gt; c.id === a.conclusionId)}</span>], Premises: [<span class="hljs-subst">${a.premiseIds.map(p =&gt; claims.findIndex(c =&gt; c.id === p)).join(<span class="hljs-string">', '</span>)}</span>]`</span>).join(<span class="hljs-string">'\n'</span>)}</span>

For each argument you identify, provide:
1. The conclusion claim (by index)
2. The premise claims (by indices)
3. A brief description of the inference/warrant
4. Whether premises are LINKED (jointly required) or CONVERGENT (independently sufficient)
5. Your confidence (0.0-1.0)

Also identify any IMPLICIT premises that are assumed but not stated. For implicit premises, provide the text of the missing premise.

Return as JSON array of argument objects.`</span>;

  <span class="hljs-comment">// Call LLM and parse response</span>
  <span class="hljs-comment">// ... implementation details ...</span>
  
  <span class="hljs-keyword">return</span> [];
}
</div></code></pre>
<h4 id="63-implicit-premise-reconstruction-enthymeme-detection">6.3 Implicit Premise Reconstruction (Enthymeme Detection)</h4>
<p>Many real-world arguments omit premises that are assumed. The extraction pipeline should detect and optionally reconstruct these:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// lib/extraction/enthymeme-detector.ts</span>

<span class="hljs-keyword">interface</span> ImplicitPremise {
  argumentId: <span class="hljs-built_in">string</span>;
  text: <span class="hljs-built_in">string</span>;                    <span class="hljs-comment">// Reconstructed premise text</span>
  premiseType: <span class="hljs-string">'major'</span> | <span class="hljs-string">'minor'</span>;  <span class="hljs-comment">// Syllogistic role</span>
  confidence: <span class="hljs-built_in">number</span>;
  justification: <span class="hljs-built_in">string</span>;           <span class="hljs-comment">// Why this premise is implied</span>
}

<span class="hljs-keyword">const</span> ENTHYMEME_DETECTION_PROMPT = <span class="hljs-string">`Analyze this argument for missing (implicit) premises.

Argument:
Conclusion: "{conclusion}"
Explicit Premises: {premises}

Many arguments omit premises that are assumed to be obvious or shared knowledge. These are called "enthymemes."

Common patterns:
1. Missing major premise: "Socrates is a man, therefore Socrates is mortal" (missing: "All men are mortal")
2. Missing minor premise: "All philosophers are wise, therefore Socrates is wise" (missing: "Socrates is a philosopher")
3. Missing warrant: "The data shows X, therefore Y" (missing: the principle connecting X to Y)

Identify any implicit premises needed to make this argument valid. For each:
1. State the missing premise
2. Indicate whether it's a major or minor premise
3. Explain why it's implied
4. Rate your confidence (0.0-1.0)

Return as JSON array.`</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">detectEnthymemes</span>(<span class="hljs-params">
  argument: ArgumentCandidate,
  claims: ExtractedClaimData[]
</span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">ImplicitPremise</span>[]&gt; </span>{
  <span class="hljs-keyword">const</span> conclusion = claims.find(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c.id === argument.conclusionId);
  <span class="hljs-keyword">const</span> premises = argument.premiseIds.map(<span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> claims.find(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c.id === id));
  
  <span class="hljs-comment">// Use LLM to detect missing premises</span>
  <span class="hljs-keyword">const</span> prompt = ENTHYMEME_DETECTION_PROMPT
    .replace(<span class="hljs-string">'{conclusion}'</span>, conclusion?.text || <span class="hljs-string">''</span>)
    .replace(<span class="hljs-string">'{premises}'</span>, premises.map(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> <span class="hljs-string">`- <span class="hljs-subst">${p?.text}</span>`</span>).join(<span class="hljs-string">'\n'</span>));
  
  <span class="hljs-comment">// ... LLM call implementation ...</span>
  
  <span class="hljs-keyword">return</span> [];
}
</div></code></pre>
<hr>
<h3 id="7-scheme-recognition">7. Scheme Recognition</h3>
<p><strong>Goal</strong>: Classify extracted arguments according to Walton's argumentation scheme taxonomy.</p>
<h4 id="71-scheme-matching-architecture">7.1 Scheme Matching Architecture</h4>
<pre class="hljs"><code><div>┌─────────────────────────────────────────────────────────────────────────────┐
│                    SCHEME RECOGNITION PIPELINE                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  INPUT: Argument (conclusion + premises + optional inference text)    │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                     │                                        │
│         ┌───────────────────────────┼───────────────────────────┐           │
│         ▼                           ▼                           ▼           │
│  ┌─────────────────┐  ┌─────────────────────────┐  ┌─────────────────────┐ │
│  │ RULE-BASED      │  │ EMBEDDING-BASED         │  │ LLM-BASED           │ │
│  │ MATCHER         │  │ MATCHER                 │  │ CLASSIFIER          │ │
│  │                 │  │                         │  │                     │ │
│  │ • Pattern regex │  │ • Embed argument text   │  │ • Zero-shot prompt  │ │
│  │ • Keyword lists │  │ • Compare to scheme     │  │ • Few-shot examples │ │
│  │ • Template fill │  │   embeddings            │  │ • Chain-of-thought  │ │
│  │                 │  │ • Cosine similarity     │  │                     │ │
│  └────────┬────────┘  └───────────┬─────────────┘  └──────────┬──────────┘ │
│           │                       │                           │             │
│           └───────────────────────┴───────────────────────────┘             │
│                                     │                                        │
│                                     ▼                                        │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  ENSEMBLE SCORER                                                       │  │
│  │  • Weighted combination of matcher scores                             │  │
│  │  • Multi-label classification (argument may match multiple schemes)   │  │
│  │  • Threshold filtering                                                │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                     │                                        │
│                                     ▼                                        │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  OUTPUT: Ranked scheme matches with confidence scores                  │  │
│  │  [{ schemeId: 'expert_opinion', confidence: 0.87 },                   │  │
│  │   { schemeId: 'position_to_know', confidence: 0.62 }, ...]            │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
</div></code></pre>
<h4 id="72-rule-based-scheme-matcher">7.2 Rule-Based Scheme Matcher</h4>
<pre class="hljs"><code><div><span class="hljs-comment">// lib/extraction/scheme-matcher.ts</span>

<span class="hljs-keyword">interface</span> SchemePattern {
  schemeKey: <span class="hljs-built_in">string</span>;
  conclusionPatterns: <span class="hljs-built_in">RegExp</span>[];
  premisePatterns: <span class="hljs-built_in">RegExp</span>[];
  requiredKeywords: <span class="hljs-built_in">string</span>[];
  optionalKeywords: <span class="hljs-built_in">string</span>[];
  baseScore: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">const</span> SCHEME_PATTERNS: SchemePattern[] = [
  <span class="hljs-comment">// Argument from Expert Opinion</span>
  {
    schemeKey: <span class="hljs-string">'expert_opinion'</span>,
    conclusionPatterns: [
      <span class="hljs-regexp">/(?:is|are)\s+(?:true|correct|valid|plausible)/i</span>,
      <span class="hljs-regexp">/should\s+be\s+(?:accepted|believed)/i</span>
    ],
    premisePatterns: [
      <span class="hljs-regexp">/(?:expert|authority|specialist|professor|doctor|scientist)/i</span>,
      <span class="hljs-regexp">/(?:according to|states?|claims?|argues?|shows?)/i</span>,
      <span class="hljs-regexp">/(?:in the field of|domain of|area of)/i</span>
    ],
    requiredKeywords: [<span class="hljs-string">'expert'</span>, <span class="hljs-string">'authority'</span>, <span class="hljs-string">'specialist'</span>, <span class="hljs-string">'professor'</span>, <span class="hljs-string">'researcher'</span>],
    optionalKeywords: [<span class="hljs-string">'credible'</span>, <span class="hljs-string">'qualified'</span>, <span class="hljs-string">'renowned'</span>, <span class="hljs-string">'leading'</span>],
    baseScore: <span class="hljs-number">0.6</span>
  },
  
  <span class="hljs-comment">// Argument from Analogy</span>
  {
    schemeKey: <span class="hljs-string">'analogy'</span>,
    conclusionPatterns: [
      <span class="hljs-regexp">/(?:similarly|likewise|in the same way)/i</span>,
      <span class="hljs-regexp">/(?:just as|like|as with)/i</span>
    ],
    premisePatterns: [
      <span class="hljs-regexp">/(?:similar|analogous|comparable|like|same as)/i</span>,
      <span class="hljs-regexp">/(?:in case|in the case of)/i</span>
    ],
    requiredKeywords: [<span class="hljs-string">'similar'</span>, <span class="hljs-string">'like'</span>, <span class="hljs-string">'same'</span>, <span class="hljs-string">'analogous'</span>, <span class="hljs-string">'comparable'</span>],
    optionalKeywords: [<span class="hljs-string">'parallel'</span>, <span class="hljs-string">'resembles'</span>, <span class="hljs-string">'corresponds'</span>],
    baseScore: <span class="hljs-number">0.5</span>
  },
  
  <span class="hljs-comment">// Argument from Cause to Effect</span>
  {
    schemeKey: <span class="hljs-string">'cause_to_effect'</span>,
    conclusionPatterns: [
      <span class="hljs-regexp">/will\s+(?:cause|lead to|result in|produce)/i</span>,
      <span class="hljs-regexp">/(?:effect|consequence|outcome)\s+will be/i</span>
    ],
    premisePatterns: [
      <span class="hljs-regexp">/(?:causes?|leads? to|results? in|produces?)/i</span>,
      <span class="hljs-regexp">/(?:whenever|if|when).*(?:then|therefore)/i</span>
    ],
    requiredKeywords: [<span class="hljs-string">'cause'</span>, <span class="hljs-string">'effect'</span>, <span class="hljs-string">'result'</span>, <span class="hljs-string">'lead'</span>, <span class="hljs-string">'produce'</span>],
    optionalKeywords: [<span class="hljs-string">'mechanism'</span>, <span class="hljs-string">'process'</span>, <span class="hljs-string">'consequence'</span>],
    baseScore: <span class="hljs-number">0.6</span>
  },
  
  <span class="hljs-comment">// Argument from Sign</span>
  {
    schemeKey: <span class="hljs-string">'sign'</span>,
    conclusionPatterns: [
      <span class="hljs-regexp">/(?:indicates?|suggests?|shows?|means?)/i</span>,
      <span class="hljs-regexp">/(?:is a sign|is evidence|demonstrates?)/i</span>
    ],
    premisePatterns: [
      <span class="hljs-regexp">/(?:sign|symptom|indicator|evidence|signal)/i</span>,
      <span class="hljs-regexp">/(?:whenever we see|presence of|occurrence of)/i</span>
    ],
    requiredKeywords: [<span class="hljs-string">'sign'</span>, <span class="hljs-string">'indicator'</span>, <span class="hljs-string">'symptom'</span>, <span class="hljs-string">'evidence'</span>],
    optionalKeywords: [<span class="hljs-string">'signal'</span>, <span class="hljs-string">'marker'</span>, <span class="hljs-string">'manifestation'</span>],
    baseScore: <span class="hljs-number">0.5</span>
  },
  
  <span class="hljs-comment">// Argument from Example</span>
  {
    schemeKey: <span class="hljs-string">'example'</span>,
    conclusionPatterns: [
      <span class="hljs-regexp">/(?:in general|generally|typically|usually)/i</span>,
      <span class="hljs-regexp">/(?:we can generalize|this shows that)/i</span>
    ],
    premisePatterns: [
      <span class="hljs-regexp">/(?:for example|for instance|such as|like|e\.g\.)/i</span>,
      <span class="hljs-regexp">/(?:in this case|in the case of|consider)/i</span>
    ],
    requiredKeywords: [<span class="hljs-string">'example'</span>, <span class="hljs-string">'instance'</span>, <span class="hljs-string">'case'</span>],
    optionalKeywords: [<span class="hljs-string">'illustration'</span>, <span class="hljs-string">'sample'</span>, <span class="hljs-string">'demonstration'</span>],
    baseScore: <span class="hljs-number">0.5</span>
  },
  
  <span class="hljs-comment">// Practical Reasoning (Action-based)</span>
  {
    schemeKey: <span class="hljs-string">'practical_reasoning'</span>,
    conclusionPatterns: [
      <span class="hljs-regexp">/(?:should|ought to|must|need to)\s+(?:\w+)/i</span>,
      <span class="hljs-regexp">/(?:best course|right thing|proper action)/i</span>
    ],
    premisePatterns: [
      <span class="hljs-regexp">/(?:goal|objective|aim|want|desire)/i</span>,
      <span class="hljs-regexp">/(?:achieve|accomplish|attain|reach)/i</span>,
      <span class="hljs-regexp">/(?:means|way|method|action)/i</span>
    ],
    requiredKeywords: [<span class="hljs-string">'should'</span>, <span class="hljs-string">'goal'</span>, <span class="hljs-string">'action'</span>, <span class="hljs-string">'achieve'</span>],
    optionalKeywords: [<span class="hljs-string">'means'</span>, <span class="hljs-string">'end'</span>, <span class="hljs-string">'purpose'</span>, <span class="hljs-string">'intention'</span>],
    baseScore: <span class="hljs-number">0.6</span>
  },
  
  <span class="hljs-comment">// Argument from Consequences</span>
  {
    schemeKey: <span class="hljs-string">'negative_consequences'</span>,
    conclusionPatterns: [
      <span class="hljs-regexp">/(?:should not|ought not|must not)/i</span>,
      <span class="hljs-regexp">/(?:avoid|prevent|stop)/i</span>
    ],
    premisePatterns: [
      <span class="hljs-regexp">/(?:will lead to|will cause|will result in)/i</span>,
      <span class="hljs-regexp">/(?:bad|negative|harmful|dangerous|costly)/i</span>
    ],
    requiredKeywords: [<span class="hljs-string">'consequence'</span>, <span class="hljs-string">'result'</span>, <span class="hljs-string">'lead'</span>],
    optionalKeywords: [<span class="hljs-string">'negative'</span>, <span class="hljs-string">'harmful'</span>, <span class="hljs-string">'dangerous'</span>, <span class="hljs-string">'bad'</span>],
    baseScore: <span class="hljs-number">0.55</span>
  },
  
  <span class="hljs-comment">// ... additional scheme patterns ...</span>
];

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">matchSchemesRuleBased</span>(<span class="hljs-params">
  argument: ArgumentCandidate,
  claims: ExtractedClaimData[]
</span>): </span>{ schemeKey: <span class="hljs-built_in">string</span>; confidence: <span class="hljs-built_in">number</span>; matchDetails: <span class="hljs-built_in">string</span>[] }[] {
  <span class="hljs-keyword">const</span> conclusion = claims.find(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c.id === argument.conclusionId);
  <span class="hljs-keyword">const</span> premises = argument.premiseIds.map(<span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> claims.find(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c.id === id)).filter(<span class="hljs-built_in">Boolean</span>);
  
  <span class="hljs-keyword">const</span> allText = [conclusion?.text, ...premises.map(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> p?.text)].filter(<span class="hljs-built_in">Boolean</span>).join(<span class="hljs-string">' '</span>);
  <span class="hljs-keyword">const</span> matches: { schemeKey: <span class="hljs-built_in">string</span>; confidence: <span class="hljs-built_in">number</span>; matchDetails: <span class="hljs-built_in">string</span>[] }[] = [];
  
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> pattern of SCHEME_PATTERNS) {
    <span class="hljs-keyword">let</span> score = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">const</span> details: <span class="hljs-built_in">string</span>[] = [];
    
    <span class="hljs-comment">// Check conclusion patterns</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> regex of pattern.conclusionPatterns) {
      <span class="hljs-keyword">if</span> (regex.test(conclusion?.text || <span class="hljs-string">''</span>)) {
        score += <span class="hljs-number">0.2</span>;
        details.push(<span class="hljs-string">`Conclusion matches: <span class="hljs-subst">${regex.source}</span>`</span>);
      }
    }
    
    <span class="hljs-comment">// Check premise patterns</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> regex of pattern.premisePatterns) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> premise of premises) {
        <span class="hljs-keyword">if</span> (regex.test(premise?.text || <span class="hljs-string">''</span>)) {
          score += <span class="hljs-number">0.15</span>;
          details.push(<span class="hljs-string">`Premise matches: <span class="hljs-subst">${regex.source}</span>`</span>);
        }
      }
    }
    
    <span class="hljs-comment">// Check required keywords</span>
    <span class="hljs-keyword">const</span> foundRequired = pattern.requiredKeywords.filter(<span class="hljs-function"><span class="hljs-params">kw</span> =&gt;</span> 
      allText.toLowerCase().includes(kw.toLowerCase())
    );
    <span class="hljs-keyword">if</span> (foundRequired.length &gt; <span class="hljs-number">0</span>) {
      score += <span class="hljs-number">0.1</span> * foundRequired.length;
      details.push(<span class="hljs-string">`Required keywords: <span class="hljs-subst">${foundRequired.join(<span class="hljs-string">', '</span>)}</span>`</span>);
    }
    
    <span class="hljs-comment">// Check optional keywords</span>
    <span class="hljs-keyword">const</span> foundOptional = pattern.optionalKeywords.filter(<span class="hljs-function"><span class="hljs-params">kw</span> =&gt;</span> 
      allText.toLowerCase().includes(kw.toLowerCase())
    );
    score += <span class="hljs-number">0.05</span> * foundOptional.length;
    
    <span class="hljs-keyword">const</span> finalScore = <span class="hljs-built_in">Math</span>.min(pattern.baseScore + score, <span class="hljs-number">1.0</span>);
    
    <span class="hljs-keyword">if</span> (finalScore &gt; <span class="hljs-number">0.3</span>) {
      matches.push({
        schemeKey: pattern.schemeKey,
        confidence: finalScore,
        matchDetails: details
      });
    }
  }
  
  <span class="hljs-keyword">return</span> matches.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b.confidence - a.confidence);
}
</div></code></pre>
<h4 id="73-llm-based-scheme-classification">7.3 LLM-Based Scheme Classification</h4>
<pre class="hljs"><code><div><span class="hljs-comment">// lib/extraction/scheme-classifier-llm.ts</span>

<span class="hljs-keyword">const</span> SCHEME_CLASSIFICATION_PROMPT = <span class="hljs-string">`You are an expert in Walton's argumentation schemes. Classify the following argument.

ARGUMENT:
Conclusion: {conclusion}
Premises:
{premises}

AVAILABLE SCHEMES (select all that apply):
1. Expert Opinion - Appeal to an expert's authority in a domain
2. Position to Know - Someone is in a position to know something
3. Analogy - Similarity between cases supports similar conclusion
4. Cause to Effect - Known cause leads to predicted effect
5. Effect to Cause - Observed effect implies a cause
6. Sign - Observable sign indicates underlying condition
7. Example - Specific instance supports generalization
8. Precedent - Past case guides current decision
9. Practical Reasoning - Goal + means to achieve it
10. Negative Consequences - Action leads to bad outcomes
11. Positive Consequences - Action leads to good outcomes
12. Popular Opinion - Many people believe it
13. Commitment - Person's past commitment implies current stance
14. Verbal Classification - Definition-based reasoning
15. Sunk Costs - Past investment justifies continued action
16. Slippery Slope - Action leads to chain of undesirable events

For each matching scheme:
1. Name the scheme
2. Explain how the argument instantiates the scheme pattern
3. Rate your confidence (0.0-1.0)
4. List applicable critical questions for this instantiation

Return as JSON array.`</span>;

<span class="hljs-keyword">interface</span> LLMSchemeMatch {
  schemeKey: <span class="hljs-built_in">string</span>;
  schemeName: <span class="hljs-built_in">string</span>;
  explanation: <span class="hljs-built_in">string</span>;
  confidence: <span class="hljs-built_in">number</span>;
  applicableCriticalQuestions: <span class="hljs-built_in">string</span>[];
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">classifySchemesWithLLM</span>(<span class="hljs-params">
  argument: ArgumentCandidate,
  claims: ExtractedClaimData[]
</span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">LLMSchemeMatch</span>[]&gt; </span>{
  <span class="hljs-keyword">const</span> conclusion = claims.find(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c.id === argument.conclusionId);
  <span class="hljs-keyword">const</span> premises = argument.premiseIds.map(<span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> claims.find(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c.id === id)).filter(<span class="hljs-built_in">Boolean</span>);
  
  <span class="hljs-keyword">const</span> prompt = SCHEME_CLASSIFICATION_PROMPT
    .replace(<span class="hljs-string">'{conclusion}'</span>, conclusion?.text || <span class="hljs-string">''</span>)
    .replace(<span class="hljs-string">'{premises}'</span>, premises.map(<span class="hljs-function">(<span class="hljs-params">p, i</span>) =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">${i + <span class="hljs-number">1</span>}</span>. <span class="hljs-subst">${p?.text}</span>`</span>).join(<span class="hljs-string">'\n'</span>));
  
  <span class="hljs-comment">// Call LLM API</span>
  <span class="hljs-comment">// ... implementation ...</span>
  
  <span class="hljs-keyword">return</span> [];
}
</div></code></pre>
<hr>
<h3 id="8-evidence--citation-linking">8. Evidence &amp; Citation Linking</h3>
<p><strong>Goal</strong>: Connect extracted claims to citations and sources present in the article.</p>
<h4 id="81-citation-detection-in-article-ast">8.1 Citation Detection in Article AST</h4>
<pre class="hljs"><code><div><span class="hljs-comment">// lib/extraction/citation-linker.ts</span>

<span class="hljs-keyword">interface</span> InlineCitation {
  text: <span class="hljs-built_in">string</span>;              <span class="hljs-comment">// "[1]", "(Smith 2023)", "[Smith et al., 2023]"</span>
  anchor: Anchor;
  citationStyle: <span class="hljs-string">'numeric'</span> | <span class="hljs-string">'author_year'</span> | <span class="hljs-string">'footnote'</span>;
  parsedAuthors?: <span class="hljs-built_in">string</span>[];
  parsedYear?: <span class="hljs-built_in">number</span>;
  parsedNumber?: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">interface</span> ResolvedCitation <span class="hljs-keyword">extends</span> InlineCitation {
  sourceId?: <span class="hljs-built_in">string</span>;         <span class="hljs-comment">// Matched Source.id</span>
  doi?: <span class="hljs-built_in">string</span>;
  url?: <span class="hljs-built_in">string</span>;
  confidence: <span class="hljs-built_in">number</span>;
}

<span class="hljs-comment">// Regex patterns for common citation formats</span>
<span class="hljs-keyword">const</span> CITATION_PATTERNS = [
  <span class="hljs-comment">// Numeric: [1], [1,2], [1-3]</span>
  { regex: <span class="hljs-regexp">/\[(\d+(?:[,\-–]\d+)*)\]/g</span>, style: <span class="hljs-string">'numeric'</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span> },
  
  <span class="hljs-comment">// Author-year: (Smith 2023), (Smith &amp; Jones, 2023), (Smith et al., 2023)</span>
  { 
    regex: <span class="hljs-regexp">/\(([A-Z][a-z]+(?:\s+(?:&amp;|and)\s+[A-Z][a-z]+)?(?:\s+et\s+al\.)?),?\s*(\d{4})\)/g</span>, 
    style: <span class="hljs-string">'author_year'</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span> 
  },
  
  <span class="hljs-comment">// Bracketed author-year: [Smith 2023]</span>
  {
    regex: <span class="hljs-regexp">/\[([A-Z][a-z]+(?:\s+(?:&amp;|and)\s+[A-Z][a-z]+)?(?:\s+et\s+al\.)?),?\s*(\d{4})\]/g</span>,
    style: <span class="hljs-string">'author_year'</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>
  }
];

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">detectCitations</span>(<span class="hljs-params">doc: PreprocessedDocument</span>): <span class="hljs-title">InlineCitation</span>[] </span>{
  <span class="hljs-keyword">const</span> citations: InlineCitation[] = [];
  
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> { regex, style } of CITATION_PATTERNS) {
    <span class="hljs-keyword">let</span> match;
    <span class="hljs-keyword">while</span> ((match = regex.exec(doc.fullText)) !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">const</span> anchor = doc.getAnchorForRange(match.index, match.index + match[<span class="hljs-number">0</span>].length);
      
      <span class="hljs-keyword">const</span> citation: InlineCitation = {
        text: match[<span class="hljs-number">0</span>],
        anchor,
        citationStyle: style
      };
      
      <span class="hljs-keyword">if</span> (style === <span class="hljs-string">'numeric'</span>) {
        citation.parsedNumber = <span class="hljs-built_in">parseInt</span>(match[<span class="hljs-number">1</span>], <span class="hljs-number">10</span>);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (style === <span class="hljs-string">'author_year'</span>) {
        citation.parsedAuthors = [match[<span class="hljs-number">1</span>]];
        citation.parsedYear = <span class="hljs-built_in">parseInt</span>(match[<span class="hljs-number">2</span>], <span class="hljs-number">10</span>);
      }
      
      citations.push(citation);
    }
  }
  
  <span class="hljs-keyword">return</span> citations;
}
</div></code></pre>
<h4 id="82-linking-claims-to-citations">8.2 Linking Claims to Citations</h4>
<pre class="hljs"><code><div><span class="hljs-comment">// lib/extraction/evidence-matcher.ts</span>

<span class="hljs-keyword">interface</span> ClaimEvidenceLink {
  claimId: <span class="hljs-built_in">string</span>;
  citationAnchor: Anchor;
  citationText: <span class="hljs-built_in">string</span>;
  linkType: <span class="hljs-string">'inline'</span> | <span class="hljs-string">'following'</span> | <span class="hljs-string">'paragraph'</span>;
  distance: <span class="hljs-built_in">number</span>;          <span class="hljs-comment">// Character distance from claim</span>
  confidence: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">linkClaimsToEvidence</span>(<span class="hljs-params">
  claims: ExtractedClaimData[],
  citations: InlineCitation[],
  doc: PreprocessedDocument
</span>): <span class="hljs-title">ClaimEvidenceLink</span>[] </span>{
  <span class="hljs-keyword">const</span> links: ClaimEvidenceLink[] = [];
  
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> claim of claims) {
    <span class="hljs-keyword">const</span> claimEnd = getCharPositionFromAnchor(claim.anchor, doc);
    
    <span class="hljs-comment">// Find citations within or immediately after claim</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> citation of citations) {
      <span class="hljs-keyword">const</span> citationStart = getCharPositionFromAnchor(citation.anchor, doc);
      <span class="hljs-keyword">const</span> distance = citationStart - claimEnd;
      
      <span class="hljs-comment">// Citation is within claim text</span>
      <span class="hljs-keyword">if</span> (isAnchorWithin(citation.anchor, claim.anchor)) {
        links.push({
          claimId: claim.id,
          citationAnchor: citation.anchor,
          citationText: citation.text,
          linkType: <span class="hljs-string">'inline'</span>,
          distance: <span class="hljs-number">0</span>,
          confidence: <span class="hljs-number">0.95</span>
        });
        <span class="hljs-keyword">continue</span>;
      }
      
      <span class="hljs-comment">// Citation immediately follows claim (within 50 chars)</span>
      <span class="hljs-keyword">if</span> (distance &gt;= <span class="hljs-number">0</span> &amp;&amp; distance &lt; <span class="hljs-number">50</span>) {
        links.push({
          claimId: claim.id,
          citationAnchor: citation.anchor,
          citationText: citation.text,
          linkType: <span class="hljs-string">'following'</span>,
          distance,
          confidence: <span class="hljs-number">0.85</span> - (distance * <span class="hljs-number">0.005</span>)
        });
        <span class="hljs-keyword">continue</span>;
      }
      
      <span class="hljs-comment">// Citation is in same paragraph</span>
      <span class="hljs-keyword">if</span> (distance &gt;= <span class="hljs-number">0</span> &amp;&amp; distance &lt; <span class="hljs-number">500</span> &amp;&amp; areSameParagraph(claim.anchor, citation.anchor)) {
        links.push({
          claimId: claim.id,
          citationAnchor: citation.anchor,
          citationText: citation.text,
          linkType: <span class="hljs-string">'paragraph'</span>,
          distance,
          confidence: <span class="hljs-number">0.5</span> - (distance * <span class="hljs-number">0.001</span>)
        });
      }
    }
  }
  
  <span class="hljs-keyword">return</span> links.filter(<span class="hljs-function"><span class="hljs-params">l</span> =&gt;</span> l.confidence &gt; <span class="hljs-number">0.3</span>);
}
</div></code></pre>
<hr>
<h3 id="9-complete-extraction-orchestrator">9. Complete Extraction Orchestrator</h3>
<pre class="hljs"><code><div><span class="hljs-comment">// lib/extraction/orchestrator.ts</span>

<span class="hljs-keyword">import</span> { preprocessArticle } <span class="hljs-keyword">from</span> <span class="hljs-string">'./preprocessor'</span>;
<span class="hljs-keyword">import</span> { detectClaims } <span class="hljs-keyword">from</span> <span class="hljs-string">'./claim-detector'</span>;
<span class="hljs-keyword">import</span> { inferDiscourseRelations, assembleArguments } <span class="hljs-keyword">from</span> <span class="hljs-string">'./argument-assembler'</span>;
<span class="hljs-keyword">import</span> { matchSchemesRuleBased, classifySchemesWithLLM } <span class="hljs-keyword">from</span> <span class="hljs-string">'./scheme-matcher'</span>;
<span class="hljs-keyword">import</span> { detectCitations, linkClaimsToEvidence } <span class="hljs-keyword">from</span> <span class="hljs-string">'./citation-linker'</span>;
<span class="hljs-keyword">import</span> { generateAnchors } <span class="hljs-keyword">from</span> <span class="hljs-string">'./anchor-generator'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> ExtractionConfig {
  <span class="hljs-comment">// Claim detection</span>
  claimModel: <span class="hljs-string">'gpt-4'</span> | <span class="hljs-string">'claude-3'</span> | <span class="hljs-string">'rule-based'</span>;
  claimSensitivity: <span class="hljs-built_in">number</span>;
  includeImplicitClaims: <span class="hljs-built_in">boolean</span>;
  
  <span class="hljs-comment">// Argument assembly</span>
  minPremises: <span class="hljs-built_in">number</span>;
  maxPremises: <span class="hljs-built_in">number</span>;
  argumentMinConfidence: <span class="hljs-built_in">number</span>;
  useLLMForArguments: <span class="hljs-built_in">boolean</span>;
  
  <span class="hljs-comment">// Scheme recognition</span>
  schemeMatcherWeights: {
    ruleBased: <span class="hljs-built_in">number</span>;
    embedding: <span class="hljs-built_in">number</span>;
    llm: <span class="hljs-built_in">number</span>;
  };
  
  <span class="hljs-comment">// Evidence linking</span>
  linkCitations: <span class="hljs-built_in">boolean</span>;
  resolveDOIs: <span class="hljs-built_in">boolean</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extractFromArticle</span>(<span class="hljs-params">
  articleId: <span class="hljs-built_in">string</span>,
  astJson: JSONContent,
  config: ExtractionConfig
</span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">ExtractionResult</span>&gt; </span>{
  <span class="hljs-keyword">const</span> startTime = <span class="hljs-built_in">Date</span>.now();
  
  <span class="hljs-comment">// Stage 1: Preprocess</span>
  <span class="hljs-keyword">const</span> doc = preprocessArticle(astJson);
  
  <span class="hljs-comment">// Stage 2: Detect claims</span>
  <span class="hljs-keyword">const</span> claimCandidates = <span class="hljs-keyword">await</span> detectClaims(doc, {
    model: config.claimModel,
    sensitivity: config.claimSensitivity,
    maxClaimsPerSection: <span class="hljs-number">20</span>,
    includeImplicitClaims: config.includeImplicitClaims
  });
  
  <span class="hljs-comment">// Stage 3: Generate anchors for claims</span>
  <span class="hljs-keyword">const</span> claims = claimCandidates.map(<span class="hljs-function">(<span class="hljs-params">candidate, i</span>) =&gt;</span> ({
    id: <span class="hljs-string">`claim-<span class="hljs-subst">${i}</span>`</span>,
    text: candidate.text,
    anchor: doc.getAnchorForRange(candidate.charStart, candidate.charEnd),
    sourceText: candidate.text,
    confidence: candidate.confidence,
    claimType: candidate.claimType,
    isImplicit: <span class="hljs-literal">false</span>,
    status: <span class="hljs-string">'PENDING'</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>
  }));
  
  <span class="hljs-comment">// Stage 4: Infer argument structures</span>
  <span class="hljs-keyword">const</span> discourseRelations = inferDiscourseRelations(claims, doc);
  <span class="hljs-keyword">const</span> argumentCandidates = <span class="hljs-keyword">await</span> assembleArguments(claims, discourseRelations, {
    minPremises: config.minPremises,
    maxPremises: config.maxPremises,
    minConfidence: config.argumentMinConfidence,
    allowImplicitPremises: config.includeImplicitClaims,
    useLLMForAssembly: config.useLLMForArguments
  });
  
  <span class="hljs-comment">// Stage 5: Classify schemes</span>
  <span class="hljs-keyword">const</span> <span class="hljs-built_in">arguments</span>: ExtractedArgumentData[] = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> argCandidate of argumentCandidates) {
    <span class="hljs-keyword">const</span> ruleMatches = matchSchemesRuleBased(argCandidate, claims);
    <span class="hljs-keyword">const</span> llmMatches = <span class="hljs-keyword">await</span> classifySchemesWithLLM(argCandidate, claims);
    
    <span class="hljs-keyword">const</span> combinedMatches = combineSchemeMatches(ruleMatches, llmMatches, config.schemeMatcherWeights);
    
    <span class="hljs-built_in">arguments</span>.push({
      id: <span class="hljs-string">`arg-<span class="hljs-subst">${<span class="hljs-built_in">arguments</span>.length}</span>`</span>,
      conclusionId: argCandidate.conclusionId,
      premiseIds: argCandidate.premiseIds,
      primarySchemeId: combinedMatches[<span class="hljs-number">0</span>]?.schemeKey,
      schemeConfidence: combinedMatches[<span class="hljs-number">0</span>]?.confidence,
      alternativeSchemes: combinedMatches.slice(<span class="hljs-number">1</span>),
      confidence: argCandidate.confidence,
      inferenceText: argCandidate.inferenceText,
      discourseMarkers: [] <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> populate from discourse analysis</span>
    });
  }
  
  <span class="hljs-comment">// Stage 6: Link evidence</span>
  <span class="hljs-keyword">let</span> evidence: ExtractedEvidenceData[] = [];
  <span class="hljs-keyword">if</span> (config.linkCitations) {
    <span class="hljs-keyword">const</span> citations = detectCitations(doc);
    <span class="hljs-keyword">const</span> links = linkClaimsToEvidence(claims, citations, doc);
    
    evidence = links.map(<span class="hljs-function"><span class="hljs-params">link</span> =&gt;</span> ({
      claimId: link.claimId,
      citationText: link.citationText,
      citationAnchor: link.citationAnchor,
      evidenceType: <span class="hljs-string">'citation'</span>,
      confidence: link.confidence
    }));
  }
  
  <span class="hljs-keyword">return</span> {
    jobId: <span class="hljs-string">''</span>,  <span class="hljs-comment">// Set by caller</span>
    claims,
    <span class="hljs-built_in">arguments</span>,
    evidence,
    metadata: {
      sourceType: <span class="hljs-string">'article'</span>,
      sourceId: articleId,
      extractorModel: config.claimModel,
      processingTimeMs: <span class="hljs-built_in">Date</span>.now() - startTime
    }
  };
}
</div></code></pre>
<hr>
<p><em>Continued in Part 3: Ontology Conversion &amp; Export (AIF, ASPIC+, CEG)</em></p>
<hr>
<h2 id="part-2-summary">Part 2 Summary</h2>
<p>This part detailed:</p>
<ol>
<li><strong>Discourse Analysis</strong>: Connective-based detection of premise-conclusion relations</li>
<li><strong>Argument Assembly</strong>: Algorithm for grouping claims into structured arguments</li>
<li><strong>Enthymeme Detection</strong>: Identifying and reconstructing implicit premises</li>
<li><strong>Scheme Recognition</strong>:
<ul>
<li>Rule-based pattern matching</li>
<li>LLM-based classification</li>
<li>Ensemble scoring</li>
</ul>
</li>
<li><strong>Evidence Linking</strong>: Connecting claims to inline citations</li>
<li><strong>Extraction Orchestrator</strong>: Full pipeline coordination</li>
</ol>
<p><strong>Next in Part 3:</strong></p>
<ul>
<li>AIF (Argument Interchange Format) conversion</li>
<li>ASPIC+ theory generation</li>
<li>CEG (Carneades Evidence Graph) export</li>
<li>Interoperability standards</li>
</ul>
<hr>
<h2 id="part-3-ontology-conversion--export">Part 3: Ontology Conversion &amp; Export</h2>
<h3 id="10-aif-argument-interchange-format-conversion">10. AIF (Argument Interchange Format) Conversion</h3>
<p><strong>Goal</strong>: Convert extracted arguments to W3C-compliant AIF format for interoperability with external argumentation tools.</p>
<h4 id="101-aif-ontology-overview">10.1 AIF Ontology Overview</h4>
<pre class="hljs"><code><div>┌─────────────────────────────────────────────────────────────────────────────┐
│                         AIF CORE ONTOLOGY                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  NODES (vertices in argument graph)                                  │    │
│  │                                                                      │    │
│  │  ┌───────────────────────────────────────────────────────────────┐  │    │
│  │  │  I-NODES (Information Nodes)                                   │  │    │
│  │  │  • Contain propositional content (claims)                      │  │    │
│  │  │  • Types: Claim, Premise, Conclusion, Evidence                 │  │    │
│  │  └───────────────────────────────────────────────────────────────┘  │    │
│  │                                                                      │    │
│  │  ┌───────────────────────────────────────────────────────────────┐  │    │
│  │  │  S-NODES (Scheme Nodes)                                        │  │    │
│  │  │  • Represent inferential relationships                         │  │    │
│  │  │  • Types:                                                       │  │    │
│  │  │    - RA-Node (Rule of Inference Application)                   │  │    │
│  │  │    - CA-Node (Conflict Application - attacks)                  │  │    │
│  │  │    - PA-Node (Preference Application)                          │  │    │
│  │  └───────────────────────────────────────────────────────────────┘  │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  EDGES (relationships between nodes)                                 │    │
│  │                                                                      │    │
│  │  • Premise → RA-Node (this I-node is premise of inference)          │    │
│  │  • RA-Node → Conclusion (inference produces this I-node)            │    │
│  │  • I-Node → CA-Node → I-Node (attack relationship)                  │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  SCHEME APPLICATION                                                  │    │
│  │                                                                      │    │
│  │  RA-Nodes can be typed by argumentation scheme:                      │    │
│  │  • hasScheme: &quot;Expert Opinion&quot; | &quot;Analogy&quot; | &quot;Cause to Effect&quot; | ...│    │
│  │  • Critical questions attached as potential CA-nodes                 │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
</div></code></pre>
<h4 id="102-mesh-%E2%86%92-aif-type-mappings">10.2 Mesh → AIF Type Mappings</h4>
<pre class="hljs"><code><div><span class="hljs-comment">// lib/export/aif-types.ts</span>

<span class="hljs-comment">// AIF Core Types (based on AIF ontology specification)</span>
<span class="hljs-keyword">interface</span> AIFNode {
  nodeID: <span class="hljs-built_in">string</span>;
  <span class="hljs-keyword">type</span>: <span class="hljs-string">'I'</span> | <span class="hljs-string">'RA'</span> | <span class="hljs-string">'CA'</span> | <span class="hljs-string">'PA'</span> | <span class="hljs-string">'MA'</span> | <span class="hljs-string">'TA'</span>;  <span class="hljs-comment">// I=Info, RA=Rule, CA=Conflict, PA=Pref, MA=Meta, TA=Transition</span>
  text?: <span class="hljs-built_in">string</span>;
  timestamp?: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">interface</span> AIFINode <span class="hljs-keyword">extends</span> AIFNode {
  <span class="hljs-keyword">type</span>: <span class="hljs-string">'I'</span>;
  text: <span class="hljs-built_in">string</span>;
  claimant?: <span class="hljs-built_in">string</span>;           <span class="hljs-comment">// Author/speaker</span>
  source?: <span class="hljs-built_in">string</span>;             <span class="hljs-comment">// External source reference</span>
}

<span class="hljs-keyword">interface</span> AIFRANode <span class="hljs-keyword">extends</span> AIFNode {
  <span class="hljs-keyword">type</span>: <span class="hljs-string">'RA'</span>;
  schemeID?: <span class="hljs-built_in">string</span>;           <span class="hljs-comment">// Reference to argumentation scheme</span>
  schemeName?: <span class="hljs-built_in">string</span>;
  schemeVariant?: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">interface</span> AIFCANode <span class="hljs-keyword">extends</span> AIFNode {
  <span class="hljs-keyword">type</span>: <span class="hljs-string">'CA'</span>;
  conflictType: <span class="hljs-string">'rebut'</span> | <span class="hljs-string">'undercut'</span> | <span class="hljs-string">'undermine'</span>;
}

<span class="hljs-keyword">interface</span> AIFEdge {
  edgeID: <span class="hljs-built_in">string</span>;
  fromID: <span class="hljs-built_in">string</span>;
  toID: <span class="hljs-built_in">string</span>;
  formEdgeID?: <span class="hljs-built_in">string</span>;         <span class="hljs-comment">// Reference to scheme formulation</span>
}

<span class="hljs-keyword">interface</span> AIFGraph {
  nodes: AIFNode[];
  edges: AIFEdge[];
  locutions?: AIFLocution[];   <span class="hljs-comment">// Dialogue moves (optional)</span>
  schemeFulfillments?: AIFSchemeFulfillment[];
}

<span class="hljs-comment">// Mesh → AIF mapping table</span>
<span class="hljs-keyword">const</span> MESH_TO_AIF_TYPE_MAP = {
  <span class="hljs-comment">// Claim types → AIF I-node subtypes</span>
  <span class="hljs-string">'Claim'</span>: <span class="hljs-string">'I'</span>,
  <span class="hljs-string">'Proposition'</span>: <span class="hljs-string">'I'</span>,
  
  <span class="hljs-comment">// Argument → RA-node</span>
  <span class="hljs-string">'Argument'</span>: <span class="hljs-string">'RA'</span>,
  
  <span class="hljs-comment">// Edge types → CA-node conflict types</span>
  <span class="hljs-string">'rebut'</span>: <span class="hljs-string">'rebut'</span>,
  <span class="hljs-string">'undercut'</span>: <span class="hljs-string">'undercut'</span>,
  <span class="hljs-string">'undermine'</span>: <span class="hljs-string">'undermine'</span>,
  
  <span class="hljs-comment">// Scheme keys → AIF scheme references</span>
  <span class="hljs-string">'expert_opinion'</span>: <span class="hljs-string">'scheme:ExpertOpinion'</span>,
  <span class="hljs-string">'analogy'</span>: <span class="hljs-string">'scheme:Analogy'</span>,
  <span class="hljs-string">'cause_to_effect'</span>: <span class="hljs-string">'scheme:CauseToEffect'</span>,
  <span class="hljs-string">'practical_reasoning'</span>: <span class="hljs-string">'scheme:PracticalReasoning'</span>,
  <span class="hljs-comment">// ... etc</span>
};
</div></code></pre>
<h4 id="103-aif-converter-implementation">10.3 AIF Converter Implementation</h4>
<pre class="hljs"><code><div><span class="hljs-comment">// lib/export/aif-converter.ts</span>

<span class="hljs-keyword">import</span> { ExtractedClaimData, ExtractedArgumentData, ExtractionResult } <span class="hljs-keyword">from</span> <span class="hljs-string">'../extraction/types'</span>;

<span class="hljs-keyword">interface</span> AIFConversionOptions {
  includeMetadata: <span class="hljs-built_in">boolean</span>;
  includeLocutions: <span class="hljs-built_in">boolean</span>;        <span class="hljs-comment">// Include dialogue moves</span>
  includeSchemeFulfillments: <span class="hljs-built_in">boolean</span>;
  baseURI: <span class="hljs-built_in">string</span>;                  <span class="hljs-comment">// Base URI for node IDs</span>
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">convertToAIF</span>(<span class="hljs-params">
  result: ExtractionResult,
  options: AIFConversionOptions
</span>): <span class="hljs-title">AIFGraph</span> </span>{
  <span class="hljs-keyword">const</span> nodes: AIFNode[] = [];
  <span class="hljs-keyword">const</span> edges: AIFEdge[] = [];
  
  <span class="hljs-keyword">const</span> claimIdToNodeId = <span class="hljs-keyword">new</span> Map&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt;();
  <span class="hljs-keyword">const</span> argIdToNodeId = <span class="hljs-keyword">new</span> Map&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt;();
  
  <span class="hljs-comment">// Step 1: Create I-nodes for all claims</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> claim of result.claims) {
    <span class="hljs-keyword">const</span> nodeId = <span class="hljs-string">`<span class="hljs-subst">${options.baseURI}</span>/nodes/<span class="hljs-subst">${claim.id}</span>`</span>;
    claimIdToNodeId.set(claim.id, nodeId);
    
    nodes.push({
      nodeID: nodeId,
      <span class="hljs-keyword">type</span>: <span class="hljs-string">'I'</span>,
      text: claim.text,
      timestamp: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toISOString()
    } <span class="hljs-keyword">as</span> AIFINode);
  }
  
  <span class="hljs-comment">// Step 2: Create RA-nodes for arguments and connect premises/conclusions</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> arg of result.arguments) {
    <span class="hljs-keyword">const</span> raNodeId = <span class="hljs-string">`<span class="hljs-subst">${options.baseURI}</span>/nodes/ra-<span class="hljs-subst">${arg.id}</span>`</span>;
    argIdToNodeId.set(arg.id, raNodeId);
    
    <span class="hljs-comment">// Create RA-node</span>
    <span class="hljs-keyword">const</span> raNode: AIFRANode = {
      nodeID: raNodeId,
      <span class="hljs-keyword">type</span>: <span class="hljs-string">'RA'</span>,
      schemeID: arg.primarySchemeId ? <span class="hljs-string">`<span class="hljs-subst">${options.baseURI}</span>/schemes/<span class="hljs-subst">${arg.primarySchemeId}</span>`</span> : <span class="hljs-literal">undefined</span>,
      schemeName: arg.primarySchemeId
    };
    nodes.push(raNode);
    
    <span class="hljs-comment">// Create edges: Premises → RA-node</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> premiseId of arg.premiseIds) {
      <span class="hljs-keyword">const</span> premiseNodeId = claimIdToNodeId.get(premiseId);
      <span class="hljs-keyword">if</span> (premiseNodeId) {
        edges.push({
          edgeID: <span class="hljs-string">`<span class="hljs-subst">${options.baseURI}</span>/edges/premise-<span class="hljs-subst">${premiseId}</span>-<span class="hljs-subst">${arg.id}</span>`</span>,
          fromID: premiseNodeId,
          toID: raNodeId
        });
      }
    }
    
    <span class="hljs-comment">// Create edge: RA-node → Conclusion</span>
    <span class="hljs-keyword">const</span> conclusionNodeId = claimIdToNodeId.get(arg.conclusionId);
    <span class="hljs-keyword">if</span> (conclusionNodeId) {
      edges.push({
        edgeID: <span class="hljs-string">`<span class="hljs-subst">${options.baseURI}</span>/edges/conclusion-<span class="hljs-subst">${arg.id}</span>`</span>,
        fromID: raNodeId,
        toID: conclusionNodeId
      });
    }
  }
  
  <span class="hljs-keyword">return</span> {
    nodes,
    edges,
    locutions: options.includeLocutions ? generateLocutions(result) : <span class="hljs-literal">undefined</span>,
    schemeFulfillments: options.includeSchemeFulfillments ? generateFulfillments(result) : <span class="hljs-literal">undefined</span>
  };
}

<span class="hljs-comment">// Export to AIF-RDF (Turtle format)</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exportAIFToTurtle</span>(<span class="hljs-params">graph: AIFGraph</span>): <span class="hljs-title">string</span> </span>{
  <span class="hljs-keyword">const</span> lines: <span class="hljs-built_in">string</span>[] = [
    <span class="hljs-string">'@prefix aif: &lt;http://www.arg.dundee.ac.uk/aif#&gt; .'</span>,
    <span class="hljs-string">'@prefix mesh: &lt;https://mesh.app/aif/&gt; .'</span>,
    <span class="hljs-string">'@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .'</span>,
    <span class="hljs-string">''</span>
  ];
  
  <span class="hljs-comment">// Serialize nodes</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> node of graph.nodes) {
    lines.push(<span class="hljs-string">`mesh:<span class="hljs-subst">${<span class="hljs-built_in">encodeURIComponent</span>(node.nodeID)}</span> a aif:<span class="hljs-subst">${node.<span class="hljs-keyword">type</span>}</span>-node ;`</span>);
    
    <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">'I'</span> &amp;&amp; (node <span class="hljs-keyword">as</span> AIFINode).text) {
      lines.push(<span class="hljs-string">`    aif:claimText "<span class="hljs-subst">${escapeRDF((node <span class="hljs-keyword">as</span> AIFINode).text)}</span>" ;`</span>);
    }
    
    <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">'RA'</span> &amp;&amp; (node <span class="hljs-keyword">as</span> AIFRANode).schemeName) {
      lines.push(<span class="hljs-string">`    aif:hasScheme mesh:scheme/<span class="hljs-subst">${(node <span class="hljs-keyword">as</span> AIFRANode).schemeName}</span> ;`</span>);
    }
    
    lines.push(<span class="hljs-string">`    aif:timestamp "<span class="hljs-subst">${node.timestamp}</span>"^^xsd:dateTime .`</span>);
    lines.push(<span class="hljs-string">''</span>);
  }
  
  <span class="hljs-comment">// Serialize edges</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> edge of graph.edges) {
    lines.push(<span class="hljs-string">`mesh:<span class="hljs-subst">${<span class="hljs-built_in">encodeURIComponent</span>(edge.fromID)}</span> aif:supports mesh:<span class="hljs-subst">${<span class="hljs-built_in">encodeURIComponent</span>(edge.toID)}</span> .`</span>);
  }
  
  <span class="hljs-keyword">return</span> lines.join(<span class="hljs-string">'\n'</span>);
}

<span class="hljs-comment">// Export to AIF-JSON (simpler format)</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exportAIFToJSON</span>(<span class="hljs-params">graph: AIFGraph</span>): <span class="hljs-title">string</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.stringify({
    <span class="hljs-string">'@context'</span>: <span class="hljs-string">'https://www.arg.dundee.ac.uk/aif/context.jsonld'</span>,
    nodes: graph.nodes.map(<span class="hljs-function"><span class="hljs-params">node</span> =&gt;</span> ({
      id: node.nodeID,
      <span class="hljs-keyword">type</span>: <span class="hljs-string">`aif:<span class="hljs-subst">${node.<span class="hljs-keyword">type</span>}</span>-node`</span>,
      ...node
    })),
    edges: graph.edges.map(<span class="hljs-function"><span class="hljs-params">edge</span> =&gt;</span> ({
      id: edge.edgeID,
      <span class="hljs-keyword">from</span>: edge.fromID,
      to: edge.toID
    }))
  }, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>);
}
</div></code></pre>
<hr>
<h3 id="11-aspic-theory-generation">11. ASPIC+ Theory Generation</h3>
<p><strong>Goal</strong>: Convert extracted arguments into formal ASPIC+ theory for acceptability analysis.</p>
<h4 id="111-aspic-framework-overview">11.1 ASPIC+ Framework Overview</h4>
<pre class="hljs"><code><div>┌─────────────────────────────────────────────────────────────────────────────┐
│                         ASPIC+ COMPONENTS                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ARGUMENTATION SYSTEM AS = (L, R, n)                                         │
│  Where:                                                                       │
│    L = Logical language                                                       │
│    R = Rs ∪ Rd (strict and defeasible rules)                                 │
│    n = Naming function for defeasible rules                                   │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  RULES                                                               │    │
│  │                                                                      │    │
│  │  Strict Rules (Rs):                                                 │    │
│  │    φ₁, φ₂, ..., φₙ → ψ                                              │    │
│  │    &quot;If premises, then conclusion necessarily&quot;                        │    │
│  │    Cannot be attacked                                                │    │
│  │                                                                      │    │
│  │  Defeasible Rules (Rd):                                             │    │
│  │    φ₁, φ₂, ..., φₙ ⇒ ψ                                              │    │
│  │    &quot;If premises, then conclusion presumably&quot;                         │    │
│  │    Named: r₁: φ₁, φ₂ ⇒ ψ                                            │    │
│  │    Can be undercut by attacking the rule itself                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  ARGUMENTS                                                           │    │
│  │                                                                      │    │
│  │  An argument A is:                                                   │    │
│  │    • A single premise φ ∈ K (knowledge base), or                    │    │
│  │    • A₁, A₂, ..., Aₙ →/⇒ ψ where each Aᵢ is an argument             │    │
│  │                                                                      │    │
│  │  Components:                                                          │    │
│  │    Prem(A) = set of premises                                         │    │
│  │    Conc(A) = conclusion                                              │    │
│  │    Sub(A) = set of sub-arguments                                     │    │
│  │    TopRule(A) = last inference rule applied                          │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  ATTACKS                                                             │    │
│  │                                                                      │    │
│  │  Rebut: A attacks B on B' ∈ Sub(B) iff                              │    │
│  │         Conc(A) = ¬Conc(B') and B' uses defeasible rule             │    │
│  │                                                                      │    │
│  │  Undercut: A attacks B on B' ∈ Sub(B) iff                           │    │
│  │            Conc(A) = ¬n(r) where r is TopRule(B')                   │    │
│  │                                                                      │    │
│  │  Undermine: A attacks B on φ ∈ Prem(B) iff                          │    │
│  │             Conc(A) = ¬φ and φ is ordinary premise                  │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  PREFERENCES                                                         │    │
│  │                                                                      │    │
│  │  Rule Preference: r₁ &lt; r₂ means r₂ is preferred over r₁            │    │
│  │  Argument Preference: Derived from rule preferences                   │    │
│  │    (last-link, weakest-link, democratic ordering)                    │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
</div></code></pre>
<h4 id="112-aspic-converter-implementation">11.2 ASPIC+ Converter Implementation</h4>
<pre class="hljs"><code><div><span class="hljs-comment">// lib/export/aspic-converter.ts</span>

<span class="hljs-keyword">interface</span> ASPICProposition {
  id: <span class="hljs-built_in">string</span>;
  text: <span class="hljs-built_in">string</span>;
  negation?: <span class="hljs-built_in">string</span>;          <span class="hljs-comment">// ID of negated proposition</span>
  isKnowledgeBase: <span class="hljs-built_in">boolean</span>;   <span class="hljs-comment">// Part of initial knowledge base K</span>
}

<span class="hljs-keyword">interface</span> ASPICRule {
  id: <span class="hljs-built_in">string</span>;
  name: <span class="hljs-built_in">string</span>;               <span class="hljs-comment">// Named for undercutting attacks</span>
  <span class="hljs-keyword">type</span>: <span class="hljs-string">'strict'</span> | <span class="hljs-string">'defeasible'</span>;
  antecedents: <span class="hljs-built_in">string</span>[];      <span class="hljs-comment">// Proposition IDs</span>
  consequent: <span class="hljs-built_in">string</span>;         <span class="hljs-comment">// Proposition ID</span>
  schemeId?: <span class="hljs-built_in">string</span>;          <span class="hljs-comment">// Walton scheme if applicable</span>
}

<span class="hljs-keyword">interface</span> ASPICPreference {
  rule1: <span class="hljs-built_in">string</span>;              <span class="hljs-comment">// Less preferred</span>
  rule2: <span class="hljs-built_in">string</span>;              <span class="hljs-comment">// More preferred</span>
  basis: <span class="hljs-string">'specificity'</span> | <span class="hljs-string">'recency'</span> | <span class="hljs-string">'authority'</span> | <span class="hljs-string">'explicit'</span>;
}

<span class="hljs-keyword">interface</span> ASPICTheory {
  propositions: ASPICProposition[];
  strictRules: ASPICRule[];
  defeasibleRules: ASPICRule[];
  knowledgeBase: <span class="hljs-built_in">string</span>[];    <span class="hljs-comment">// Proposition IDs accepted as premises</span>
  preferences: ASPICPreference[];
  contraries: { prop: <span class="hljs-built_in">string</span>; contrary: <span class="hljs-built_in">string</span> }[];  <span class="hljs-comment">// Contrary/contradictory pairs</span>
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">convertToASPIC</span>(<span class="hljs-params">
  result: ExtractionResult,
  options: ASPICConversionOptions
</span>): <span class="hljs-title">ASPICTheory</span> </span>{
  <span class="hljs-keyword">const</span> propositions: ASPICProposition[] = [];
  <span class="hljs-keyword">const</span> defeasibleRules: ASPICRule[] = [];
  <span class="hljs-keyword">const</span> strictRules: ASPICRule[] = [];
  <span class="hljs-keyword">const</span> knowledgeBase: <span class="hljs-built_in">string</span>[] = [];
  <span class="hljs-keyword">const</span> preferences: ASPICPreference[] = [];
  
  <span class="hljs-keyword">const</span> claimToPropId = <span class="hljs-keyword">new</span> Map&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt;();
  
  <span class="hljs-comment">// Step 1: Convert claims to propositions</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> claim of result.claims) {
    <span class="hljs-keyword">const</span> propId = <span class="hljs-string">`p_<span class="hljs-subst">${claim.id}</span>`</span>;
    claimToPropId.set(claim.id, propId);
    
    propositions.push({
      id: propId,
      text: claim.text,
      isKnowledgeBase: claim.claimType === <span class="hljs-string">'premise'</span> || claim.claimType === <span class="hljs-string">'evidence'</span>
    });
    
    <span class="hljs-comment">// Premises with high confidence go into knowledge base</span>
    <span class="hljs-keyword">if</span> (claim.confidence &gt; <span class="hljs-number">0.8</span> &amp;&amp; (claim.claimType === <span class="hljs-string">'premise'</span> || claim.claimType === <span class="hljs-string">'evidence'</span>)) {
      knowledgeBase.push(propId);
    }
  }
  
  <span class="hljs-comment">// Step 2: Convert arguments to rules</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> arg of result.arguments) {
    <span class="hljs-keyword">const</span> ruleName = <span class="hljs-string">`r_<span class="hljs-subst">${arg.id}</span>`</span>;
    <span class="hljs-keyword">const</span> antecedents = arg.premiseIds
      .map(<span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> claimToPropId.get(id))
      .filter(<span class="hljs-built_in">Boolean</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>[];
    <span class="hljs-keyword">const</span> consequent = claimToPropId.get(arg.conclusionId);
    
    <span class="hljs-keyword">if</span> (!consequent || antecedents.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;
    
    <span class="hljs-comment">// Determine rule type based on scheme</span>
    <span class="hljs-keyword">const</span> isStrict = isStrictScheme(arg.primarySchemeId);
    
    <span class="hljs-keyword">const</span> rule: ASPICRule = {
      id: ruleName,
      name: ruleName,
      <span class="hljs-keyword">type</span>: isStrict ? <span class="hljs-string">'strict'</span> : <span class="hljs-string">'defeasible'</span>,
      antecedents,
      consequent,
      schemeId: arg.primarySchemeId
    };
    
    <span class="hljs-keyword">if</span> (isStrict) {
      strictRules.push(rule);
    } <span class="hljs-keyword">else</span> {
      defeasibleRules.push(rule);
    }
  }
  
  <span class="hljs-comment">// Step 3: Infer preferences from confidence scores</span>
  <span class="hljs-keyword">const</span> sortedRules = [...defeasibleRules].sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> argA = result.arguments.find(<span class="hljs-function"><span class="hljs-params">arg</span> =&gt;</span> <span class="hljs-string">`r_<span class="hljs-subst">${arg.id}</span>`</span> === a.id);
    <span class="hljs-keyword">const</span> argB = result.arguments.find(<span class="hljs-function"><span class="hljs-params">arg</span> =&gt;</span> <span class="hljs-string">`r_<span class="hljs-subst">${arg.id}</span>`</span> === b.id);
    <span class="hljs-keyword">return</span> (argB?.confidence || <span class="hljs-number">0</span>) - (argA?.confidence || <span class="hljs-number">0</span>);
  });
  
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; sortedRules.length - <span class="hljs-number">1</span>; i++) {
    preferences.push({
      rule1: sortedRules[i + <span class="hljs-number">1</span>].id,  <span class="hljs-comment">// Lower confidence = less preferred</span>
      rule2: sortedRules[i].id,       <span class="hljs-comment">// Higher confidence = more preferred</span>
      basis: <span class="hljs-string">'explicit'</span>
    });
  }
  
  <span class="hljs-keyword">return</span> {
    propositions,
    strictRules,
    defeasibleRules,
    knowledgeBase,
    preferences,
    contraries: inferContraries(propositions)
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isStrictScheme</span>(<span class="hljs-params">schemeId?: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">boolean</span> </span>{
  <span class="hljs-comment">// Some schemes represent strict inference (e.g., modus ponens, definition)</span>
  <span class="hljs-keyword">const</span> strictSchemes = [<span class="hljs-string">'verbal_classification'</span>, <span class="hljs-string">'definition'</span>, <span class="hljs-string">'modus_ponens'</span>];
  <span class="hljs-keyword">return</span> schemeId ? strictSchemes.includes(schemeId) : <span class="hljs-literal">false</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inferContraries</span>(<span class="hljs-params">propositions: ASPICProposition[]</span>): </span>{ prop: <span class="hljs-built_in">string</span>; contrary: <span class="hljs-built_in">string</span> }[] {
  <span class="hljs-keyword">const</span> contraries: { prop: <span class="hljs-built_in">string</span>; contrary: <span class="hljs-built_in">string</span> }[] = [];
  
  <span class="hljs-comment">// Simple heuristic: detect negation markers</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; propositions.length; i++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; propositions.length; j++) {
      <span class="hljs-keyword">const</span> p1 = propositions[i].text.toLowerCase();
      <span class="hljs-keyword">const</span> p2 = propositions[j].text.toLowerCase();
      
      <span class="hljs-comment">// Check if one is negation of other</span>
      <span class="hljs-keyword">if</span> (
        p2.startsWith(<span class="hljs-string">'not '</span>) &amp;&amp; p2.slice(<span class="hljs-number">4</span>) === p1 ||
        p1.startsWith(<span class="hljs-string">'not '</span>) &amp;&amp; p1.slice(<span class="hljs-number">4</span>) === p2 ||
        p2.includes(<span class="hljs-string">`not <span class="hljs-subst">${p1}</span>`</span>) ||
        p1.includes(<span class="hljs-string">`not <span class="hljs-subst">${p2}</span>`</span>)
      ) {
        contraries.push({ prop: propositions[i].id, contrary: propositions[j].id });
      }
    }
  }
  
  <span class="hljs-keyword">return</span> contraries;
}

<span class="hljs-comment">// Export to ASPIC+ theory file format</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exportASPICToTheoryFormat</span>(<span class="hljs-params">theory: ASPICTheory</span>): <span class="hljs-title">string</span> </span>{
  <span class="hljs-keyword">const</span> lines: <span class="hljs-built_in">string</span>[] = [
    <span class="hljs-string">'% ASPIC+ Theory generated by Mesh Extraction Pipeline'</span>,
    <span class="hljs-string">`% Generated: <span class="hljs-subst">${<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toISOString()}</span>`</span>,
    <span class="hljs-string">''</span>,
    <span class="hljs-string">'% === PROPOSITIONS ==='</span>,
  ];
  
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> prop of theory.propositions) {
    lines.push(<span class="hljs-string">`prop(<span class="hljs-subst">${prop.id}</span>, "<span class="hljs-subst">${escapeQuotes(prop.text)}</span>").`</span>);
  }
  
  lines.push(<span class="hljs-string">''</span>, <span class="hljs-string">'% === KNOWLEDGE BASE ==='</span>);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> kb of theory.knowledgeBase) {
    lines.push(<span class="hljs-string">`kb(<span class="hljs-subst">${kb}</span>).`</span>);
  }
  
  lines.push(<span class="hljs-string">''</span>, <span class="hljs-string">'% === STRICT RULES ==='</span>);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> rule of theory.strictRules) {
    lines.push(<span class="hljs-string">`strict_rule(<span class="hljs-subst">${rule.id}</span>, [<span class="hljs-subst">${rule.antecedents.join(<span class="hljs-string">', '</span>)}</span>], <span class="hljs-subst">${rule.consequent}</span>).`</span>);
  }
  
  lines.push(<span class="hljs-string">''</span>, <span class="hljs-string">'% === DEFEASIBLE RULES ==='</span>);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> rule of theory.defeasibleRules) {
    <span class="hljs-keyword">const</span> schemePart = rule.schemeId ? <span class="hljs-string">`, scheme(<span class="hljs-subst">${rule.schemeId}</span>)`</span> : <span class="hljs-string">''</span>;
    lines.push(<span class="hljs-string">`def_rule(<span class="hljs-subst">${rule.id}</span>, [<span class="hljs-subst">${rule.antecedents.join(<span class="hljs-string">', '</span>)}</span>], <span class="hljs-subst">${rule.consequent}</span><span class="hljs-subst">${schemePart}</span>).`</span>);
  }
  
  lines.push(<span class="hljs-string">''</span>, <span class="hljs-string">'% === PREFERENCES ==='</span>);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> pref of theory.preferences) {
    lines.push(<span class="hljs-string">`prefer(<span class="hljs-subst">${pref.rule2}</span>, <span class="hljs-subst">${pref.rule1}</span>).  % <span class="hljs-subst">${pref.rule2}</span> &gt; <span class="hljs-subst">${pref.rule1}</span>`</span>);
  }
  
  lines.push(<span class="hljs-string">''</span>, <span class="hljs-string">'% === CONTRARIES ==='</span>);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> c of theory.contraries) {
    lines.push(<span class="hljs-string">`contrary(<span class="hljs-subst">${c.prop}</span>, <span class="hljs-subst">${c.contrary}</span>).`</span>);
  }
  
  <span class="hljs-keyword">return</span> lines.join(<span class="hljs-string">'\n'</span>);
}
</div></code></pre>
<hr>
<h3 id="12-ceg-carneades-argument-evaluation-structure-export">12. CEG (Carneades Argument Evaluation Structure) Export</h3>
<p><strong>Goal</strong>: Export to Carneades format for evidence-weighted argument evaluation.</p>
<h4 id="121-carneades-model-overview">12.1 Carneades Model Overview</h4>
<pre class="hljs"><code><div>┌─────────────────────────────────────────────────────────────────────────────┐
│                    CARNEADES ARGUMENT EVALUATION                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Key Concepts:                                                               │
│                                                                              │
│  STATEMENTS: Propositions with proof standards                               │
│    • proofStandard: PE (preponderance) | CCE (clear &amp; convincing) |         │
│                     BRD (beyond reasonable doubt) | SE (scintilla)          │
│    • value: true | false | unknown                                          │
│    • weight: 0.0 - 1.0                                                       │
│                                                                              │
│  ARGUMENTS: Support or attack statements                                     │
│    • premises: list of statements                                           │
│    • conclusion: statement                                                  │
│    • weight: intrinsic strength of inference                                │
│    • scheme: argumentation scheme used                                      │
│                                                                              │
│  EVALUATION: Determine statement acceptability                               │
│    • Aggregate pro/con arguments by weight                                  │
│    • Compare to proof standard threshold                                    │
│    • Propagate through argument graph                                       │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
</div></code></pre>
<h4 id="122-carneades-converter">12.2 Carneades Converter</h4>
<pre class="hljs"><code><div><span class="hljs-comment">// lib/export/carneades-converter.ts</span>

<span class="hljs-keyword">type</span> ProofStandard = <span class="hljs-string">'SE'</span> | <span class="hljs-string">'PE'</span> | <span class="hljs-string">'CCE'</span> | <span class="hljs-string">'BRD'</span> | <span class="hljs-string">'DV'</span>;

<span class="hljs-keyword">interface</span> CarneadesStatement {
  id: <span class="hljs-built_in">string</span>;
  text: <span class="hljs-built_in">string</span>;
  proofStandard: ProofStandard;
  value?: <span class="hljs-string">'true'</span> | <span class="hljs-string">'false'</span> | <span class="hljs-string">'unknown'</span>;
  weight?: <span class="hljs-built_in">number</span>;
  assumed?: <span class="hljs-built_in">boolean</span>;
}

<span class="hljs-keyword">interface</span> CarneadesArgument {
  id: <span class="hljs-built_in">string</span>;
  conclusion: <span class="hljs-built_in">string</span>;           <span class="hljs-comment">// Statement ID</span>
  premises: <span class="hljs-built_in">string</span>[];           <span class="hljs-comment">// Statement IDs</span>
  exceptions?: <span class="hljs-built_in">string</span>[];        <span class="hljs-comment">// Exception statement IDs</span>
  weight: <span class="hljs-built_in">number</span>;               <span class="hljs-comment">// 0.0 - 1.0</span>
  pro: <span class="hljs-built_in">boolean</span>;                 <span class="hljs-comment">// true = supports, false = attacks</span>
  scheme?: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">interface</span> CarneadesArgumentGraph {
  statements: CarneadesStatement[];
  <span class="hljs-built_in">arguments</span>: CarneadesArgument[];
  metadata: {
    title?: <span class="hljs-built_in">string</span>;
    source?: <span class="hljs-built_in">string</span>;
    created: <span class="hljs-built_in">string</span>;
  };
}

<span class="hljs-comment">// Map claim types to proof standards</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getProofStandard</span>(<span class="hljs-params">claimType: <span class="hljs-built_in">string</span>, confidence: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">ProofStandard</span> </span>{
  <span class="hljs-keyword">if</span> (claimType === <span class="hljs-string">'hypothesis'</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">'SE'</span>;      <span class="hljs-comment">// Scintilla of evidence</span>
  <span class="hljs-keyword">if</span> (claimType === <span class="hljs-string">'conclusion'</span> &amp;&amp; confidence &gt; <span class="hljs-number">0.8</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">'CCE'</span>;  <span class="hljs-comment">// Clear &amp; convincing</span>
  <span class="hljs-keyword">if</span> (claimType === <span class="hljs-string">'evidence'</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">'PE'</span>;         <span class="hljs-comment">// Preponderance</span>
  <span class="hljs-keyword">return</span> <span class="hljs-string">'PE'</span>;  <span class="hljs-comment">// Default</span>
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">convertToCarneades</span>(<span class="hljs-params">
  result: ExtractionResult,
  options: CarneadesConversionOptions
</span>): <span class="hljs-title">CarneadesArgumentGraph</span> </span>{
  <span class="hljs-keyword">const</span> statements: CarneadesStatement[] = [];
  <span class="hljs-keyword">const</span> carguments: CarneadesArgument[] = [];
  
  <span class="hljs-keyword">const</span> claimToStatementId = <span class="hljs-keyword">new</span> Map&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt;();
  
  <span class="hljs-comment">// Convert claims to statements</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> claim of result.claims) {
    <span class="hljs-keyword">const</span> stmtId = <span class="hljs-string">`s_<span class="hljs-subst">${claim.id}</span>`</span>;
    claimToStatementId.set(claim.id, stmtId);
    
    statements.push({
      id: stmtId,
      text: claim.text,
      proofStandard: getProofStandard(claim.claimType || <span class="hljs-string">'assertion'</span>, claim.confidence),
      weight: claim.confidence,
      assumed: claim.claimType === <span class="hljs-string">'premise'</span> &amp;&amp; claim.confidence &gt; <span class="hljs-number">0.9</span>
    });
  }
  
  <span class="hljs-comment">// Convert arguments</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> arg of result.arguments) {
    <span class="hljs-keyword">const</span> conclusionId = claimToStatementId.get(arg.conclusionId);
    <span class="hljs-keyword">if</span> (!conclusionId) <span class="hljs-keyword">continue</span>;
    
    <span class="hljs-keyword">const</span> premiseIds = arg.premiseIds
      .map(<span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> claimToStatementId.get(id))
      .filter(<span class="hljs-built_in">Boolean</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>[];
    
    carguments.push({
      id: <span class="hljs-string">`a_<span class="hljs-subst">${arg.id}</span>`</span>,
      conclusion: conclusionId,
      premises: premiseIds,
      weight: arg.confidence,
      pro: <span class="hljs-literal">true</span>,  <span class="hljs-comment">// Extracted arguments support their conclusions</span>
      scheme: arg.primarySchemeId
    });
  }
  
  <span class="hljs-keyword">return</span> {
    statements,
    <span class="hljs-built_in">arguments</span>: carguments,
    metadata: {
      source: result.metadata.sourceId,
      created: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toISOString()
    }
  };
}

<span class="hljs-comment">// Export to Carneades JSON format (compatible with Carneades web tools)</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exportCarneadesToJSON</span>(<span class="hljs-params">graph: CarneadesArgumentGraph</span>): <span class="hljs-title">string</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.stringify({
    meta: graph.metadata,
    statements: <span class="hljs-built_in">Object</span>.fromEntries(
      graph.statements.map(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> [s.id, {
        text: { en: s.text },
        standard: s.proofStandard,
        weight: s.weight,
        assumed: s.assumed
      }])
    ),
    <span class="hljs-built_in">arguments</span>: <span class="hljs-built_in">Object</span>.fromEntries(
      graph.arguments.map(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> [a.id, {
        conclusion: a.conclusion,
        premises: a.premises,
        exceptions: a.exceptions || [],
        weight: a.weight,
        pro: a.pro,
        scheme: a.scheme
      }])
    )
  }, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>);
}
</div></code></pre>
<hr>
<h3 id="13-unified-export-api">13. Unified Export API</h3>
<pre class="hljs"><code><div><span class="hljs-comment">// lib/export/index.ts</span>

<span class="hljs-keyword">import</span> { convertToAIF, exportAIFToJSON, exportAIFToTurtle } <span class="hljs-keyword">from</span> <span class="hljs-string">'./aif-converter'</span>;
<span class="hljs-keyword">import</span> { convertToASPIC, exportASPICToTheoryFormat } <span class="hljs-keyword">from</span> <span class="hljs-string">'./aspic-converter'</span>;
<span class="hljs-keyword">import</span> { convertToCarneades, exportCarneadesToJSON } <span class="hljs-keyword">from</span> <span class="hljs-string">'./carneades-converter'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> ExportFormat = 
  | <span class="hljs-string">'aif-json'</span>
  | <span class="hljs-string">'aif-rdf'</span>
  | <span class="hljs-string">'aspic-theory'</span>
  | <span class="hljs-string">'carneades-json'</span>
  | <span class="hljs-string">'mesh-native'</span>;

<span class="hljs-keyword">interface</span> ExportOptions {
  format: ExportFormat;
  includeMetadata: <span class="hljs-built_in">boolean</span>;
  includeConfidenceScores: <span class="hljs-built_in">boolean</span>;
  baseURI?: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exportExtractionResult</span>(<span class="hljs-params">
  result: ExtractionResult,
  options: ExportOptions
</span>): <span class="hljs-title">Promise</span>&lt;</span>{ content: <span class="hljs-built_in">string</span>; mimeType: <span class="hljs-built_in">string</span>; filename: <span class="hljs-built_in">string</span> }&gt; {
  
  <span class="hljs-keyword">switch</span> (options.format) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'aif-json'</span>: {
      <span class="hljs-keyword">const</span> aifGraph = convertToAIF(result, {
        includeMetadata: options.includeMetadata,
        includeLocutions: <span class="hljs-literal">false</span>,
        includeSchemeFulfillments: <span class="hljs-literal">true</span>,
        baseURI: options.baseURI || <span class="hljs-string">'https://mesh.app/aif'</span>
      });
      <span class="hljs-keyword">return</span> {
        content: exportAIFToJSON(aifGraph),
        mimeType: <span class="hljs-string">'application/json'</span>,
        filename: <span class="hljs-string">`extraction-<span class="hljs-subst">${result.jobId}</span>-aif.json`</span>
      };
    }
    
    <span class="hljs-keyword">case</span> <span class="hljs-string">'aif-rdf'</span>: {
      <span class="hljs-keyword">const</span> aifGraph = convertToAIF(result, {
        includeMetadata: options.includeMetadata,
        includeLocutions: <span class="hljs-literal">false</span>,
        includeSchemeFulfillments: <span class="hljs-literal">true</span>,
        baseURI: options.baseURI || <span class="hljs-string">'https://mesh.app/aif'</span>
      });
      <span class="hljs-keyword">return</span> {
        content: exportAIFToTurtle(aifGraph),
        mimeType: <span class="hljs-string">'text/turtle'</span>,
        filename: <span class="hljs-string">`extraction-<span class="hljs-subst">${result.jobId}</span>-aif.ttl`</span>
      };
    }
    
    <span class="hljs-keyword">case</span> <span class="hljs-string">'aspic-theory'</span>: {
      <span class="hljs-keyword">const</span> aspicTheory = convertToASPIC(result, {
        includeSchemeAnnotations: <span class="hljs-literal">true</span>
      });
      <span class="hljs-keyword">return</span> {
        content: exportASPICToTheoryFormat(aspicTheory),
        mimeType: <span class="hljs-string">'text/plain'</span>,
        filename: <span class="hljs-string">`extraction-<span class="hljs-subst">${result.jobId}</span>-aspic.theory`</span>
      };
    }
    
    <span class="hljs-keyword">case</span> <span class="hljs-string">'carneades-json'</span>: {
      <span class="hljs-keyword">const</span> carneadesGraph = convertToCarneades(result, {
        defaultProofStandard: <span class="hljs-string">'PE'</span>
      });
      <span class="hljs-keyword">return</span> {
        content: exportCarneadesToJSON(carneadesGraph),
        mimeType: <span class="hljs-string">'application/json'</span>,
        filename: <span class="hljs-string">`extraction-<span class="hljs-subst">${result.jobId}</span>-carneades.json`</span>
      };
    }
    
    <span class="hljs-keyword">case</span> <span class="hljs-string">'mesh-native'</span>:
    <span class="hljs-keyword">default</span>: {
      <span class="hljs-keyword">return</span> {
        content: <span class="hljs-built_in">JSON</span>.stringify(result, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>),
        mimeType: <span class="hljs-string">'application/json'</span>,
        filename: <span class="hljs-string">`extraction-<span class="hljs-subst">${result.jobId}</span>.json`</span>
      };
    }
  }
}

<span class="hljs-comment">// API route for exports</span>
<span class="hljs-comment">// app/api/extraction/[jobId]/export/route.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GET</span>(<span class="hljs-params">
  request: Request,
  { params }: { params: { jobId: <span class="hljs-built_in">string</span> } }
</span>) </span>{
  <span class="hljs-keyword">const</span> { searchParams } = <span class="hljs-keyword">new</span> URL(request.url);
  <span class="hljs-keyword">const</span> format = searchParams.get(<span class="hljs-string">'format'</span>) <span class="hljs-keyword">as</span> ExportFormat || <span class="hljs-string">'mesh-native'</span>;
  
  <span class="hljs-comment">// Load extraction job result</span>
  <span class="hljs-keyword">const</span> job = <span class="hljs-keyword">await</span> prisma.extractionJob.findUnique({
    where: { id: params.jobId },
    include: {
      extractedClaims: <span class="hljs-literal">true</span>,
      extractedArguments: {
        include: { premises: <span class="hljs-literal">true</span> }
      }
    }
  });
  
  <span class="hljs-keyword">if</span> (!job || job.status !== <span class="hljs-string">'APPROVED'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Response(<span class="hljs-string">'Job not found or not approved'</span>, { status: <span class="hljs-number">404</span> });
  }
  
  <span class="hljs-keyword">const</span> result = reconstructExtractionResult(job);
  <span class="hljs-keyword">const</span> exported = <span class="hljs-keyword">await</span> exportExtractionResult(result, {
    format,
    includeMetadata: <span class="hljs-literal">true</span>,
    includeConfidenceScores: <span class="hljs-literal">true</span>
  });
  
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Response(exported.content, {
    headers: {
      <span class="hljs-string">'Content-Type'</span>: exported.mimeType,
      <span class="hljs-string">'Content-Disposition'</span>: <span class="hljs-string">`attachment; filename="<span class="hljs-subst">${exported.filename}</span>"`</span>
    }
  });
}
</div></code></pre>
<hr>
<p><em>Continued in Part 4: User Interface &amp; Workflows</em></p>
<hr>
<h2 id="part-3-summary">Part 3 Summary</h2>
<p>This part detailed:</p>
<ol>
<li>
<p><strong>AIF Conversion</strong>:</p>
<ul>
<li>I-nodes for claims, RA-nodes for arguments, CA-nodes for attacks</li>
<li>JSON and RDF/Turtle export formats</li>
<li>W3C-compliant ontology mapping</li>
</ul>
</li>
<li>
<p><strong>ASPIC+ Generation</strong>:</p>
<ul>
<li>Propositions, strict rules, defeasible rules</li>
<li>Knowledge base construction</li>
<li>Preference ordering from confidence scores</li>
<li>Contrary inference</li>
</ul>
</li>
<li>
<p><strong>Carneades Export</strong>:</p>
<ul>
<li>Statements with proof standards</li>
<li>Weighted argument evaluation</li>
<li>Evidence graph structure</li>
</ul>
</li>
<li>
<p><strong>Unified Export API</strong>:</p>
<ul>
<li>Single interface for all formats</li>
<li>API route for download</li>
</ul>
</li>
</ol>
<p><strong>Next in Part 4:</strong></p>
<ul>
<li>Extraction UI components</li>
<li>Human-in-the-loop verification workflow</li>
<li>Integration with ArticleReaderWithPins</li>
<li>Real-time extraction feedback</li>
</ul>
<hr>
<h2 id="part-4-user-interface--workflows">Part 4: User Interface &amp; Workflows</h2>
<h3 id="14-extraction-ui-components">14. Extraction UI Components</h3>
<p><strong>Goal</strong>: Provide intuitive interfaces for initiating, monitoring, and reviewing extractions.</p>
<h4 id="141-component-architecture">14.1 Component Architecture</h4>
<pre class="hljs"><code><div>┌─────────────────────────────────────────────────────────────────────────────┐
│                    EXTRACTION UI COMPONENT HIERARCHY                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ArticleReaderWithPins (existing)                                            │
│  └── ExtractionProvider (new context)                                       │
│      │                                                                       │
│      ├── ExtractionToolbar                                                  │
│      │   ├── ExtractButton (&quot;Extract Claims &amp; Arguments&quot;)                   │
│      │   ├── ExtractionProgress (during processing)                         │
│      │   └── ExtractionModeToggle (view: off | highlights | full)          │
│      │                                                                       │
│      ├── ExtractionOverlay (highlights in article body)                     │
│      │   ├── ClaimHighlight (per extracted claim)                           │
│      │   ├── ArgumentConnector (lines linking premises to conclusions)      │
│      │   └── ConfidenceBadge (shows extraction confidence)                  │
│      │                                                                       │
│      ├── ExtractionRail (right sidebar, parallel to comment rail)           │
│      │   ├── ClaimCard (per claim, with accept/reject/edit)                │
│      │   ├── ArgumentCard (shows structure, scheme)                        │
│      │   └── EvidenceCard (linked citations)                               │
│      │                                                                       │
│      └── ExtractionReviewPanel (slide-out for detailed review)              │
│          ├── ClaimEditor (edit claim text)                                  │
│          ├── ArgumentStructureEditor (drag-drop premises)                   │
│          ├── SchemeSelector (choose/change scheme)                          │
│          └── ApprovalActions (approve all, reject all, publish)            │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
</div></code></pre>
<h4 id="142-extractionprovider-context">14.2 ExtractionProvider Context</h4>
<pre class="hljs"><code><div><span class="hljs-comment">// components/article/extraction/ExtractionContext.tsx</span>

<span class="hljs-string">"use client"</span>;

<span class="hljs-keyword">import</span> { createContext, useContext, useState, useCallback, ReactNode } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { ExtractedClaimData, ExtractedArgumentData, ExtractionResult } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/lib/extraction/types'</span>;

<span class="hljs-keyword">interface</span> ExtractionState {
  <span class="hljs-comment">// Job state</span>
  jobId: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;
  status: <span class="hljs-string">'idle'</span> | <span class="hljs-string">'extracting'</span> | <span class="hljs-string">'reviewing'</span> | <span class="hljs-string">'approved'</span> | <span class="hljs-string">'published'</span>;
  progress: <span class="hljs-built_in">number</span>;  <span class="hljs-comment">// 0-100 during extraction</span>
  
  <span class="hljs-comment">// Extracted content</span>
  claims: ExtractedClaimData[];
  <span class="hljs-built_in">arguments</span>: ExtractedArgumentData[];
  
  <span class="hljs-comment">// UI state</span>
  viewMode: <span class="hljs-string">'off'</span> | <span class="hljs-string">'highlights'</span> | <span class="hljs-string">'full'</span>;
  selectedClaimId: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;
  selectedArgumentId: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;
  
  <span class="hljs-comment">// Stats</span>
  stats: {
    totalClaims: <span class="hljs-built_in">number</span>;
    approvedClaims: <span class="hljs-built_in">number</span>;
    rejectedClaims: <span class="hljs-built_in">number</span>;
    modifiedClaims: <span class="hljs-built_in">number</span>;
    totalArguments: <span class="hljs-built_in">number</span>;
    approvedArguments: <span class="hljs-built_in">number</span>;
  };
}

<span class="hljs-keyword">interface</span> ExtractionActions {
  <span class="hljs-comment">// Extraction</span>
  startExtraction: <span class="hljs-function">(<span class="hljs-params">articleId: <span class="hljs-built_in">string</span>, config?: ExtractionConfig</span>) =&gt;</span> <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;
  cancelExtraction: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">void</span>;
  
  <span class="hljs-comment">// Review actions</span>
  approveClaim: <span class="hljs-function">(<span class="hljs-params">claimId: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;
  rejectClaim: <span class="hljs-function">(<span class="hljs-params">claimId: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;
  modifyClaim: <span class="hljs-function">(<span class="hljs-params">claimId: <span class="hljs-built_in">string</span>, newText: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;
  mergeClaims: <span class="hljs-function">(<span class="hljs-params">claimIds: <span class="hljs-built_in">string</span>[], targetId: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;
  
  approveArgument: <span class="hljs-function">(<span class="hljs-params">argumentId: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;
  rejectArgument: <span class="hljs-function">(<span class="hljs-params">argumentId: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;
  modifyArgumentStructure: <span class="hljs-function">(<span class="hljs-params">argumentId: <span class="hljs-built_in">string</span>, premiseIds: <span class="hljs-built_in">string</span>[], conclusionId: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;
  changeScheme: <span class="hljs-function">(<span class="hljs-params">argumentId: <span class="hljs-built_in">string</span>, schemeId: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;
  
  <span class="hljs-comment">// Bulk actions</span>
  approveAll: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">void</span>;
  rejectAll: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">void</span>;
  publishApproved: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;
  
  <span class="hljs-comment">// UI</span>
  setViewMode: <span class="hljs-function">(<span class="hljs-params">mode: 'off' | 'highlights' | 'full'</span>) =&gt;</span> <span class="hljs-built_in">void</span>;
  selectClaim: <span class="hljs-function">(<span class="hljs-params">claimId: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;
  selectArgument: <span class="hljs-function">(<span class="hljs-params">argumentId: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;
}

<span class="hljs-keyword">const</span> ExtractionContext = createContext&lt;{
  state: ExtractionState;
  actions: ExtractionActions;
} | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>);

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ExtractionProvider</span>(<span class="hljs-params">{ 
  articleId, 
  children 
}: { 
  articleId: <span class="hljs-built_in">string</span>;
  children: ReactNode;
}</span>) </span>{
  <span class="hljs-keyword">const</span> [state, setState] = useState&lt;ExtractionState&gt;({
    jobId: <span class="hljs-literal">null</span>,
    status: <span class="hljs-string">'idle'</span>,
    progress: <span class="hljs-number">0</span>,
    claims: [],
    <span class="hljs-built_in">arguments</span>: [],
    viewMode: <span class="hljs-string">'off'</span>,
    selectedClaimId: <span class="hljs-literal">null</span>,
    selectedArgumentId: <span class="hljs-literal">null</span>,
    stats: {
      totalClaims: <span class="hljs-number">0</span>,
      approvedClaims: <span class="hljs-number">0</span>,
      rejectedClaims: <span class="hljs-number">0</span>,
      modifiedClaims: <span class="hljs-number">0</span>,
      totalArguments: <span class="hljs-number">0</span>,
      approvedArguments: <span class="hljs-number">0</span>
    }
  });
  
  <span class="hljs-keyword">const</span> startExtraction = useCallback(<span class="hljs-keyword">async</span> (articleId: <span class="hljs-built_in">string</span>, config?: ExtractionConfig) =&gt; {
    setState(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> ({ ...s, status: <span class="hljs-string">'extracting'</span>, progress: <span class="hljs-number">0</span> }));
    
    <span class="hljs-keyword">try</span> {
      <span class="hljs-comment">// Start extraction job</span>
      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'/api/extraction/start'</span>, {
        method: <span class="hljs-string">'POST'</span>,
        headers: { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span> },
        body: <span class="hljs-built_in">JSON</span>.stringify({ sourceType: <span class="hljs-string">'article'</span>, sourceId: articleId, config })
      });
      
      <span class="hljs-keyword">const</span> { jobId } = <span class="hljs-keyword">await</span> response.json();
      setState(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> ({ ...s, jobId }));
      
      <span class="hljs-comment">// Poll for progress</span>
      <span class="hljs-keyword">const</span> pollInterval = setInterval(<span class="hljs-keyword">async</span> () =&gt; {
        <span class="hljs-keyword">const</span> statusRes = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">`/api/extraction/<span class="hljs-subst">${jobId}</span>/status`</span>);
        <span class="hljs-keyword">const</span> status = <span class="hljs-keyword">await</span> statusRes.json();
        
        setState(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> ({ ...s, progress: status.progress }));
        
        <span class="hljs-keyword">if</span> (status.status === <span class="hljs-string">'PENDING_REVIEW'</span>) {
          clearInterval(pollInterval);
          
          <span class="hljs-comment">// Load results</span>
          <span class="hljs-keyword">const</span> resultsRes = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">`/api/extraction/<span class="hljs-subst">${jobId}</span>/results`</span>);
          <span class="hljs-keyword">const</span> results: ExtractionResult = <span class="hljs-keyword">await</span> resultsRes.json();
          
          setState(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> ({
            ...s,
            status: <span class="hljs-string">'reviewing'</span>,
            claims: results.claims,
            <span class="hljs-built_in">arguments</span>: results.arguments,
            viewMode: <span class="hljs-string">'highlights'</span>,
            stats: {
              totalClaims: results.claims.length,
              approvedClaims: <span class="hljs-number">0</span>,
              rejectedClaims: <span class="hljs-number">0</span>,
              modifiedClaims: <span class="hljs-number">0</span>,
              totalArguments: results.arguments.length,
              approvedArguments: <span class="hljs-number">0</span>
            }
          }));
        }
      }, <span class="hljs-number">1000</span>);
      
    } <span class="hljs-keyword">catch</span> (error) {
      setState(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> ({ ...s, status: <span class="hljs-string">'idle'</span>, progress: <span class="hljs-number">0</span> }));
      <span class="hljs-keyword">throw</span> error;
    }
  }, []);
  
  <span class="hljs-keyword">const</span> approveClaim = useCallback(<span class="hljs-function">(<span class="hljs-params">claimId: <span class="hljs-built_in">string</span></span>) =&gt;</span> {
    setState(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> ({
      ...s,
      claims: s.claims.map(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> 
        c.id === claimId ? { ...c, status: <span class="hljs-string">'APPROVED'</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span> } : c
      ),
      stats: {
        ...s.stats,
        approvedClaims: s.stats.approvedClaims + <span class="hljs-number">1</span>
      }
    }));
  }, []);
  
  <span class="hljs-keyword">const</span> rejectClaim = useCallback(<span class="hljs-function">(<span class="hljs-params">claimId: <span class="hljs-built_in">string</span></span>) =&gt;</span> {
    setState(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> ({
      ...s,
      claims: s.claims.map(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> 
        c.id === claimId ? { ...c, status: <span class="hljs-string">'REJECTED'</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span> } : c
      ),
      stats: {
        ...s.stats,
        rejectedClaims: s.stats.rejectedClaims + <span class="hljs-number">1</span>
      }
    }));
  }, []);
  
  <span class="hljs-keyword">const</span> modifyClaim = useCallback(<span class="hljs-function">(<span class="hljs-params">claimId: <span class="hljs-built_in">string</span>, newText: <span class="hljs-built_in">string</span></span>) =&gt;</span> {
    setState(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> ({
      ...s,
      claims: s.claims.map(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> 
        c.id === claimId 
          ? { ...c, text: newText, status: <span class="hljs-string">'MODIFIED'</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span> }
          : c
      ),
      stats: {
        ...s.stats,
        modifiedClaims: s.stats.modifiedClaims + <span class="hljs-number">1</span>
      }
    }));
  }, []);
  
  <span class="hljs-keyword">const</span> publishApproved = useCallback(<span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">if</span> (!state.jobId) <span class="hljs-keyword">return</span>;
    
    <span class="hljs-keyword">const</span> approvedClaims = state.claims.filter(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> 
      c.status === <span class="hljs-string">'APPROVED'</span> || c.status === <span class="hljs-string">'MODIFIED'</span>
    );
    <span class="hljs-keyword">const</span> approvedArguments = state.arguments.filter(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> 
      a.status === <span class="hljs-string">'APPROVED'</span> || a.status === <span class="hljs-string">'MODIFIED'</span>
    );
    
    <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">`/api/extraction/<span class="hljs-subst">${state.jobId}</span>/publish`</span>, {
      method: <span class="hljs-string">'POST'</span>,
      headers: { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span> },
      body: <span class="hljs-built_in">JSON</span>.stringify({
        claimIds: approvedClaims.map(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c.id),
        argumentIds: approvedArguments.map(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> a.id)
      })
    });
    
    setState(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> ({ ...s, status: <span class="hljs-string">'published'</span> }));
  }, [state.jobId, state.claims, state.arguments]);
  
  <span class="hljs-comment">// ... additional actions ...</span>
  
  <span class="hljs-keyword">const</span> actions: ExtractionActions = {
    startExtraction,
    cancelExtraction: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> setState(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> ({ ...s, status: <span class="hljs-string">'idle'</span> })),
    approveClaim,
    rejectClaim,
    modifyClaim,
    mergeClaims: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {},  <span class="hljs-comment">// TODO</span>
    approveArgument: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {},  <span class="hljs-comment">// TODO</span>
    rejectArgument: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {},  <span class="hljs-comment">// TODO</span>
    modifyArgumentStructure: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {},  <span class="hljs-comment">// TODO</span>
    changeScheme: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {},  <span class="hljs-comment">// TODO</span>
    approveAll: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      setState(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> ({
        ...s,
        claims: s.claims.map(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> ({ ...c, status: <span class="hljs-string">'APPROVED'</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span> })),
        <span class="hljs-built_in">arguments</span>: s.arguments.map(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> ({ ...a, status: <span class="hljs-string">'APPROVED'</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span> }))
      }));
    },
    rejectAll: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      setState(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> ({
        ...s,
        claims: s.claims.map(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> ({ ...c, status: <span class="hljs-string">'REJECTED'</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span> })),
        <span class="hljs-built_in">arguments</span>: s.arguments.map(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> ({ ...a, status: <span class="hljs-string">'REJECTED'</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span> }))
      }));
    },
    publishApproved,
    setViewMode: <span class="hljs-function">(<span class="hljs-params">mode</span>) =&gt;</span> setState(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> ({ ...s, viewMode: mode })),
    selectClaim: <span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> setState(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> ({ ...s, selectedClaimId: id })),
    selectArgument: <span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> setState(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> ({ ...s, selectedArgumentId: id }))
  };
  
  <span class="hljs-keyword">return</span> (
    &lt;ExtractionContext.Provider value={{ state, actions }}&gt;
      {children}
    &lt;<span class="hljs-regexp">/ExtractionContext.Provider&gt;
  );
}

export function useExtraction() {
  const context = useContext(ExtractionContext);
  if (!context) throw new Error('useExtraction must be within ExtractionProvider');
  return context;
}
</span></div></code></pre>
<h4 id="143-claim-highlight-overlay">14.3 Claim Highlight Overlay</h4>
<pre class="hljs"><code><div><span class="hljs-comment">// components/article/extraction/ClaimHighlight.tsx</span>

<span class="hljs-string">"use client"</span>;

<span class="hljs-keyword">import</span> { useMemo } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { Anchor } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/types/comments'</span>;
<span class="hljs-keyword">import</span> { ExtractedClaimData } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/lib/extraction/types'</span>;
<span class="hljs-keyword">import</span> { useExtraction } <span class="hljs-keyword">from</span> <span class="hljs-string">'./ExtractionContext'</span>;
<span class="hljs-keyword">import</span> { getAnchorRects } <span class="hljs-keyword">from</span> <span class="hljs-string">'../ArticleReaderWithPins'</span>;  <span class="hljs-comment">// Reuse existing anchor utils</span>

<span class="hljs-keyword">interface</span> ClaimHighlightProps {
  claim: ExtractedClaimData;
  containerRef: React.RefObject&lt;HTMLDivElement&gt;;
}

<span class="hljs-keyword">const</span> STATUS_COLORS = {
  PENDING: <span class="hljs-string">'bg-amber-200/40 border-amber-400'</span>,
  APPROVED: <span class="hljs-string">'bg-green-200/40 border-green-500'</span>,
  REJECTED: <span class="hljs-string">'bg-red-200/30 border-red-400 opacity-50'</span>,
  MODIFIED: <span class="hljs-string">'bg-blue-200/40 border-blue-500'</span>,
  MERGED: <span class="hljs-string">'bg-purple-200/40 border-purple-500'</span>,
  PUBLISHED: <span class="hljs-string">'bg-green-300/40 border-green-600'</span>
};

<span class="hljs-keyword">const</span> CLAIM_TYPE_ICONS = {
  assertion: <span class="hljs-string">'📝'</span>,
  hypothesis: <span class="hljs-string">'🔬'</span>,
  conclusion: <span class="hljs-string">'🎯'</span>,
  premise: <span class="hljs-string">'📌'</span>,
  evidence: <span class="hljs-string">'📊'</span>
};

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ClaimHighlight</span>(<span class="hljs-params">{ claim, containerRef }: ClaimHighlightProps</span>) </span>{
  <span class="hljs-keyword">const</span> { state, actions } = useExtraction();
  <span class="hljs-keyword">const</span> isSelected = state.selectedClaimId === claim.id;
  
  <span class="hljs-keyword">const</span> rects = useMemo(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (!containerRef.current) <span class="hljs-keyword">return</span> [];
    <span class="hljs-keyword">return</span> getAnchorRects(claim.anchor, containerRef.current);
  }, [claim.anchor, containerRef.current]);
  
  <span class="hljs-keyword">if</span> (rects.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  
  <span class="hljs-keyword">const</span> colorClass = STATUS_COLORS[claim.status] || STATUS_COLORS.PENDING;
  
  <span class="hljs-keyword">return</span> (
    &lt;&gt;
      {<span class="hljs-comment">/* Highlight rectangles */</span>}
      {rects.map(<span class="hljs-function">(<span class="hljs-params">rect, i</span>) =&gt;</span> (
        &lt;div
          key={<span class="hljs-string">`<span class="hljs-subst">${claim.id}</span>-rect-<span class="hljs-subst">${i}</span>`</span>}
          className={<span class="hljs-string">`
            absolute pointer-events-auto cursor-pointer
            border-b-2 transition-all duration-150
            <span class="hljs-subst">${colorClass}</span>
            <span class="hljs-subst">${isSelected ? <span class="hljs-string">'ring-2 ring-indigo-500 ring-offset-1'</span> : <span class="hljs-string">''</span>}</span>
          `</span>}
          style={{
            top: rect.top,
            left: rect.left,
            width: rect.width,
            height: rect.height
          }}
          onClick={<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> actions.selectClaim(claim.id)}
          onMouseEnter={<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> actions.selectClaim(claim.id)}
        /&gt;
      ))}
      
      {<span class="hljs-comment">/* Floating badge on first rect */</span>}
      {rects[<span class="hljs-number">0</span>] &amp;&amp; (
        &lt;div
          className={<span class="hljs-string">`
            absolute pointer-events-auto
            flex items-center gap-1 px-1.5 py-0.5
            text-[10px] font-medium rounded-full
            shadow-sm border
            <span class="hljs-subst">${colorClass}</span>
          `</span>}
          style={{
            top: rects[<span class="hljs-number">0</span>].top - <span class="hljs-number">18</span>,
            left: rects[<span class="hljs-number">0</span>].left
          }}
        &gt;
          &lt;span&gt;{CLAIM_TYPE_ICONS[claim.claimType || <span class="hljs-string">'assertion'</span>]}&lt;<span class="hljs-regexp">/span&gt;
          &lt;span className="opacity-70"&gt;{Math.round(claim.confidence * 100)}%&lt;/</span>span&gt;
        &lt;<span class="hljs-regexp">/div&gt;
      )}
    &lt;/</span>&gt;
  );
}

<span class="hljs-comment">// Wrapper for all claim highlights</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ExtractionOverlay</span>(<span class="hljs-params">{ 
  containerRef 
}: { 
  containerRef: React.RefObject&lt;HTMLDivElement&gt;;
}</span>) </span>{
  <span class="hljs-keyword">const</span> { state } = useExtraction();
  
  <span class="hljs-keyword">if</span> (state.viewMode === <span class="hljs-string">'off'</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  
  <span class="hljs-keyword">return</span> (
    &lt;div className=<span class="hljs-string">"pointer-events-none absolute inset-0 z-20"</span>&gt;
      {state.claims.map(<span class="hljs-function"><span class="hljs-params">claim</span> =&gt;</span> (
        &lt;ClaimHighlight
          key={claim.id}
          claim={claim}
          containerRef={containerRef}
        /&gt;
      ))}
      
      {<span class="hljs-comment">/* Argument connectors (in full mode) */</span>}
      {state.viewMode === <span class="hljs-string">'full'</span> &amp;&amp; (
        &lt;ArgumentConnectors 
          <span class="hljs-built_in">arguments</span>={state.arguments}
          claims={state.claims}
          containerRef={containerRef}
        /&gt;
      )}
    &lt;<span class="hljs-regexp">/div&gt;
  );
}
</span></div></code></pre>
<h4 id="144-extraction-review-rail">14.4 Extraction Review Rail</h4>
<pre class="hljs"><code><div><span class="hljs-comment">// components/article/extraction/ExtractionRail.tsx</span>

<span class="hljs-string">"use client"</span>;

<span class="hljs-keyword">import</span> { useExtraction } <span class="hljs-keyword">from</span> <span class="hljs-string">'./ExtractionContext'</span>;
<span class="hljs-keyword">import</span> { ExtractedClaimData, ExtractedArgumentData } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/lib/extraction/types'</span>;
<span class="hljs-keyword">import</span> { CheckIcon, XIcon, PencilIcon, LinkIcon } <span class="hljs-keyword">from</span> <span class="hljs-string">'lucide-react'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ExtractionRail</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> { state, actions } = useExtraction();
  
  <span class="hljs-keyword">if</span> (state.status !== <span class="hljs-string">'reviewing'</span> || state.viewMode === <span class="hljs-string">'off'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
  
  <span class="hljs-keyword">const</span> pendingClaims = state.claims.filter(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c.status === <span class="hljs-string">'PENDING'</span>);
  <span class="hljs-keyword">const</span> reviewedClaims = state.claims.filter(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c.status !== <span class="hljs-string">'PENDING'</span>);
  
  <span class="hljs-keyword">return</span> (
    &lt;div className=<span class="hljs-string">"w-80 h-full overflow-y-auto bg-slate-50 border-l border-slate-200 p-4"</span>&gt;
      {<span class="hljs-comment">/* Header */</span>}
      &lt;div className=<span class="hljs-string">"flex items-center justify-between mb-4"</span>&gt;
        &lt;h3 className=<span class="hljs-string">"font-semibold text-slate-800"</span>&gt;Extracted Claims&lt;<span class="hljs-regexp">/h3&gt;
        &lt;span className="text-sm text-slate-500"&gt;
          {state.stats.approvedClaims}/</span>{state.stats.totalClaims} reviewed
        &lt;<span class="hljs-regexp">/span&gt;
      &lt;/</span>div&gt;
      
      {<span class="hljs-comment">/* Progress bar */</span>}
      &lt;div className=<span class="hljs-string">"h-1.5 bg-slate-200 rounded-full mb-4 overflow-hidden"</span>&gt;
        &lt;div 
          className=<span class="hljs-string">"h-full bg-green-500 transition-all"</span>
          style={{ 
            width: <span class="hljs-string">`<span class="hljs-subst">${(state.stats.approvedClaims <span class="hljs-regexp">/ state.stats.totalClaims) * 100}%` 
          }}
        /</span>&gt;
      &lt;<span class="hljs-regexp">/div&gt;
      
      {/</span>* Quick actions *<span class="hljs-regexp">/}
      &lt;div className="flex gap-2 mb-4"&gt;
        &lt;button
          onClick={actions.approveAll}
          className="flex-1 px-3 py-1.5 text-sm bg-green-100 text-green-700 rounded hover:bg-green-200"
        &gt;
          Approve All
        &lt;/</span>button&gt;
        &lt;button
          onClick={() =&gt; actions.publishApproved()}</span>
          className="flex-1 px-3 py-1.5 text-sm bg-indigo-600 text-white rounded hover:bg-indigo-700"
          disabled={state.stats.approvedClaims === 0}
        &gt;
          Publish ({state.stats.approvedClaims})
        &lt;/button&gt;
      &lt;/div&gt;
      
      {/* Pending claims */}
      {pendingClaims.length &gt; 0 &amp;&amp; (
        &lt;div className="mb-6"&gt;
          &lt;h4 className="text-xs font-medium text-slate-500 uppercase mb-2"&gt;
            Pending Review ({pendingClaims.length})
          &lt;/h4&gt;
          &lt;div className="space-y-2"&gt;
            {pendingClaims.map(claim =&gt; (
              &lt;ClaimCard key={claim.id} claim={claim} /&gt;
            ))}
          &lt;/div&gt;
        &lt;/div&gt;
      )}
      
      {/* Reviewed claims */}
      {reviewedClaims.length &gt; 0 &amp;&amp; (
        &lt;div&gt;
          &lt;h4 className="text-xs font-medium text-slate-500 uppercase mb-2"&gt;
            Reviewed ({reviewedClaims.length})
          &lt;/h4&gt;
          &lt;div className="space-y-2"&gt;
            {reviewedClaims.map(claim =&gt; (
              &lt;ClaimCard key={claim.id} claim={claim} /&gt;
            ))}
          &lt;/div&gt;
        &lt;/div&gt;
      )}
      
      {/* Arguments section */}
      &lt;div className="mt-6 pt-6 border-t border-slate-200"&gt;
        &lt;h3 className="font-semibold text-slate-800 mb-4"&gt;Extracted Arguments&lt;/h3&gt;
        &lt;div className="space-y-3"&gt;
          {state.arguments.map(arg =&gt; (
            &lt;ArgumentCard key={arg.id} argument={arg} claims={state.claims} /&gt;
          ))}
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

function ClaimCard({ claim }: { claim: ExtractedClaimData }) {
  const { state, actions } = useExtraction();
  const isSelected = state.selectedClaimId === claim.id;
  
  const statusStyles = {
    PENDING: 'border-amber-300 bg-amber-50',
    APPROVED: 'border-green-400 bg-green-50',
    REJECTED: 'border-red-300 bg-red-50 opacity-60',
    MODIFIED: 'border-blue-400 bg-blue-50',
    MERGED: 'border-purple-400 bg-purple-50',
    PUBLISHED: 'border-green-500 bg-green-100'
  };
  
  return (
    &lt;div
      className={`</span>
        p<span class="hljs-number">-3</span> rounded-lg border transition-all cursor-pointer
        ${statusStyles[claim.status]}
        ${isSelected ? <span class="hljs-string">'ring-2 ring-indigo-500'</span> : <span class="hljs-string">''</span>}
      <span class="hljs-string">`}
      onClick={() =&gt; actions.selectClaim(claim.id)}
    &gt;
      {/* Claim type badge */}
      &lt;div className="flex items-center gap-2 mb-1.5"&gt;
        &lt;span className="text-[10px] font-medium px-1.5 py-0.5 rounded bg-slate-200 text-slate-600"&gt;
          {claim.claimType?.toUpperCase() || 'CLAIM'}
        &lt;/span&gt;
        &lt;span className="text-[10px] text-slate-500"&gt;
          {Math.round(claim.confidence * 100)}% confidence
        &lt;/span&gt;
      &lt;/div&gt;
      
      {/* Claim text */}
      &lt;p className="text-sm text-slate-800 line-clamp-3 mb-2"&gt;
        {claim.text}
      &lt;/p&gt;
      
      {/* Actions */}
      {claim.status === 'PENDING' &amp;&amp; (
        &lt;div className="flex gap-1"&gt;
          &lt;button
            onClick={(e) =&gt; { e.stopPropagation(); actions.approveClaim(claim.id); }}
            className="p-1.5 rounded bg-green-100 text-green-700 hover:bg-green-200"
            title="Approve"
          &gt;
            &lt;CheckIcon size={14} /&gt;
          &lt;/button&gt;
          &lt;button
            onClick={(e) =&gt; { e.stopPropagation(); actions.rejectClaim(claim.id); }}
            className="p-1.5 rounded bg-red-100 text-red-700 hover:bg-red-200"
            title="Reject"
          &gt;
            &lt;XIcon size={14} /&gt;
          &lt;/button&gt;
          &lt;button
            onClick={(e) =&gt; { e.stopPropagation(); /* open editor */ }}
            className="p-1.5 rounded bg-slate-100 text-slate-600 hover:bg-slate-200"
            title="Edit"
          &gt;
            &lt;PencilIcon size={14} /&gt;
          &lt;/button&gt;
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
}

function ArgumentCard({ 
  argument, 
  claims 
}: { 
  argument: ExtractedArgumentData;
  claims: ExtractedClaimData[];
}) {
  const { actions } = useExtraction();
  const conclusion = claims.find(c =&gt; c.id === argument.conclusionId);
  const premises = argument.premiseIds.map(id =&gt; claims.find(c =&gt; c.id === id)).filter(Boolean);
  
  return (
    &lt;div className="p-3 rounded-lg border border-slate-300 bg-white"&gt;
      {/* Scheme badge */}
      {argument.primarySchemeId &amp;&amp; (
        &lt;div className="flex items-center gap-2 mb-2"&gt;
          &lt;span className="text-[10px] font-medium px-2 py-0.5 rounded-full bg-indigo-100 text-indigo-700"&gt;
            {argument.primarySchemeId.replace(/_/g, ' ')}
          &lt;/span&gt;
          &lt;span className="text-[10px] text-slate-500"&gt;
            {Math.round((argument.schemeConfidence || 0) * 100)}%
          &lt;/span&gt;
        &lt;/div&gt;
      )}
      
      {/* Premises */}
      &lt;div className="space-y-1 mb-2"&gt;
        {premises.map((p, i) =&gt; (
          &lt;div key={p!.id} className="flex items-start gap-1.5"&gt;
            &lt;span className="text-[10px] text-slate-400 mt-0.5"&gt;P{i + 1}&lt;/span&gt;
            &lt;p className="text-xs text-slate-600 line-clamp-2"&gt;{p!.text}&lt;/p&gt;
          &lt;/div&gt;
        ))}
      &lt;/div&gt;
      
      {/* Arrow */}
      &lt;div className="text-center text-slate-400 text-sm"&gt;↓&lt;/div&gt;
      
      {/* Conclusion */}
      &lt;div className="flex items-start gap-1.5 mt-1"&gt;
        &lt;span className="text-[10px] text-indigo-500 font-medium mt-0.5"&gt;∴&lt;/span&gt;
        &lt;p className="text-xs text-slate-800 font-medium line-clamp-2"&gt;
          {conclusion?.text}
        &lt;/p&gt;
      &lt;/div&gt;
      
      {/* Confidence */}
      &lt;div className="mt-2 flex items-center justify-between"&gt;
        &lt;span className="text-[10px] text-slate-500"&gt;
          Argument confidence: {Math.round(argument.confidence * 100)}%
        &lt;/span&gt;
        &lt;button
          onClick={() =&gt; actions.selectArgument(argument.id)}
          className="text-[10px] text-indigo-600 hover:underline"
        &gt;
          Edit structure →
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</span></div></code></pre>
<hr>
<h3 id="15-integration-with-articlereaderwithpins">15. Integration with ArticleReaderWithPins</h3>
<p><strong>Goal</strong>: Seamlessly integrate extraction UI into existing article reading experience.</p>
<h4 id="151-enhanced-articlereaderwithpins">15.1 Enhanced ArticleReaderWithPins</h4>
<pre class="hljs"><code><div><span class="hljs-comment">// components/article/ArticleReaderWithPinsExtended.tsx</span>

<span class="hljs-string">"use client"</span>;

<span class="hljs-keyword">import</span> { useRef } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ArticleReaderWithPins <span class="hljs-keyword">from</span> <span class="hljs-string">'./ArticleReaderWithPins'</span>;
<span class="hljs-keyword">import</span> { ExtractionProvider, useExtraction } <span class="hljs-keyword">from</span> <span class="hljs-string">'./extraction/ExtractionContext'</span>;
<span class="hljs-keyword">import</span> { ExtractionToolbar } <span class="hljs-keyword">from</span> <span class="hljs-string">'./extraction/ExtractionToolbar'</span>;
<span class="hljs-keyword">import</span> { ExtractionOverlay } <span class="hljs-keyword">from</span> <span class="hljs-string">'./extraction/ClaimHighlight'</span>;
<span class="hljs-keyword">import</span> { ExtractionRail } <span class="hljs-keyword">from</span> <span class="hljs-string">'./extraction/ExtractionRail'</span>;

<span class="hljs-keyword">interface</span> ExtendedProps {
  <span class="hljs-comment">// Existing props from ArticleReaderWithPins</span>
  template: <span class="hljs-built_in">string</span>;
  heroSrc?: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;
  html: <span class="hljs-built_in">string</span>;
  threads: CommentThread[];
  articleSlug: <span class="hljs-built_in">string</span>;
  title?: <span class="hljs-built_in">string</span>;
  currentUser?: unknown;
  deliberationId?: <span class="hljs-built_in">string</span>;
  
  <span class="hljs-comment">// New extraction props</span>
  articleId: <span class="hljs-built_in">string</span>;
  extractionEnabled?: <span class="hljs-built_in">boolean</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ArticleReaderWithPinsExtended</span>(<span class="hljs-params">props: ExtendedProps</span>) </span>{
  <span class="hljs-keyword">const</span> { articleId, extractionEnabled = <span class="hljs-literal">true</span>, ...readerProps } = props;
  
  <span class="hljs-keyword">if</span> (!extractionEnabled) {
    <span class="hljs-keyword">return</span> &lt;ArticleReaderWithPins {...readerProps} /&gt;;
  }
  
  <span class="hljs-keyword">return</span> (
    &lt;ExtractionProvider articleId={articleId}&gt;
      &lt;ArticleReaderWithExtraction {...readerProps} articleId={articleId} /&gt;
    &lt;<span class="hljs-regexp">/ExtractionProvider&gt;
  );
}

function ArticleReaderWithExtraction({ 
  articleId,
  ...props 
}: ExtendedProps) {
  const containerRef = useRef&lt;HTMLDivElement&gt;(null);
  const { state } = useExtraction();
  
  return (
    &lt;div className="flex"&gt;
      {/</span>* Main article area *<span class="hljs-regexp">/}
      &lt;div className="flex-1 relative"&gt;
        {/</span>* Extraction toolbar (floating) *<span class="hljs-regexp">/}
        &lt;ExtractionToolbar articleId={articleId} /</span>&gt;
        
        {<span class="hljs-comment">/* Original reader */</span>}
        &lt;div ref={containerRef} className=<span class="hljs-string">"relative"</span>&gt;
          &lt;ArticleReaderWithPins {...props} /&gt;
          
          {<span class="hljs-comment">/* Extraction overlay */</span>}
          &lt;ExtractionOverlay containerRef={containerRef} /&gt;
        &lt;<span class="hljs-regexp">/div&gt;
      &lt;/</span>div&gt;
      
      {<span class="hljs-comment">/* Extraction rail (conditional) */</span>}
      {state.status === <span class="hljs-string">'reviewing'</span> &amp;&amp; state.viewMode !== <span class="hljs-string">'off'</span> &amp;&amp; (
        &lt;ExtractionRail /&gt;
      )}
    &lt;<span class="hljs-regexp">/div&gt;
  );
}
</span></div></code></pre>
<h4 id="152-extraction-toolbar">15.2 Extraction Toolbar</h4>
<pre class="hljs"><code><div><span class="hljs-comment">// components/article/extraction/ExtractionToolbar.tsx</span>

<span class="hljs-string">"use client"</span>;

<span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { useExtraction } <span class="hljs-keyword">from</span> <span class="hljs-string">'./ExtractionContext'</span>;
<span class="hljs-keyword">import</span> { 
  SparklesIcon, 
  EyeIcon, 
  EyeOffIcon,
  SettingsIcon,
  DownloadIcon 
} <span class="hljs-keyword">from</span> <span class="hljs-string">'lucide-react'</span>;

<span class="hljs-keyword">interface</span> ExtractionToolbarProps {
  articleId: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ExtractionToolbar</span>(<span class="hljs-params">{ articleId }: ExtractionToolbarProps</span>) </span>{
  <span class="hljs-keyword">const</span> { state, actions } = useExtraction();
  <span class="hljs-keyword">const</span> [showSettings, setShowSettings] = useState(<span class="hljs-literal">false</span>);
  
  <span class="hljs-keyword">return</span> (
    &lt;div className=<span class="hljs-string">"fixed top-20 right-8 z-50 flex flex-col gap-2"</span>&gt;
      {<span class="hljs-comment">/* Main extraction button */</span>}
      {state.status === <span class="hljs-string">'idle'</span> &amp;&amp; (
        &lt;button
          onClick={<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> actions.startExtraction(articleId)}
          className=<span class="hljs-string">"flex items-center gap-2 px-4 py-2 bg-indigo-600 text-white rounded-lg shadow-lg hover:bg-indigo-700 transition-colors"</span>
        &gt;
          &lt;SparklesIcon size={<span class="hljs-number">18</span>} /&gt;
          &lt;span className=<span class="hljs-string">"font-medium"</span>&gt;Extract Claims&lt;<span class="hljs-regexp">/span&gt;
        &lt;/</span>button&gt;
      )}
      
      {<span class="hljs-comment">/* Progress indicator */</span>}
      {state.status === <span class="hljs-string">'extracting'</span> &amp;&amp; (
        &lt;div className=<span class="hljs-string">"flex items-center gap-3 px-4 py-2 bg-white rounded-lg shadow-lg border border-slate-200"</span>&gt;
          &lt;div className=<span class="hljs-string">"w-4 h-4 border-2 border-indigo-600 border-t-transparent rounded-full animate-spin"</span> /&gt;
          &lt;div className=<span class="hljs-string">"flex flex-col"</span>&gt;
            &lt;span className=<span class="hljs-string">"text-sm font-medium text-slate-700"</span>&gt;Extracting...&lt;<span class="hljs-regexp">/span&gt;
            &lt;span className="text-xs text-slate-500"&gt;{state.progress}% complete&lt;/</span>span&gt;
          &lt;<span class="hljs-regexp">/div&gt;
        &lt;/</span>div&gt;
      )}
      
      {<span class="hljs-comment">/* Review mode controls */</span>}
      {state.status === <span class="hljs-string">'reviewing'</span> &amp;&amp; (
        &lt;&gt;
          {<span class="hljs-comment">/* View mode toggle */</span>}
          &lt;div className=<span class="hljs-string">"flex bg-white rounded-lg shadow-lg border border-slate-200 p-1"</span>&gt;
            &lt;button
              onClick={<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> actions.setViewMode(<span class="hljs-string">'off'</span>)}
              className={<span class="hljs-string">`p-2 rounded <span class="hljs-subst">${state.viewMode === <span class="hljs-string">'off'</span> ? <span class="hljs-string">'bg-slate-200'</span> : <span class="hljs-string">''</span>}</span>`</span>}
              title=<span class="hljs-string">"Hide highlights"</span>
            &gt;
              &lt;EyeOffIcon size={<span class="hljs-number">18</span>} className=<span class="hljs-string">"text-slate-600"</span> /&gt;
            &lt;<span class="hljs-regexp">/button&gt;
            &lt;button
              onClick={() =&gt; actions.setViewMode('highlights')}
              className={`p-2 rounded ${state.viewMode === 'highlights' ? 'bg-slate-200' : ''}`}
              title="Show claim highlights"
            &gt;
              &lt;EyeIcon size={18} className="text-slate-600" /</span>&gt;
            &lt;<span class="hljs-regexp">/button&gt;
            &lt;button
              onClick={() =&gt; actions.setViewMode('full')}
              className={`p-2 rounded ${state.viewMode === 'full' ? 'bg-indigo-100' : ''}`}
              title="Show arguments"
            &gt;
              &lt;SparklesIcon size={18} className="text-indigo-600" /</span>&gt;
            &lt;<span class="hljs-regexp">/button&gt;
          &lt;/</span>div&gt;
          
          {<span class="hljs-comment">/* Stats badge */</span>}
          &lt;div className=<span class="hljs-string">"bg-white rounded-lg shadow-lg border border-slate-200 px-3 py-2"</span>&gt;
            &lt;div className=<span class="hljs-string">"text-xs text-slate-500"</span>&gt;Extracted&lt;<span class="hljs-regexp">/div&gt;
            &lt;div className="flex gap-3 mt-1"&gt;
              &lt;span className="text-sm font-medium text-slate-700"&gt;
                {state.stats.totalClaims} claims
              &lt;/</span>span&gt;
              &lt;span className=<span class="hljs-string">"text-sm font-medium text-slate-700"</span>&gt;
                {state.stats.totalArguments} args
              &lt;<span class="hljs-regexp">/span&gt;
            &lt;/</span>div&gt;
          &lt;<span class="hljs-regexp">/div&gt;
          
          {/</span>* Export button *<span class="hljs-regexp">/}
          &lt;button
            onClick={() =&gt; setShowSettings(true)}
            className="p-2 bg-white rounded-lg shadow-lg border border-slate-200 hover:bg-slate-50"
            title="Export options"
          &gt;
            &lt;DownloadIcon size={18} className="text-slate-600" /</span>&gt;
          &lt;<span class="hljs-regexp">/button&gt;
        &lt;/</span>&gt;
      )}
      
      {<span class="hljs-comment">/* Export modal */</span>}
      {showSettings &amp;&amp; (
        &lt;ExportModal 
          jobId={state.jobId!} 
          onClose={<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> setShowSettings(<span class="hljs-literal">false</span>)} 
        /&gt;
      )}
    &lt;<span class="hljs-regexp">/div&gt;
  );
}

function ExportModal({ jobId, onClose }: { jobId: string; onClose: () =&gt; void }) {
  const formats = [
    { id: 'mesh-native', name: 'Mesh JSON', desc: 'Native format for re-import' },
    { id: 'aif-json', name: 'AIF JSON', desc: 'Argument Interchange Format' },
    { id: 'aif-rdf', name: 'AIF RDF/Turtle', desc: 'Semantic web format' },
    { id: 'aspic-theory', name: 'ASPIC+ Theory', desc: 'For formal evaluation' },
    { id: 'carneades-json', name: 'Carneades', desc: 'Evidence-weighted format' }
  ];
  
  const handleExport = async (format: string) =&gt; {
    window.open(`/</span>api/extraction/${jobId}/<span class="hljs-keyword">export</span>?format=${format}<span class="hljs-string">`, '_blank');
  };
  
  return (
    &lt;div className="fixed inset-0 bg-black/50 flex items-center justify-center z-[100]"&gt;
      &lt;div className="bg-white rounded-xl shadow-xl w-[400px] p-6"&gt;
        &lt;h3 className="text-lg font-semibold mb-4"&gt;Export Extraction&lt;/h3&gt;
        
        &lt;div className="space-y-2"&gt;
          {formats.map(fmt =&gt; (
            &lt;button
              key={fmt.id}
              onClick={() =&gt; handleExport(fmt.id)}
              className="w-full flex items-center justify-between p-3 rounded-lg border border-slate-200 hover:bg-slate-50 text-left"
            &gt;
              &lt;div&gt;
                &lt;div className="font-medium text-slate-800"&gt;{fmt.name}&lt;/div&gt;
                &lt;div className="text-xs text-slate-500"&gt;{fmt.desc}&lt;/div&gt;
              &lt;/div&gt;
              &lt;DownloadIcon size={18} className="text-slate-400" /&gt;
            &lt;/button&gt;
          ))}
        &lt;/div&gt;
        
        &lt;button
          onClick={onClose}
          className="mt-4 w-full py-2 text-sm text-slate-600 hover:text-slate-800"
        &gt;
          Cancel
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</span></div></code></pre>
<hr>
<h3 id="16-api-routes-for-extraction">16. API Routes for Extraction</h3>
<pre class="hljs"><code><div><span class="hljs-comment">// app/api/extraction/start/route.ts</span>

<span class="hljs-keyword">import</span> { NextRequest, NextResponse } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/server'</span>;
<span class="hljs-keyword">import</span> { prisma } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/lib/prisma'</span>;
<span class="hljs-keyword">import</span> { getServerSession } <span class="hljs-keyword">from</span> <span class="hljs-string">'next-auth'</span>;
<span class="hljs-keyword">import</span> { extractFromArticle } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/lib/extraction/orchestrator'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">POST</span>(<span class="hljs-params">request: NextRequest</span>) </span>{
  <span class="hljs-keyword">const</span> session = <span class="hljs-keyword">await</span> getServerSession();
  <span class="hljs-keyword">if</span> (!session?.user) {
    <span class="hljs-keyword">return</span> NextResponse.json({ error: <span class="hljs-string">'Unauthorized'</span> }, { status: <span class="hljs-number">401</span> });
  }
  
  <span class="hljs-keyword">const</span> { sourceType, sourceId, config } = <span class="hljs-keyword">await</span> request.json();
  
  <span class="hljs-comment">// Validate source exists</span>
  <span class="hljs-keyword">if</span> (sourceType === <span class="hljs-string">'article'</span>) {
    <span class="hljs-keyword">const</span> article = <span class="hljs-keyword">await</span> prisma.article.findUnique({
      where: { id: sourceId },
      select: { id: <span class="hljs-literal">true</span>, astJson: <span class="hljs-literal">true</span>, authorId: <span class="hljs-literal">true</span> }
    });
    
    <span class="hljs-keyword">if</span> (!article) {
      <span class="hljs-keyword">return</span> NextResponse.json({ error: <span class="hljs-string">'Article not found'</span> }, { status: <span class="hljs-number">404</span> });
    }
  }
  
  <span class="hljs-comment">// Create extraction job</span>
  <span class="hljs-keyword">const</span> job = <span class="hljs-keyword">await</span> prisma.extractionJob.create({
    data: {
      sourceType,
      sourceId,
      status: <span class="hljs-string">'QUEUED'</span>,
      configJson: config || {},
      createdById: session.user.id
    }
  });
  
  <span class="hljs-comment">// Queue background processing</span>
  <span class="hljs-comment">// In production, use BullMQ or similar</span>
  processExtractionJob(job.id).catch(<span class="hljs-built_in">console</span>.error);
  
  <span class="hljs-keyword">return</span> NextResponse.json({ jobId: job.id });
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processExtractionJob</span>(<span class="hljs-params">jobId: <span class="hljs-built_in">string</span></span>) </span>{
  <span class="hljs-comment">// Update status</span>
  <span class="hljs-keyword">await</span> prisma.extractionJob.update({
    where: { id: jobId },
    data: { status: <span class="hljs-string">'PROCESSING'</span>, startedAt: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() }
  });
  
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> job = <span class="hljs-keyword">await</span> prisma.extractionJob.findUnique({
      where: { id: jobId }
    });
    
    <span class="hljs-keyword">if</span> (job?.sourceType === <span class="hljs-string">'article'</span>) {
      <span class="hljs-keyword">const</span> article = <span class="hljs-keyword">await</span> prisma.article.findUnique({
        where: { id: job.sourceId },
        select: { astJson: <span class="hljs-literal">true</span> }
      });
      
      <span class="hljs-keyword">const</span> config = job.configJson <span class="hljs-keyword">as</span> ExtractionConfig || {
        claimModel: <span class="hljs-string">'gpt-4'</span>,
        claimSensitivity: <span class="hljs-number">0.5</span>,
        includeImplicitClaims: <span class="hljs-literal">true</span>,
        minPremises: <span class="hljs-number">1</span>,
        maxPremises: <span class="hljs-number">5</span>,
        argumentMinConfidence: <span class="hljs-number">0.4</span>,
        useLLMForArguments: <span class="hljs-literal">true</span>,
        schemeMatcherWeights: { ruleBased: <span class="hljs-number">0.3</span>, embedding: <span class="hljs-number">0.3</span>, llm: <span class="hljs-number">0.4</span> },
        linkCitations: <span class="hljs-literal">true</span>,
        resolveDOIs: <span class="hljs-literal">true</span>
      };
      
      <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> extractFromArticle(
        job.sourceId,
        article!.astJson,
        config
      );
      
      <span class="hljs-comment">// Store results</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> claim of result.claims) {
        <span class="hljs-keyword">await</span> prisma.extractedClaim.create({
          data: {
            jobId,
            text: claim.text,
            anchorJson: claim.anchor,
            sourceText: claim.sourceText,
            confidence: claim.confidence,
            claimType: claim.claimType,
            isImplicit: claim.isImplicit,
            status: <span class="hljs-string">'PENDING'</span>
          }
        });
      }
      
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> arg of result.arguments) {
        <span class="hljs-keyword">const</span> extArg = <span class="hljs-keyword">await</span> prisma.extractedArgument.create({
          data: {
            jobId,
            conclusionId: arg.conclusionId,  <span class="hljs-comment">// Will need ID mapping</span>
            primarySchemeId: arg.primarySchemeId,
            schemeConfidence: arg.schemeConfidence,
            confidence: arg.confidence,
            status: <span class="hljs-string">'PENDING'</span>
          }
        });
        
        <span class="hljs-comment">// Create premise links</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> premiseId of arg.premiseIds) {
          <span class="hljs-keyword">await</span> prisma.extractedArgumentPremise.create({
            data: {
              argumentId: extArg.id,
              claimId: premiseId  <span class="hljs-comment">// Will need ID mapping</span>
            }
          });
        }
      }
      
      <span class="hljs-keyword">await</span> prisma.extractionJob.update({
        where: { id: jobId },
        data: {
          status: <span class="hljs-string">'PENDING_REVIEW'</span>,
          completedAt: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),
          claimsExtracted: result.claims.length,
          argumentsExtracted: result.arguments.length,
          rawResultJson: result
        }
      });
    }
    
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-keyword">await</span> prisma.extractionJob.update({
      where: { id: jobId },
      data: {
        status: <span class="hljs-string">'FAILED'</span>,
        error: error <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Error</span> ? error.message : <span class="hljs-string">'Unknown error'</span>
      }
    });
  }
}
</div></code></pre>
<hr>
<h3 id="17-publish-workflow">17. Publish Workflow</h3>
<pre class="hljs"><code><div><span class="hljs-comment">// app/api/extraction/[jobId]/publish/route.ts</span>

<span class="hljs-keyword">import</span> { NextRequest, NextResponse } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/server'</span>;
<span class="hljs-keyword">import</span> { prisma } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/lib/prisma'</span>;
<span class="hljs-keyword">import</span> { getServerSession } <span class="hljs-keyword">from</span> <span class="hljs-string">'next-auth'</span>;
<span class="hljs-keyword">import</span> { generateMoid } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/lib/util/moid'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">POST</span>(<span class="hljs-params">
  request: NextRequest,
  { params }: { params: { jobId: <span class="hljs-built_in">string</span> } }
</span>) </span>{
  <span class="hljs-keyword">const</span> session = <span class="hljs-keyword">await</span> getServerSession();
  <span class="hljs-keyword">if</span> (!session?.user) {
    <span class="hljs-keyword">return</span> NextResponse.json({ error: <span class="hljs-string">'Unauthorized'</span> }, { status: <span class="hljs-number">401</span> });
  }
  
  <span class="hljs-keyword">const</span> { claimIds, argumentIds, deliberationId } = <span class="hljs-keyword">await</span> request.json();
  
  <span class="hljs-keyword">const</span> job = <span class="hljs-keyword">await</span> prisma.extractionJob.findUnique({
    where: { id: params.jobId },
    include: {
      extractedClaims: { where: { id: { <span class="hljs-keyword">in</span>: claimIds } } },
      extractedArguments: { 
        where: { id: { <span class="hljs-keyword">in</span>: argumentIds } },
        include: { premises: <span class="hljs-literal">true</span> }
      }
    }
  });
  
  <span class="hljs-keyword">if</span> (!job) {
    <span class="hljs-keyword">return</span> NextResponse.json({ error: <span class="hljs-string">'Job not found'</span> }, { status: <span class="hljs-number">404</span> });
  }
  
  <span class="hljs-comment">// Get or create target deliberation</span>
  <span class="hljs-keyword">let</span> targetDelibId = deliberationId || job.deliberationId;
  <span class="hljs-keyword">if</span> (!targetDelibId &amp;&amp; job.sourceType === <span class="hljs-string">'article'</span>) {
    <span class="hljs-comment">// Create deliberation linked to article</span>
    <span class="hljs-keyword">const</span> delib = <span class="hljs-keyword">await</span> prisma.deliberation.create({
      data: {
        name: <span class="hljs-string">`Extracted from article <span class="hljs-subst">${job.sourceId}</span>`</span>,
        hostType: <span class="hljs-string">'article'</span>,
        hostId: job.sourceId,
        createdById: session.user.id
      }
    });
    targetDelibId = delib.id;
  }
  
  <span class="hljs-keyword">const</span> claimIdMap = <span class="hljs-keyword">new</span> Map&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt;();  <span class="hljs-comment">// ExtractedClaim.id → Claim.id</span>
  <span class="hljs-keyword">const</span> createdClaims: <span class="hljs-built_in">string</span>[] = [];
  <span class="hljs-keyword">const</span> createdArguments: <span class="hljs-built_in">string</span>[] = [];
  
  <span class="hljs-comment">// Create Claim entities</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> extClaim of job.extractedClaims) {
    <span class="hljs-keyword">const</span> claim = <span class="hljs-keyword">await</span> prisma.claim.create({
      data: {
        text: extClaim.modifiedText || extClaim.text,
        createdById: session.user.id,
        moid: generateMoid(),
        deliberationId: targetDelibId,
        extractedFromJobId: job.id,
        extractionConfidence: extClaim.confidence
      }
    });
    
    claimIdMap.set(extClaim.id, claim.id);
    createdClaims.push(claim.id);
    
    <span class="hljs-comment">// Create ArticleClaimAnchor</span>
    <span class="hljs-keyword">if</span> (job.sourceType === <span class="hljs-string">'article'</span>) {
      <span class="hljs-keyword">await</span> prisma.articleClaimAnchor.create({
        data: {
          articleId: job.sourceId,
          claimId: claim.id,
          anchorJson: extClaim.anchorJson,
          sourceText: extClaim.sourceText,
          extractionJobId: job.id
        }
      });
    }
    
    <span class="hljs-comment">// Update extracted claim status</span>
    <span class="hljs-keyword">await</span> prisma.extractedClaim.update({
      where: { id: extClaim.id },
      data: { status: <span class="hljs-string">'PUBLISHED'</span>, publishedClaimId: claim.id }
    });
  }
  
  <span class="hljs-comment">// Create Argument entities</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> extArg of job.extractedArguments) {
    <span class="hljs-keyword">const</span> conclusionClaimId = claimIdMap.get(extArg.conclusionId);
    <span class="hljs-keyword">if</span> (!conclusionClaimId) <span class="hljs-keyword">continue</span>;
    
    <span class="hljs-keyword">const</span> argument = <span class="hljs-keyword">await</span> prisma.argument.create({
      data: {
        deliberationId: targetDelibId!,
        authorId: session.user.id,
        text: <span class="hljs-string">''</span>,  <span class="hljs-comment">// Arguments don't have separate text</span>
        conclusionClaimId,
        schemeId: extArg.primarySchemeId,
        confidence: extArg.confidence
      }
    });
    
    <span class="hljs-comment">// Create premises</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> premise of extArg.premises) {
      <span class="hljs-keyword">const</span> premiseClaimId = claimIdMap.get(premise.claimId);
      <span class="hljs-keyword">if</span> (premiseClaimId) {
        <span class="hljs-keyword">await</span> prisma.argumentPremise.create({
          data: {
            argumentId: argument.id,
            claimId: premiseClaimId,
            isImplicit: premise.isImplicit
          }
        });
      }
    }
    
    createdArguments.push(argument.id);
    
    <span class="hljs-keyword">await</span> prisma.extractedArgument.update({
      where: { id: extArg.id },
      data: { status: <span class="hljs-string">'PUBLISHED'</span>, publishedArgumentId: argument.id }
    });
  }
  
  <span class="hljs-comment">// Update job status</span>
  <span class="hljs-keyword">await</span> prisma.extractionJob.update({
    where: { id: params.jobId },
    data: {
      status: <span class="hljs-string">'PUBLISHED'</span>,
      deliberationId: targetDelibId,
      claimsApproved: createdClaims.length,
      argumentsApproved: createdArguments.length
    }
  });
  
  <span class="hljs-keyword">return</span> NextResponse.json({
    success: <span class="hljs-literal">true</span>,
    deliberationId: targetDelibId,
    claimsCreated: createdClaims.length,
    argumentsCreated: createdArguments.length
  });
}
</div></code></pre>
<hr>
<h2 id="part-4-summary">Part 4 Summary</h2>
<p>This part detailed:</p>
<ol>
<li>
<p><strong>Extraction UI Components</strong>:</p>
<ul>
<li><code>ExtractionProvider</code> context for state management</li>
<li><code>ClaimHighlight</code> overlay for visual feedback</li>
<li><code>ExtractionRail</code> sidebar for review workflow</li>
<li><code>ExtractionToolbar</code> for extraction controls</li>
</ul>
</li>
<li>
<p><strong>Integration with ArticleReaderWithPins</strong>:</p>
<ul>
<li>Seamless addition to existing article reading</li>
<li>Shared anchor utilities</li>
<li>Parallel comment and extraction rails</li>
</ul>
</li>
<li>
<p><strong>API Routes</strong>:</p>
<ul>
<li><code>/api/extraction/start</code> - Initiate extraction job</li>
<li><code>/api/extraction/[jobId]/status</code> - Poll for progress</li>
<li><code>/api/extraction/[jobId]/results</code> - Get extraction results</li>
<li><code>/api/extraction/[jobId]/publish</code> - Create real Claims/Arguments</li>
<li><code>/api/extraction/[jobId]/export</code> - Export to AIF/ASPIC+/CEG</li>
</ul>
</li>
<li>
<p><strong>Publish Workflow</strong>:</p>
<ul>
<li>Map extracted claims to real Claim entities</li>
<li>Create Arguments with premises</li>
<li>Generate ArticleClaimAnchor for bidirectional linking</li>
<li>Update extraction job status</li>
</ul>
</li>
</ol>
<hr>
<h2 id="complete-document-summary">Complete Document Summary</h2>
<p>This specification covers the <strong>Article-to-Argument Extraction Pipeline</strong> in four parts:</p>
<table>
<thead>
<tr>
<th>Part</th>
<th>Focus</th>
<th>Key Deliverables</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Part 1</strong></td>
<td>Architecture &amp; Data Model</td>
<td>System overview, Prisma schema extensions, Anchor design</td>
</tr>
<tr>
<td><strong>Part 2</strong></td>
<td>Extraction Engine</td>
<td>Claim detection, argument assembly, scheme recognition, evidence linking</td>
</tr>
<tr>
<td><strong>Part 3</strong></td>
<td>Ontology Export</td>
<td>AIF, ASPIC+, Carneades converters, unified export API</td>
</tr>
<tr>
<td><strong>Part 4</strong></td>
<td>UI &amp; Workflows</td>
<td>React components, ArticleReaderWithPins integration, publish workflow</td>
</tr>
</tbody>
</table>
<h3 id="implementation-priorities">Implementation Priorities</h3>
<ol>
<li><strong>Phase 1</strong>: Core extraction (claims + basic arguments)</li>
<li><strong>Phase 2</strong>: Scheme recognition</li>
<li><strong>Phase 3</strong>: Evidence linking</li>
<li><strong>Phase 4</strong>: UI integration</li>
<li><strong>Phase 5</strong>: Ontology exports</li>
</ol>
<h3 id="open-questions">Open Questions</h3>
<ol>
<li><strong>LLM selection</strong>: GPT-4 vs Claude for extraction quality/cost tradeoffs?</li>
<li><strong>Implicit claims</strong>: How aggressively to reconstruct enthymemes?</li>
<li><strong>Batch vs. interactive</strong>: Extract whole article or incremental selection?</li>
<li><strong>Multi-user review</strong>: How to handle concurrent review of same extraction?</li>
</ol>
<hr>
<p><em>This document is a living specification. Iterate as implementation reveals new requirements.</em></p>

</body>
</html>
