generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
  engineType      = "library"
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  directUrl  = env("DIRECT_URL")
  extensions = [uuid_ossp(map: "uuid-ossp", schema: "extensions"), vector]
}

/// This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
model User {
  id                        BigInt                    @id @default(autoincrement())
  auth_id                   String                    @unique
  created_at                DateTime                  @default(now()) @db.Timestamptz(6)
  updated_at                DateTime?                 @default(now()) @updatedAt @db.Timestamptz(6)
  username                  String                    @db.VarChar
  name                      String
  image                     String?
  bio                       String?
  onboarded                 Boolean                   @default(false)
  archivedPosts             ArchivedPost[]
  archivedRealtimePosts     ArchivedRealtimePost[]
  conversationsUser1        Conversation[]            @relation("ConversationUser1")
  conversationsUser2        Conversation[]            @relation("ConversationUser2")
  conversation_participants ConversationParticipant[]
  favoriteItems             FavoriteItem[]
  following                 Follow[]                  @relation("FollowingRelation")
  followers                 Follow[]                  @relation("FollowerRelation")
  friendSuggestionsTarget   FriendSuggestion[]        @relation("SuggestionsTarget")
  friendSuggestionsCreated  FriendSuggestion[]        @relation("SuggestionsCreator")
  integrations              Integration[]
  likes                     Like[]
  linkedAccounts            LinkedAccount[]
  messages                  Message[]
  sentNotifications         Notification[]            @relation("NotificationActor")
  receivedNotifications     Notification[]            @relation("NotificationUser")
  productReviewVotes        ProductReviewVote[]
  productReviewVouches      ProductReviewVouch[]
  productReviews            ProductReview[]
  realtimeedges             RealtimeEdge[]
  realtimeLikes             RealtimeLike[]
  realtimeposts             RealtimePost[]
  feedPosts                 FeedPost[]
  libraryPosts              LibraryPost[]
  stacks                    Stack[]
  portfolioPages            PortfolioPage[] // ðŸ‘ˆ back-relation
  annotations               Annotation[]
  realtimeRoomInviteTokens  RealtimeRoomInviteToken[]
  recommendationClicks      RecommendationClick[]
  attributeEdits            UserAttributeEdit[]
  userAttributes            UserAttributes?
  userEmbedding             UserEmbedding?
  createdPredictionMarkets  PredictionMarket[]        @relation("CreatedPredictionMarkets")
  oraclePredictionMarkets   PredictionMarket[]        @relation("OraclePredictionMarkets")
  trades                    Trade[]                   @relation("UserTrades")
  wallet                    Wallet?
  resolutionLogs            ResolutionLog[]
  realtimerooms             UserRealtimeRoom[]
  workflows                 Workflow[]
  stalls                    Stall[]
  offers                    Offer[]
  bids                      Bid[]
  orders                    Order[]
  StallMessage              StallMessage[]
  cartItems                 CartItem[]
  carts                     Cart[]
  settings                  UserSettings?
  Auction                   Auction[]
  StackCollaborator         StackCollaborator[]
  StackSubscription         StackSubscription[]
  stackItemsAdded           StackItem[]               // Blocks/stacks this user added to stacks
  SheafAudienceList         SheafAudienceList[]
  roles                     UserRole[]
  reactions                 MessageReaction[]
  createdIssues             Issue[]                   @relation("CreatedIssues")
  assignedIssues            Issue[]                   @relation("AssignedIssues")
  answeredIssues            Issue[]                   @relation("AnsweredIssues")

  driftMembers     DriftMember[]
  MessageMention   MessageMention[]
  // Stars & Bookmarks back-relations
  messageStars     MessageStar[]
  bookmarks        Bookmark[]
  ActivityPubKey   ActivityPubKey[]
  ApFollower       ApFollower[]
  ApFollowing      ApFollowing[]
  ApOutboxActivity ApOutboxActivity[]
  mergedReceipts   MergeReceipt[]     @relation("UserMergedReceipts")
  proposalSignals  ProposalSignal[]   @relation("UserProposalSignals")
  expertiseTags    String[]           @default([])

  // Glossary system relations
  proposedTerms          GlossaryTerm[]              @relation("ProposedTerms")
  authoredDefinitions    GlossaryDefinition[]        @relation("AuthoredDefinitions")
  definitionEndorsements GlossaryEndorsement[]       @relation("DefinitionEndorsements")
  definitionVotes        GlossaryDefinitionVote[]    @relation("DefinitionVotes")
  definitionChanges      GlossaryDefinitionHistory[] @relation("DefinitionChanges")

  // Thesis builder relations
  authoredTheses Thesis[] @relation("AuthoredTheses")

  // Source rating relations
  sourceRatings SourceRating[]

  // Phase 3.1: Source alert notifications
  sourceAlertNotifications SourceAlertNotification[]

  // Phase 3.2: Reference manager connections
  referenceManagerConnections ReferenceManagerConnection[]

  // ASPIC+ Explicit Contraries - Phase D-1
  claimContraries ClaimContrary[]

  // ArgumentChain relations
  createdArgumentChains     ArgumentChain[]     @relation
  addedChainNodes           ArgumentChainNode[]
  createdArgumentScopes     ArgumentScope[]

  // Phase 3.2.4: Public API keys
  apiKeys                   ApiKey[]

  @@map("users")
}

model UserAttributes {
  id                  BigInt     @id @default(autoincrement())
  user_id             BigInt     @unique
  created_at          DateTime   @default(now()) @db.Timestamptz(6)
  artists             String[]
  albums              String[]
  songs               String[]
  interests           String[]
  movies              String[]
  birthday            DateTime?
  communities         String[]
  hobbies             String[]
  location            String?
  books               String[]
  events_visibility   visibility @default(PUBLIC)
  tv_visibility       visibility @default(PUBLIC)
  podcasts_visibility visibility @default(PUBLIC)
  updated_at          DateTime   @default(now()) @updatedAt @db.Timestamptz(6)
  user                User       @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@map("user_attributes")
}

/// This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
model Like {
  id           BigInt    @id @default(autoincrement())
  created_at   DateTime  @default(now()) @db.Timestamptz(6)
  score        Int
  type         like_type @default(LIKE)
  user_id      BigInt
  updated_at   DateTime? @default(now()) @updatedAt @db.Timestamptz(6)
  feed_post_id BigInt
  feedPost     FeedPost  @relation(fields: [feed_post_id], references: [id], onDelete: Cascade)
  user         User      @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([feed_post_id, user_id])
  @@map("likes")
}

model FeedPost {
  id BigInt @id @default(autoincrement())

  created_at DateTime       @default(now()) @db.Timestamptz(6)
  updated_at DateTime?      @default(now()) @updatedAt @db.Timestamptz(6)
  author_id  BigInt
  type       feed_post_type
  content    String?
  image_url  String?
  portfolio  Json? // <-- add this

  video_url        String?
  caption          String?
  isPublic         Boolean           @default(true)
  like_count       Int               @default(0)
  expiration_date  DateTime?
  author           User              @relation(fields: [author_id], references: [id])
  predictionMarket PredictionMarket? @relation("FeedPostPrediction")
  productReview    ProductReview?
  libraryPost      LibraryPost?      @relation(fields: [library_post_id], references: [id], onDelete: SetNull, onUpdate: Cascade)
  stack            Stack?            @relation(fields: [stack_id], references: [id], onDelete: SetNull, onUpdate: Cascade)
  articleId        String?           @unique
  thumbnailKey     String? // 4:3 hero variant stored in CDN
  tldr             String? // 280-char summary
  parent_id        BigInt?
  pluginData       Json?
  pluginType       String?
  feedPost         FeedPost?         @relation("FeedPostChildren", fields: [parent_id], references: [id], onDelete: Restrict)
  children         FeedPost[]        @relation("FeedPostChildren")
  Like             Like[]

  library_post_id String?
  stack_id        String?

  @@index([created_at])
  @@index([library_post_id])
  @@index([stack_id])
  @@index([author_id])
  @@map("feed_posts")
}

enum feed_post_type {
  TEXT
  VIDEO
  IMAGE
  LIVESTREAM
  IMAGE_COMPUTE
  COLLAGE
  GALLERY
  PORTAL
  AUDIO
  DRAW
  LIVECHAT
  DOCUMENT
  THREAD
  CODE
  PORTFOLIO
  LLM_INSTRUCTION
  PREDICTION
  PLUGIN
  PRODUCT_REVIEW
  ENTROPY
  MUSIC
  ROOM_CANVAS
  ARTICLE
  LIBRARY
}

model RealtimeLike {
  id               BigInt       @id @default(autoincrement())
  created_at       DateTime     @default(now()) @db.Timestamptz(6)
  score            Int
  type             like_type    @default(LIKE)
  user_id          BigInt
  realtime_post_id BigInt
  updated_at       DateTime?    @default(now()) @updatedAt @db.Timestamptz(6)
  realtime_post    RealtimePost @relation(fields: [realtime_post_id], references: [id], onDelete: Cascade)
  user             User         @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([realtime_post_id, user_id])
  @@map("realtime_likes")
}

model RealtimeRoom {
  id                       String                    @id
  created_at               DateTime                  @default(now()) @db.Timestamptz(6)
  room_icon                String
  isLounge                 Boolean                   @default(false)
  isPublic                 Boolean                   @default(false)
  realtimeedges            RealtimeEdge[]
  realtimeposts            RealtimePost[]
  realtimeRoomInviteTokens RealtimeRoomInviteToken[]
  members                  UserRealtimeRoom[]

  @@map("realtime_rooms")
}

model RealtimePost {
  id                 BigInt             @id @default(autoincrement())
  created_at         DateTime           @default(now()) @db.Timestamptz(6)
  content            String?
  image_url          String?
  video_url          String?
  caption            String?
  author_id          BigInt
  updated_at         DateTime?          @default(now()) @updatedAt @db.Timestamptz(6)
  like_count         Int                @default(0)
  x_coordinate       Decimal
  y_coordinate       Decimal
  type               realtime_post_type @default(TEXT)
  realtime_room_id   String
  locked             Boolean
  collageLayoutStyle String?
  collageColumns     Int?
  collageGap         Int?
  isPublic           Boolean            @default(false)
  parent_id          BigInt?
  expiration_date    DateTime?
  pluginData         Json?
  pluginType         String?
  room_post_content  Json?
  productReview      ProductReview?
  predictionMarket   PredictionMarket?  @relation(fields: [predictionMarketId], references: [id])
  outgoing_edges     RealtimeEdge[]     @relation("RealtimeEdgeToSourceRealtimePost")
  incoming_edges     RealtimeEdge[]     @relation("RealtimeEdgeToTargetRealtimePost")
  likes              RealtimeLike[]
  author             User               @relation(fields: [author_id], references: [id])
  realtimePost       RealtimePost?      @relation("RealtimePostChildren", fields: [parent_id], references: [id], onDelete: Restrict)
  children           RealtimePost[]     @relation("RealtimePostChildren")
  realtimeroom       RealtimeRoom       @relation(fields: [realtime_room_id], references: [id])
  predictionMarketId String?

  @@map("realtime_posts")
}

model RealtimeEdge {
  id               BigInt       @id @default(autoincrement())
  created_at       DateTime     @default(now()) @db.Timestamptz(6)
  updated_at       DateTime?    @default(now()) @updatedAt @db.Timestamptz(6)
  source_node_id   BigInt
  target_node_id   BigInt
  author_id        BigInt
  realtime_room_id String
  author           User         @relation(fields: [author_id], references: [id])
  realtimeroom     RealtimeRoom @relation(fields: [realtime_room_id], references: [id])
  sourceNode       RealtimePost @relation("RealtimeEdgeToSourceRealtimePost", fields: [source_node_id], references: [id])
  targetNode       RealtimePost @relation("RealtimeEdgeToTargetRealtimePost", fields: [target_node_id], references: [id])

  @@unique([source_node_id, target_node_id])
  @@map("realtime_edges")
}

model UserRealtimeRoom {
  id               BigInt       @id @default(autoincrement())
  user_id          BigInt
  realtime_room_id String
  joined_at        DateTime     @default(now()) @db.Timestamptz(6)
  realtime_room    RealtimeRoom @relation(fields: [realtime_room_id], references: [id], onDelete: Cascade)
  user             User         @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([user_id, realtime_room_id])
  @@map("users_realtime_rooms")
}

model RealtimeRoomInviteToken {
  id               BigInt       @id @default(autoincrement())
  token            String       @unique
  created_at       DateTime     @default(now()) @db.Timestamptz(6)
  expiration_date  DateTime?
  realtime_room_id String
  inviting_user_id BigInt
  inviting_user    User         @relation(fields: [inviting_user_id], references: [id], onDelete: Cascade)
  realtime_room    RealtimeRoom @relation(fields: [realtime_room_id], references: [id], onDelete: Cascade)

  @@map("realtime_room_invite_tokens")
}

model Follow {
  id           BigInt   @id @default(autoincrement())
  follower_id  BigInt
  following_id BigInt
  created_at   DateTime @default(now()) @db.Timestamptz(6)
  follower     User     @relation("FollowingRelation", fields: [follower_id], references: [id], onDelete: Cascade)
  following    User     @relation("FollowerRelation", fields: [following_id], references: [id], onDelete: Cascade)

  @@unique([follower_id, following_id])
  @@map("follows")
}

model ArchivedPost {
  id               BigInt    @id @default(autoincrement())
  original_post_id BigInt    @unique
  created_at       DateTime  @db.Timestamptz(6)
  content          String
  author_id        BigInt
  updated_at       DateTime? @db.Timestamptz(6)
  parent_id        BigInt?
  like_count       Int       @default(0)
  expiration_date  DateTime?
  archived_at      DateTime  @default(now()) @db.Timestamptz(6)
  author           User      @relation(fields: [author_id], references: [id])

  @@map("archived_posts")
}

model ArchivedRealtimePost {
  id                 BigInt             @id @default(autoincrement())
  original_post_id   BigInt             @unique
  created_at         DateTime           @db.Timestamptz(6)
  content            String?
  image_url          String?
  video_url          String?
  caption            String?
  author_id          BigInt
  updated_at         DateTime?          @db.Timestamptz(6)
  like_count         Int                @default(0)
  x_coordinate       Decimal
  y_coordinate       Decimal
  type               realtime_post_type @default(TEXT)
  realtime_room_id   String
  locked             Boolean            @default(false)
  collageLayoutStyle String?
  collageColumns     Int?
  collageGap         Int?
  isPublic           Boolean            @default(false)
  pluginType         String?
  pluginData         Json?
  parent_id          BigInt?
  expiration_date    DateTime?
  archived_at        DateTime           @default(now()) @db.Timestamptz(6)
  author             User               @relation(fields: [author_id], references: [id])

  @@map("archived_realtime_posts")
}

model UserEmbedding {
  user_id    BigInt   @id
  embedding  Float[]
  updated_at DateTime @default(now()) @updatedAt @db.Timestamptz(6)
  user       User     @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@map("user_embeddings")
}

model FriendSuggestion {
  id                BigInt   @id @default(autoincrement())
  user_id           BigInt
  suggested_user_id BigInt
  score             Float
  created_at        DateTime @default(now()) @db.Timestamptz(6)
  suggestedUser     User     @relation("SuggestionsTarget", fields: [suggested_user_id], references: [id], onDelete: Cascade)
  user              User     @relation("SuggestionsCreator", fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([user_id, suggested_user_id])
  @@map("friend_suggestions")
}

model Workflow {
  id              BigInt   @id @default(autoincrement())
  owner_id        BigInt
  name            String
  is_active       Boolean  @default(true)
  current_version Int      @default(1)
  created_at      DateTime @default(now()) @db.Timestamptz(6)
  updated_at      DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  versions           WorkflowVersion[]
  runs               WorkflowRun[]
  scheduledWorkflows ScheduledWorkflow[]
  // keep these if you still use the state-machine builder:
  states             WorkflowState[]
  transitions        WorkflowTransition[]

  owner User @relation(fields: [owner_id], references: [id], onDelete: Cascade)

  @@map("workflows")
}

model WorkflowVersion {
  id          BigInt   @id @default(autoincrement())
  workflow_id BigInt
  version     Int
  dsl         Json // { steps: Step[], edges: Edge[] } for the linear builder
  created_at  DateTime @default(now()) @db.Timestamptz(6)
  created_by  BigInt?

  workflow Workflow @relation(fields: [workflow_id], references: [id], onDelete: Cascade)

  @@unique([workflow_id, version])
  @@map("workflow_versions")
}

enum WorkflowRunStatus {
  PENDING
  RUNNING
  SUCCEEDED
  FAILED
  CANCELLED
  PAUSED
}

model WorkflowRun {
  id              BigInt            @id @default(autoincrement())
  workflow_id     BigInt
  version         Int
  status          WorkflowRunStatus @default(PENDING)
  trigger_kind    String? // "cron" | "webhook" | "manual"
  trigger_payload Json?
  started_at      DateTime          @default(now()) @db.Timestamptz(6)
  finished_at     DateTime?         @db.Timestamptz(6)
  error           Json?

  workflow Workflow          @relation(fields: [workflow_id], references: [id], onDelete: Cascade)
  steps    WorkflowRunStep[]

  @@index([workflow_id, started_at])
  @@map("workflow_runs")
}

enum StepStatus {
  PENDING
  RUNNING
  SUCCEEDED
  FAILED
  SKIPPED
}

model WorkflowRunStep {
  id          BigInt     @id @default(autoincrement())
  run_id      BigInt
  step_id     String // DSL Step.id
  action_ref  String?
  status      StepStatus @default(PENDING)
  input       Json?
  output      Json?
  error       Json?
  attempt     Int        @default(0)
  started_at  DateTime?  @db.Timestamptz(6)
  finished_at DateTime?  @db.Timestamptz(6)
  duration_ms Int?

  run WorkflowRun @relation(fields: [run_id], references: [id], onDelete: Cascade)

  @@index([run_id, step_id])
  @@map("workflow_run_steps")
}

model WorkflowState {
  id              BigInt               @id @default(autoincrement())
  workflow_id     BigInt
  version         Int
  graph           Json
  created_at      DateTime             @default(now()) @db.Timestamptz(6)
  updated_at      DateTime?            @default(now()) @updatedAt @db.Timestamptz(6)
  workflow        Workflow             @relation(fields: [workflow_id], references: [id], onDelete: Cascade)
  fromTransitions WorkflowTransition[] @relation("WorkflowTransitionFromState")
  toTransitions   WorkflowTransition[] @relation("WorkflowTransitionToState")

  @@unique([workflow_id, version])
  @@map("workflow_states")
}

model WorkflowTransition {
  id            BigInt        @id @default(autoincrement())
  workflow_id   BigInt
  from_state_id BigInt
  to_state_id   BigInt
  version       Int
  created_at    DateTime      @default(now()) @db.Timestamptz(6)
  fromState     WorkflowState @relation("WorkflowTransitionFromState", fields: [from_state_id], references: [id])
  toState       WorkflowState @relation("WorkflowTransitionToState", fields: [to_state_id], references: [id])
  workflow      Workflow      @relation(fields: [workflow_id], references: [id], onDelete: Cascade)

  @@map("workflow_transitions")
}

model UserAttributeEdit {
  id         BigInt   @id @default(autoincrement())
  user_id    BigInt
  created_at DateTime @default(now()) @db.Timestamptz(6)
  user       User     @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@map("user_attribute_edits")
}

model RecommendationClick {
  id                  BigInt   @id @default(autoincrement())
  user_id             BigInt
  recommended_user_id BigInt?
  recommended_room_id String?
  created_at          DateTime @default(now()) @db.Timestamptz(6)
  user                User     @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@map("recommendation_clicks")
}

model ScheduledWorkflow {
  id          BigInt   @id @default(autoincrement())
  workflow_id BigInt
  cron        String?
  trigger     String? // e.g., "webhook" (plus secret in metadata)
  metadata    Json?
  created_at  DateTime @default(now()) @db.Timestamptz(6)
  updated_at  DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  workflow Workflow @relation(fields: [workflow_id], references: [id], onDelete: Cascade)

  @@map("scheduled_workflows")
}

enum IntegrationStatus {
  CONNECTED
  NEEDS_REAUTH
  REVOKED
}

model Integration {
  id                   BigInt            @id @default(autoincrement())
  user_id              BigInt
  service              String
  external_account_id  String? // e.g. shop domain, gmail address, stripe_account id
  scopes               String[]          @default([]) // least-privilege scope list
  access_token_cipher  Bytes?
  refresh_token_cipher Bytes?
  expires_at           DateTime?         @db.Timestamptz(6)
  status               IntegrationStatus @default(CONNECTED)
  metadata             Json?

  // legacy field during transition (can remove after backfill)
  credential String

  created_at DateTime @default(now()) @db.Timestamptz(6)
  updated_at DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([user_id, service, external_account_id])
  @@index([user_id, service])
  @@map("integrations")
}

model LinkedAccount {
  id            BigInt    @id @default(autoincrement())
  user_id       BigInt
  provider      String
  access_token  String
  refresh_token String
  expires_at    DateTime? @db.Timestamptz(6)
  created_at    DateTime  @default(now()) @db.Timestamptz(6)
  user          User      @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([user_id, provider])
  @@index([user_id])
  @@map("linked_accounts")
}

model ProductReview {
  id               BigInt               @id @default(autoincrement())
  realtime_post_id BigInt?              @unique
  feed_post_id     BigInt?              @unique
  author_id        BigInt
  product_name     String
  rating           Int
  summary          String?
  created_at       DateTime             @default(now()) @db.Timestamptz(6)
  updated_at       DateTime             @default(now()) @updatedAt @db.Timestamptz(6)
  product_link     String?
  image_urls       String[]
  claims           ProductReviewClaim[]
  author           User                 @relation(fields: [author_id], references: [id], onDelete: Cascade)
  realtime_post    RealtimePost?        @relation(fields: [realtime_post_id], references: [id])
  feed_post        FeedPost?            @relation(fields: [feed_post_id], references: [id])

  @@map("product_reviews")
}

model ProductReviewClaim {
  id              BigInt               @id @default(autoincrement())
  review_id       BigInt
  text            String
  created_at      DateTime             @default(now()) @db.Timestamptz(6)
  helpful_count   Int                  @default(0)
  unhelpful_count Int                  @default(0)
  vouch_total     Int                  @default(0)
  review          ProductReview        @relation(fields: [review_id], references: [id], onDelete: Cascade)
  votes           ProductReviewVote[]
  vouches         ProductReviewVouch[]

  @@map("product_review_claims")
}

model ProductReviewVote {
  id         BigInt             @id @default(autoincrement())
  claim_id   BigInt
  user_id    BigInt
  type       String
  created_at DateTime           @default(now()) @db.Timestamptz(6)
  claim      ProductReviewClaim @relation(fields: [claim_id], references: [id], onDelete: Cascade)
  user       User               @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([claim_id, user_id])
  @@map("product_review_votes")
}

model ProductReviewVouch {
  id         BigInt             @id @default(autoincrement())
  claim_id   BigInt
  user_id    BigInt
  amount     Int
  created_at DateTime           @default(now()) @db.Timestamptz(6)
  claim      ProductReviewClaim @relation(fields: [claim_id], references: [id], onDelete: Cascade)
  user       User               @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([claim_id, user_id])
  @@map("product_review_vouches")
}

model Conversation {
  id              BigInt                    @id @default(autoincrement())
  user1_id        BigInt?
  user2_id        BigInt?
  created_at      DateTime                  @default(now()) @db.Timestamptz(6)
  updated_at      DateTime                  @default(now()) @updatedAt @db.Timestamptz(6)
  title           String?
  is_group        Boolean                   @default(false)
  user1           User?                     @relation("ConversationUser1", fields: [user1_id], references: [id])
  user2           User?                     @relation("ConversationUser2", fields: [user2_id], references: [id])
  messages        Message[]
  notifications   Notification[]            @relation("NotificationConversation")
  participants    ConversationParticipant[]
  drifts          Drift[]                   @relation("ConversationDrifts")
  proposalSignals ProposalSignal[]          @relation("ConversationProposalSignals")
  Discussion      Discussion?

  @@unique([user1_id, user2_id])
  @@index([user1_id])
  @@index([user2_id])
  @@map("conversations")
}

model ConversationParticipant {
  id              BigInt       @id @default(autoincrement())
  conversation_id BigInt
  user_id         BigInt
  joined_at       DateTime     @default(now()) @db.Timestamptz(6)
  conversation    Conversation @relation(fields: [conversation_id], references: [id], onDelete: Cascade)
  user            User         @relation(fields: [user_id], references: [id], onDelete: Cascade)
  discussion      Discussion?  @relation(fields: [discussionId], references: [id])
  discussionId    String?

  @@unique([conversation_id, user_id])
  @@index([user_id])
  @@map("conversation_participants")
}

model MessageAttachment {
  id         BigInt   @id @default(autoincrement())
  created_at DateTime @default(now()) @db.Timestamptz(6)
  message_id BigInt
  path       String
  type       String
  size       Int
  metadata   Json?
  message    Message  @relation(fields: [message_id], references: [id], onDelete: Cascade)

  @@index([message_id])
  @@map("message_attachments")
}

model Message {
  id              BigInt              @id @default(autoincrement())
  conversation_id BigInt
  sender_id       BigInt
  text            String?
  created_at      DateTime            @default(now()) @db.Timestamptz(6)
  conversation    Conversation        @relation(fields: [conversation_id], references: [id], onDelete: Cascade)
  sender          User                @relation(fields: [sender_id], references: [id], onDelete: Cascade)
  notifications   Notification[]      @relation("NotificationMessage")
  attachments     MessageAttachment[]

  // moderation / lifecycle
  is_redacted Boolean   @default(false)
  edited_at   DateTime? @db.Timestamptz(6)
  deleted_at  DateTime? @db.Timestamptz(6)
  client_id   String?   @db.VarChar(64)

  // Drifts & Threads
  drift_id        BigInt? // FK column
  reply_to        BigInt?
  reply_count     Int              @default(0)
  last_reply_at   DateTime?
  anchoredDrift   Drift?           @relation("DriftAnchor")
  proposalSignals ProposalSignal[] @relation("MessageProposalSignals")

  // Misc
  meta Json?

  // relations

  reactions        MessageReaction[]
  SheafFacet       SheafFacet[]
  SheafMessageMeta SheafMessageMeta[]

  // ðŸ‘‡ exactly ONE relation field to Drift, named `drift` (or `Drift`, but only once)
  drift          Drift?           @relation("DriftMessages", fields: [drift_id], references: [id])
  MessageMention MessageMention[]

  // Stars & Bookmarks back-relations
  stars     MessageStar[]
  bookmarks Bookmark[]

  // --- GitChat receipts ---
  mergeReceipts MergeReceipt[]

  @@unique([conversation_id, client_id])
  @@index([conversation_id, created_at])
  @@index([drift_id])
  @@index([reply_to])
  @@map("messages")
}

enum DriftKind {
  DRIFT
  THREAD
  PROPOSAL
}

model Drift {
  id                BigInt    @id @default(autoincrement())
  conversation_id   BigInt
  created_by        BigInt
  title             String
  created_at        DateTime  @default(now()) @db.Timestamptz(6)
  updated_at        DateTime  @updatedAt @db.Timestamptz(6)
  is_closed         Boolean   @default(false)
  is_archived       Boolean   @default(false)
  message_count     Int       @default(0)
  last_message_at   DateTime?
  anchor_message_id BigInt?   @unique
  kind              DriftKind @default(DRIFT)
  root_message_id   BigInt? // <â€” root message for kind=THREAD

  // relations
  conversation   Conversation @relation("ConversationDrifts", fields: [conversation_id], references: [id], onDelete: Cascade)
  anchor_message Message?     @relation("DriftAnchor", fields: [anchor_message_id], references: [id], onDelete: Cascade)

  // ðŸ‘‡ inverse side of the relation; MUST use the same name "DriftMessages"
  messages Message[] @relation("DriftMessages")

  members DriftMember[]

  @@unique([conversation_id, root_message_id, kind], map: "uniq_thread_per_root")
  @@index([root_message_id, kind]) // âœ… add this line here
  @@index([conversation_id])
  @@index([root_message_id])
  @@map("drifts")
}

model DriftMember {
  id           BigInt    @id @default(autoincrement())
  drift_id     BigInt
  user_id      BigInt
  joined_at    DateTime  @default(now()) @db.Timestamptz(6)
  collapsed    Boolean   @default(true)
  pinned       Boolean   @default(false)
  muted        Boolean   @default(false)
  last_read_at DateTime?

  drift Drift @relation(fields: [drift_id], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([drift_id, user_id])
  @@index([user_id])
  @@map("drift_members")
}

enum PollKind {
  OPTIONS
  TEMP
}

model Poll {
  id              BigInt    @id @default(autoincrement())
  conversation_id BigInt
  message_id      BigInt
  created_by_id   BigInt
  kind            PollKind
  options         String[]  @default([])
  max_options     Int       @default(1)
  closes_at       DateTime? @db.Timestamptz(6)
  anonymous       Boolean   @default(false)
  created_at      DateTime  @default(now()) @db.Timestamptz(6)

  votes PollVote[]

  @@index([conversation_id])
  @@map("polls")
}

model PollVote {
  id         BigInt   @id @default(autoincrement())
  poll_id    BigInt
  user_id    BigInt
  option_idx Int?
  value      Int?
  created_at DateTime @default(now()) @db.Timestamptz(6)

  poll Poll @relation(fields: [poll_id], references: [id], onDelete: Cascade)

  @@unique([poll_id, user_id])
  @@map("poll_votes")
}

model CanonicalMedia {
  id            String         @id
  title         String
  mediaType     String
  metadata      Json?
  embedding     Float[]
  updatedAt     DateTime       @updatedAt
  favoriteItems FavoriteItem[]

  @@map("canonical_media")
}

model FavoriteItem {
  mediaId String
  rating  Int?
  addedAt DateTime       @default(now())
  userId  BigInt
  media   CanonicalMedia @relation(fields: [mediaId], references: [id], onDelete: Cascade)
  user    User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, mediaId])
  @@index([userId])
  @@map("favorite_items")
}

model Notification {
  id              BigInt            @id @default(autoincrement())
  user_id         BigInt
  actor_id        BigInt
  type            notification_type
  conversation_id BigInt?
  message_id      BigInt?
  market_id       String?
  trade_id        String?
  created_at      DateTime          @default(now()) @db.Timestamptz(6)
  read            Boolean           @default(false)
  actor           User              @relation("NotificationActor", fields: [actor_id], references: [id], onDelete: Cascade)
  conversation    Conversation?     @relation("NotificationConversation", fields: [conversation_id], references: [id], onDelete: Cascade)
  message         Message?          @relation("NotificationMessage", fields: [message_id], references: [id], onDelete: Cascade)
  market          PredictionMarket? @relation("PredictionMarketNotifications", fields: [market_id], references: [id])
  trade           Trade?            @relation("TradeNotifications", fields: [trade_id], references: [id])
  user            User              @relation("NotificationUser", fields: [user_id], references: [id], onDelete: Cascade)

  @@index([user_id])
  @@map("notifications")
}

/// --- Stars & Bookmarks ---
model MessageStar {
  user_id    BigInt
  message_id BigInt
  created_at DateTime @default(now()) @db.Timestamptz(6)

  user    User    @relation(fields: [user_id], references: [id], onDelete: Cascade)
  message Message @relation(fields: [message_id], references: [id], onDelete: Cascade)

  @@id([user_id, message_id])
  @@index([user_id, created_at])
  @@map("message_stars")
}

model Bookmark {
  id         BigInt   @id @default(autoincrement())
  user_id    BigInt
  message_id BigInt
  label      String?
  created_at DateTime @default(now()) @db.Timestamptz(6)

  user    User    @relation(fields: [user_id], references: [id], onDelete: Cascade)
  message Message @relation(fields: [message_id], references: [id], onDelete: Cascade)

  @@unique([user_id, message_id])
  @@index([user_id, created_at])
  @@map("bookmarks")
}

model PortfolioPage {
  id         BigInt   @id @default(autoincrement())
  slug       String   @unique
  html       String
  css        String
  tsx        String? // existing
  payload    Json? // <â€‘â€‘ NEW (optional)
  snapshot   String? // <â€‘â€‘ NEW (optional helper)
  created_at DateTime @default(now()) @db.Timestamptz(6)
  owner_id   BigInt?
  owner      User?    @relation(fields: [owner_id], references: [id], onDelete: Cascade)

  @@index([owner_id, created_at])
  @@map("portfolio_pages")
}

// prisma/schema.prisma
model ProfileSite {
  id        BigInt   @id @default(autoincrement())
  slug      String   @unique
  ownerId   BigInt   @map("owner_id")
  title     String?
  caption   String?
  pageUrl   String   @map("page_url")
  snapshot  String?
  isPublic  Boolean  @default(true) @map("is_public")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("profile_sites")
}

model scroll_events {
  id         BigInt   @id @default(autoincrement())
  user_id    String   @db.Uuid
  content_id String?  @db.Uuid
  dwell_ms   Int
  created_at DateTime @default(now()) @db.Timestamptz(6)

  @@index([user_id], map: "scroll_events_user_idx")
}

model user_taste_vectors {
  user_id    BigInt                @id
  taste      Unsupported("vector")
  traits     Json?                 @default("{}")
  updated_at DateTime              @default(now()) @db.Timestamptz(6)

  @@index([taste], map: "user_taste_vectors_ann")
}

model track_embedding {
  vector    Unsupported("vector")
  createdAt DateTime              @default(now())
  track_id  String                @id

  @@map("track_embedding")
}

model UserSimilarityKnn {
  user_id      BigInt
  neighbour_id BigInt
  sim          Float
  created_at   DateTime @default(now()) @db.Timestamptz(6)

  @@id([user_id, neighbour_id])
  @@map("user_similarity_knn")
}

model PredictionMarket {
  id         String          @id @default(cuid())
  postId     BigInt          @unique
  question   String          @db.VarChar(140)
  closesAt   DateTime
  closedAt   DateTime?
  resolvesAt DateTime?
  state      PredictionState @default(OPEN)
  outcome    MarketOutcome?
  b          Float           @default(100)
  yesPool    Float           @default(0)
  noPool     Float           @default(0)
  creatorId  BigInt
  oracleId   BigInt?

  trades         Trade[]
  notifications  Notification[]  @relation("PredictionMarketNotifications")
  post           FeedPost        @relation("FeedPostPrediction", fields: [postId], references: [id])
  creator        User            @relation("CreatedPredictionMarkets", fields: [creatorId], references: [id])
  oracle         User?           @relation("OraclePredictionMarkets", fields: [oracleId], references: [id])
  RealtimePost   RealtimePost[]
  resolutionLogs ResolutionLog[]

  @@map("prediction_markets")
}

model Trade {
  id        String        @id @default(cuid())
  marketId  String
  userId    BigInt
  side      MarketOutcome
  shares    Float
  price     Float
  cost      Int
  createdAt DateTime      @default(now()) @db.Timestamptz(6)

  market        PredictionMarket @relation(fields: [marketId], references: [id])
  user          User             @relation("UserTrades", fields: [userId], references: [id])
  notifications Notification[]   @relation("TradeNotifications")

  @@index([marketId])
  @@index([userId])
  @@index([marketId, userId], name: "idx_trade_market_user")
  @@map("prediction_trades")
}

model Wallet {
  userId       BigInt @id
  balanceCents Int    @default(0)
  lockedCents  Int    @default(0)

  user User @relation(fields: [userId], references: [id])

  @@map("wallet")
}

model ResolutionLog {
  id         BigInt            @id @default(autoincrement())
  market     PredictionMarket  @relation(fields: [marketId], references: [id])
  marketId   String
  resolver   User              @relation(fields: [resolverId], references: [id])
  resolverId BigInt
  outcome    ResolutionOutcome
  createdAt  DateTime          @default(now())

  @@map("resolution_log")
}

enum ResolutionOutcome {
  YES
  NO
  N_A
}

enum PredictionState {
  OPEN
  CLOSED
  RESOLVED
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Claim Prediction System - Enums
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

enum ClaimPredictionStatus {
  PENDING     // Active, awaiting outcome
  RESOLVED    // Outcome determined
  WITHDRAWN   // Retracted by creator
  EXPIRED     // Target date passed without resolution
}

enum PredictionResolution {
  CONFIRMED       // Prediction came true
  DISCONFIRMED    // Prediction was wrong
  PARTIALLY_TRUE  // Partially accurate
  INDETERMINATE   // Cannot be determined
}

enum EvidenceType {
  OBSERVATION     // Direct observation
  MEASUREMENT     // Quantitative data
  ANNOUNCEMENT    // Official announcement
  NEWS_REPORT     // News coverage
  STUDY           // Research study
  OTHER           // Other type
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Phase 1.1: Academic Claims - Claim Types
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
enum AcademicClaimType {
  THESIS        // The central argument or main claim of a work
  INTERPRETIVE  // A reading or interpretation of text, event, or phenomenon
  HISTORICAL    // A factual claim about past events or conditions
  CONCEPTUAL    // A definition, analysis, or clarification of a concept
  NORMATIVE     // An evaluative or prescriptive claim (what ought to be)
  METHODOLOGICAL // A claim about how to study or analyze something
  COMPARATIVE   // A claim relating or comparing two or more things
  CAUSAL        // A claim about causation or causal mechanisms
  META          // A claim about the field, debate, or scholarship itself
  EMPIRICAL     // A claim based on data, observations, or experiments
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Phase 1.1: Academic Sources - Identifier Types
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
enum SourceIdentifierType {
  DOI
  ISBN
  ARXIV
  PMID
  URL
  MANUAL
}

enum MarketOutcome {
  YES
  NO
}

enum like_type {
  LIKE
  DISLIKE
}

enum realtime_post_type {
  TEXT
  VIDEO
  IMAGE
  LIVESTREAM
  IMAGE_COMPUTE
  COLLAGE
  GALLERY
  PORTAL
  AUDIO
  DRAW
  LIVECHAT
  DOCUMENT
  THREAD
  CODE
  PORTFOLIO
  LLM_INSTRUCTION
  PREDICTION
  PLUGIN
  PRODUCT_REVIEW
  ENTROPY
  MUSIC
  ROOM_CANVAS
}

enum visibility {
  PUBLIC
  FOLLOWERS
  PRIVATE
}

enum notification_type {
  FOLLOW
  MESSAGE
  TRADE_EXECUTED
  MARKET_RESOLVED
}

model Section {
  id           BigInt   @id @default(autoincrement())
  x            Int
  y            Int
  visitors     Int      @default(0)
  liveCount    Int      @default(0)
  auctionCount Int      @default(0)
  created_at   DateTime @default(now()) @db.Timestamptz(6)
  updated_at   DateTime @default(now()) @updatedAt @db.Timestamptz(6)
  stalls       Stall[]

  @@unique([x, y])
  @@map("section") // ðŸ‘ˆ tell Prisma the real table name
}

model Stall {
  id           BigInt         @id @default(autoincrement())
  section_id   BigInt?
  owner_id     BigInt
  name         String
  seller_id    BigInt?
  seller       Seller?        @relation(fields: [seller_id], references: [id])
  created_at   DateTime       @default(now()) @db.Timestamptz(6)
  updated_at   DateTime       @default(now()) @updatedAt @db.Timestamptz(6)
  section      Section?       @relation(fields: [section_id], references: [id])
  owner        User           @relation(fields: [owner_id], references: [id])
  items        Item[]
  auctions     Auction[]
  orders       Order[]
  images       StallImage[]
  StallMessage StallMessage[]
  live         Boolean        @default(false)
  liveSrc      String? // nullable -> no stream yet
  doc          Json?
  Offer        Offer[]

  @@unique([section_id, owner_id])
  @@index([section_id])
  @@index([owner_id, updated_at])
  @@map("stalls")
}

model StallImage {
  id         BigInt   @id @default(autoincrement())
  stall_id   BigInt
  url        String
  blurhash   String?
  created_at DateTime @default(now()) @db.Timestamptz(6)
  position   Int      @default(0)
  stall      Stall    @relation(fields: [stall_id], references: [id])

  @@index([stall_id, position])
  @@map("stall_image")
}

// ---------- ITEM ----------
model Item {
  id          BigInt   @id @default(autoincrement())
  stall_id    BigInt
  name        String
  description String
  price       Decimal? @db.Decimal(12, 2)
  currency    String   @default("usd")
  stock       Int
  images      String[] // PG array
  created_at  DateTime @default(now()) @db.Timestamptz(6)

  stall      Stall       @relation(fields: [stall_id], references: [id])
  offers     Offer[]
  auction    Auction?
  orderItems OrderItem[]
  cartItems  CartItem[]
  OrderLine  OrderLine[]

  @@index([stall_id])
  @@map("items")
}

model Seller {
  id                   BigInt  @id @default(autoincrement()) // <-- give Seller the ids
  stripeAccountId      String? @unique
  stripeChargesEnabled Boolean @default(false)
  stalls               Stall[]
  Offer                Offer[]
}

// ---------- OFFER ----------
model Offer {
  id            BigInt      @id @default(autoincrement())
  stall_id      BigInt
  item_id       BigInt?
  buyer_id      BigInt
  seller_id     BigInt
  amount        Decimal     @db.Decimal(12, 2)
  currency      String      @default("usd")
  status        OfferStatus @default(PENDING)
  counter_of_id BigInt?
  expires_at    DateTime?
  version       Int         @default(1)
  message       String?
  created_at    DateTime    @default(now()) @db.Timestamptz(6)
  updated_at    DateTime    @default(now()) @updatedAt @db.Timestamptz(6)

  stall  Stall  @relation(fields: [stall_id], references: [id])
  item   Item?  @relation(fields: [item_id], references: [id])
  buyer  User   @relation(fields: [buyer_id], references: [id])
  seller Seller @relation(fields: [seller_id], references: [id])

  counterOf Offer?  @relation("OfferCounters", fields: [counter_of_id], references: [id])
  counters  Offer[] @relation("OfferCounters")

  // reservation for checkout
  cart       Cart?        @relation("CartOffer")
  OfferEvent OfferEvent[]

  @@index([stall_id, status])
  @@index([buyer_id, status])
  @@index([item_id, status])
  @@map("offers")
}

enum OfferEventKind {
  CREATED
  COUNTERED
  ACCEPTED
  REJECTED
  EXPIRED
}

model OfferEvent {
  id         BigInt         @id @default(autoincrement())
  offer_id   BigInt
  kind       OfferEventKind
  payload    Json?
  created_at DateTime       @default(now()) @db.Timestamptz(6)

  offer Offer @relation(fields: [offer_id], references: [id])

  @@index([offer_id])
  @@map("offer_events")
}

// ---------- AUCTION / BID ----------
model Auction {
  id         BigInt        @id @default(autoincrement())
  item_id    BigInt        @unique
  stall_id   BigInt
  reserve    Decimal       @db.Decimal(12, 2)
  currency   String        @default("usd")
  ends_at    DateTime
  state      auction_state @default(LIVE)
  winner_id  BigInt?
  created_at DateTime      @default(now()) @db.Timestamptz(6)

  item   Item    @relation(fields: [item_id], references: [id])
  stall  Stall   @relation(fields: [stall_id], references: [id])
  winner User?   @relation(fields: [winner_id], references: [id])
  bids   Bid[]
  Order  Order[]

  @@index([stall_id])
  @@index([ends_at, state])
  @@map("auctions")
}

model Bid {
  id         BigInt   @id @default(autoincrement())
  auction_id BigInt
  bidder_id  BigInt
  amount     Decimal  @db.Decimal(12, 2)
  created_at DateTime @default(now()) @db.Timestamptz(6)

  auction Auction @relation(fields: [auction_id], references: [id])
  bidder  User    @relation(fields: [bidder_id], references: [id])

  @@index([auction_id, created_at])
  @@map("bids")
}

enum OfferStatus {
  PENDING
  ACCEPTED
  REJECTED
  EXPIRED
}

enum OrderStatus {
  PENDING_PAYMENT
  AUTHORIZED
  PAID
  FULFILLED
  RELEASED
  DISPUTED
  REFUNDED
  CANCELLED
}

// ---------- ORDERS / CART / ESCROW ----------
model Order {
  id           BigInt      @id @default(autoincrement())
  stall_id     BigInt
  buyer_id     BigInt?
  auction_id   BigInt?
  status       OrderStatus @default(PENDING_PAYMENT)
  subtotal     Decimal?    @db.Decimal(12, 2)
  shipping     Decimal?    @db.Decimal(12, 2)
  total        Decimal?    @db.Decimal(12, 2)
  currency     String      @default("usd")
  stripePI     String?
  pmId         String?
  fulfilled_at DateTime?
  released_at  DateTime?
  hold_days    Int         @default(3)
  created_at   DateTime    @default(now()) @db.Timestamptz(6)
  updated_at   DateTime    @default(now()) @updatedAt @db.Timestamptz(6)

  stall   Stall    @relation(fields: [stall_id], references: [id])
  buyer   User?    @relation(fields: [buyer_id], references: [id])
  auction Auction? @relation(fields: [auction_id], references: [id])

  items     OrderItem[]
  OrderLine OrderLine[]

  @@index([stall_id, status])
  @@map("orders")
}

model OrderItem {
  id         BigInt   @id @default(autoincrement())
  order_id   BigInt
  item_id    BigInt
  qty        Int
  unit_price Decimal? @db.Decimal(12, 2) // TEMP: nullable if you just added it
  created_at DateTime @default(now()) @db.Timestamptz(6)

  order Order @relation(fields: [order_id], references: [id])
  item  Item  @relation(fields: [item_id], references: [id])

  @@index([order_id])
  @@map("order_items")
}

model OrderLine {
  id          BigInt   @id @default(autoincrement())
  order_id    BigInt?
  item_id     BigInt?
  quantity    Int?
  price_cents Int?
  created_at  DateTime @default(now()) @db.Timestamptz(6)
  order       Order?   @relation(fields: [order_id], references: [id])
  item        Item?    @relation(fields: [item_id], references: [id])

  @@index([order_id])
  @@map("order_lines")
}

model StallMessage {
  id         BigInt   @id @default(autoincrement())
  stall_id   BigInt
  user_id    BigInt
  text       String
  created_at DateTime @default(now()) @db.Timestamptz(6)

  stall Stall @relation(fields: [stall_id], references: [id])
  user  User  @relation(fields: [user_id], references: [id])

  @@index([stall_id])
  @@map("stall_messages")
}

model CartItem {
  id         BigInt   @id @default(autoincrement())
  user_id    BigInt
  item_id    BigInt
  qty        Int      @default(1)
  created_at DateTime @default(now()) @db.Timestamptz(6)

  user User @relation(fields: [user_id], references: [id])
  item Item @relation(fields: [item_id], references: [id])

  @@unique([user_id, item_id])
  @@map("cart_items")
}

enum escrow_state {
  PENDING
  HELD
  RELEASED
  REFUNDED
}

// Offer reservation (one-per-offer)
model Cart {
  id         BigInt   @id @default(autoincrement())
  user_id    BigInt
  offer_id   BigInt   @unique
  deadline   DateTime @db.Timestamptz(6)
  created_at DateTime @default(now()) @db.Timestamptz(6)

  offer  Offer   @relation("CartOffer", fields: [offer_id], references: [id])
  user   User    @relation(fields: [user_id], references: [id])
  escrow Escrow? @relation("CartEscrow")

  @@index([user_id])
  @@map("cart")
}

model Escrow {
  id         BigInt       @id @default(autoincrement())
  cart_id    BigInt       @unique
  state      escrow_state @default(PENDING)
  tx_ref     String?
  created_at DateTime     @default(now()) @db.Timestamptz(6)
  updated_at DateTime     @default(now()) @updatedAt @db.Timestamptz(6)

  cart Cart @relation("CartEscrow", fields: [cart_id], references: [id])

  @@map("escrow")
}

model PartyPresence {
  id         String   @id @default(cuid())
  party_id   String
  user_id    BigInt
  x          Int
  y          Int
  updated_at DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([party_id])
  @@map("party_presence")
}

model StallHeat {
  id       BigInt @id @default(autoincrement())
  stall_id BigInt
  cell     Int
  views    Int

  @@unique([stall_id, cell], name: "stall_id_cell")
  @@map("stall_heat")
}

model GroupMeeting {
  id              String   @id @default(uuid())
  title           String?
  participantUids String[]
  origins         Json?
  votes           Json?
  status          String   @default("init")
  createdAt       DateTime @default(now())

  @@map("group_meetings")
}

model UserSettings {
  user_id    BigInt   @id
  prefs      Json     @default("{}")
  updated_at DateTime @updatedAt

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@map("user_settings")
}

model WorkspaceSettings {
  workspace_id BigInt   @id
  prefs        Json     @default("{}")
  updated_at   DateTime @updatedAt

  @@map("workspace_settings")
}

model Telemetry {
  id        BigInt   @id @default(autoincrement())
  event     String
  coords    String
  userId    BigInt?
  createdAt DateTime @default(now()) @db.Timestamptz(6)

  @@index([event, createdAt])
}

enum auction_state {
  LIVE
  CLOSED
}

enum ArticleStatus {
  DRAFT
  PUBLISHED
}

// ============================================================
// Block Type Enums (Phase 1.2)
// ============================================================

enum BlockType {
  pdf
  link
  text
  image
  video
  dataset
  embed     // Future: embedded content (tweets, etc.)
}

enum BlockProcessingStatus {
  pending     // Awaiting processing
  processing  // Currently being processed
  completed   // Successfully processed
  failed      // Processing failed
  skipped     // No processing needed
}

model LibraryPost {
  id          String   @id @default(cuid())
  uploader_id BigInt
  stack_id    String?  // DEPRECATED: Use stackConnections via StackItem for multi-stack support
  title       String?
  page_count  Int      @default(0)
  file_url    String?  // Made nullable for non-PDF blocks
  thumb_urls  String[]
  created_at  DateTime @default(now()) @db.Timestamptz(6)
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Block type discriminator (Phase 1.2)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  blockType   BlockType @default(pdf)
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Link block fields
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  linkUrl         String?   // Original URL
  linkCanonical   String?   // Resolved canonical URL
  linkTitle       String?   // OG title / page title
  linkDescription String?   // OG description / meta description
  linkImage       String?   // OG image URL
  linkFavicon     String?   // Site favicon
  linkSiteName    String?   // OG site_name
  linkReadableText String?  // Extracted readable content (for search)
  linkScreenshot  String?   // Screenshot URL (stored in CDN)
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Text block fields
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  textContent     String?   // Markdown content
  textPlain       String?   // Plain text version (for search)
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Image block fields
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  imageUrl        String?   // Image file URL
  imageAlt        String?   // Alt text
  imageWidth      Int?
  imageHeight     Int?
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Video block fields
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  videoUrl        String?   // Video URL (YouTube, Vimeo, etc.)
  videoProvider   String?   // 'youtube' | 'vimeo' | 'direct'
  videoEmbedId    String?   // Provider-specific ID
  videoDuration   Int?      // Duration in seconds
  videoThumb      String?   // Thumbnail URL
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Processing status
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  processingStatus BlockProcessingStatus @default(completed)
  processingError  String?
  processedAt      DateTime?

  annotations      Annotation[]
  stack            Stack?       @relation(fields: [stack_id], references: [id])
  uploader         User         @relation(fields: [uploader_id], references: [id], onDelete: Cascade)
  feedPosts        FeedPost[]
  
  // NEW: All stacks this block is connected to (via StackItem join table)
  stackConnections StackItem[]  @relation("BlockConnections")

  @@index([uploader_id, created_at])
  @@index([stack_id])
  @@index([blockType])
  @@index([processingStatus])
  @@map("library_posts")
}

model Stack {
  id             String              @id @default(cuid())
  owner_id       BigInt
  name           String
  description    String?
  is_public      Boolean             @default(false) // DEPRECATED: Use visibility instead
  visibility     StackVisibility     @default(public_closed)
  order          String[]            // DEPRECATED: Will be removed after StackItem migration complete
  created_at     DateTime            @default(now()) @db.Timestamptz(6)
  parent_id      String?
  slug           String?             @unique
  owner          User                @relation(fields: [owner_id], references: [id], onDelete: Cascade)
  posts          LibraryPost[]
  parent         Stack?              @relation("StackHierarchy", fields: [parent_id], references: [id])
  children       Stack[]             @relation("StackHierarchy")
  feedPosts      FeedPost[]
  collaborators  StackCollaborator[]
  subscribers    StackSubscription[]
  StackReference StackReference[]
  
  // NEW: StackItem relations for multi-stack connections
  items          StackItem[]         @relation("StackItems")
  embeddedIn     StackItem[]         @relation("EmbeddedIn")

  // Phase 3.2: Reference manager default target
  refManagerDefaults ReferenceManagerConnection[]

  @@unique([owner_id, name])
  @@index([visibility])
  @@map("stacks")
}

// Stack visibility modes (Phase 1.5)
enum StackVisibility {
  public_open    // Anyone can view + add blocks
  public_closed  // Anyone can view; only owner/collaborators can add
  private        // Only owner/collaborators can view and add
  unlisted       // Link access only; not in search/discovery
}

// Citation anchor types (Phase 2.1)
enum CitationAnchorType {
  annotation     // PDF highlight â†’ links to Annotation record
  text_range     // Web capture text selection â†’ anchorData has range
  timestamp      // Video/audio â†’ anchorData has {start, end} seconds
  page           // Page-level reference (no specific selection)
  coordinates    // Image region â†’ anchorData has {x, y, width, height}
}

// Citation intent types (Phase 2.3) - semantic relationship to target
enum CitationIntent {
  supports      // Evidence in favor of the claim
  refutes       // Evidence against the claim
  context       // Background/contextual information
  defines       // Defines a key term
  method        // Describes methodology
  background    // General background reading
  acknowledges  // Acknowledges opposing view without refuting
  example       // Provides an example/case study
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Phase 3.1: Source Trust Infrastructure Enums
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

enum SourceVerificationStatus {
  unverified    // Never checked
  verified      // URL resolves, content accessible
  redirected    // URL redirects (canonicalUrl differs)
  unavailable   // Temporarily unavailable (4xx/5xx)
  broken        // Permanently broken (multiple failures)
  paywalled     // Accessible but behind paywall
}

enum EnrichmentStatus {
  pending       // Not yet enriched
  enriched      // Successfully enriched from external DB
  partial       // Some fields enriched
  not_found     // Not found in external DBs
  failed        // Enrichment failed
}

enum ArchiveStatus {
  none          // No archive requested
  pending       // Archive request submitted
  in_progress   // Archiving in progress
  archived      // Successfully archived
  failed        // Archive failed
  exists        // Already archived (found existing)
}

enum RetractionStatus {
  none                    // No retraction
  retracted               // Fully retracted
  expression_of_concern   // Expression of concern issued
  partial_retraction      // Partial retraction
}

enum CorrectionStatus {
  none              // No corrections
  minor_correction  // Minor correction (typos, formatting)
  major_correction  // Major correction (data, methodology)
  erratum           // Formal erratum published
}

enum SourceAlertType {
  retraction
  expression_of_concern
  major_correction
  link_broken
  content_changed
}

enum StackRole {
  OWNER
  EDITOR
  VIEWER
}

model StackCollaborator {
  stack_id   String
  user_id    BigInt
  role       StackRole @default(EDITOR)
  created_at DateTime  @default(now()) @db.Timestamptz(6)

  stack Stack @relation(fields: [stack_id], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@id([stack_id, user_id])
  @@index([user_id])
  @@index([stack_id])
  @@map("stack_collaborators")
}

model StackSubscription {
  stack_id   String
  user_id    BigInt
  created_at DateTime @default(now()) @db.Timestamptz(6)

  stack Stack @relation(fields: [stack_id], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@id([stack_id, user_id])
  @@index([user_id])
  @@index([stack_id])
  @@map("stack_subscriptions")
}

// ============================================================
// StackItem: Join table enabling many-to-many Stack â†” Block relationships
// Phase 1.1 of Stacks Improvement Roadmap
// ============================================================

enum StackItemKind {
  block       // LibraryPost reference
  stack_embed // Embedded stack reference
}

model StackItem {
  id           String        @id @default(cuid())
  stackId      String
  
  // Polymorphic reference: either a block OR an embedded stack
  blockId      String?       // LibraryPost.id (null if kind=stack_embed)
  embedStackId String?       // Stack.id for embedded stacks (null if kind=block)
  
  kind         StackItemKind @default(block)
  position     Float         // Float enables cheap insertion (avg of neighbors)
  addedById    BigInt        // Who connected this
  note         String?       // Optional "why I added this" annotation
  createdAt    DateTime      @default(now()) @db.Timestamptz(6)
  updatedAt    DateTime      @updatedAt

  // Relations
  stack        Stack         @relation("StackItems", fields: [stackId], references: [id], onDelete: Cascade)
  block        LibraryPost?  @relation("BlockConnections", fields: [blockId], references: [id], onDelete: Cascade)
  embedStack   Stack?        @relation("EmbeddedIn", fields: [embedStackId], references: [id], onDelete: Cascade)
  addedBy      User          @relation(fields: [addedById], references: [id])

  @@unique([stackId, blockId])           // One block can only appear once per stack
  @@unique([stackId, embedStackId])      // One embedded stack only once per parent
  @@index([stackId, position])           // Fast ordered retrieval
  @@index([blockId])                     // Fast "contexts" lookup
  @@index([embedStackId])
  @@index([addedById])
  @@map("stack_items")
}

model Source {
  id            String    @id @default(cuid())
  kind          String // 'article' | 'book' | 'web' | 'dataset' | 'video' | 'other'
  title         String?
  authorsJson   Json? // [{family, given}] CSL-esque
  year          Int?
  container     String? // journal / site / channel
  publisher     String?
  volume        String?
  issue         String?
  pages         String?
  doi           String?   @unique
  url           String?   @unique
  platform      String? // 'arxiv' | 'substack' | 'twitter' | 'youtube' | ...
  accessedAt    DateTime?
  archiveUrl    String? // Wayback/perma.cc if available
  zoteroKey     String? // optional cross-ref key
  libraryPostId String? // link to your LibraryPost (Stack) row
  fingerprint   String? // sha1 of canonicalized url/doi/title to dedup
  createdById   String
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Phase 3.1: Verification Fields
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  verificationStatus SourceVerificationStatus @default(unverified)
  verifiedAt         DateTime?
  lastCheckedAt      DateTime?
  canonicalUrl       String?   // Final URL after redirects
  httpStatus         Int?      // Last HTTP status code
  httpStatusHistory  Json?     // [{status, checkedAt}, ...]
  contentHash        String?   // Hash of page content/PDF for change detection
  contentChangedAt   DateTime?

  // Metadata enrichment status
  enrichmentStatus   EnrichmentStatus @default(pending)
  enrichedAt         DateTime?
  enrichmentSource   String?   // "crossref", "semantic_scholar", "openalex"

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Phase 3.1: Archiving Fields
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  archiveStatus       ArchiveStatus @default(none)
  archiveRequestedAt  DateTime?
  archivedAt          DateTime?
  archiveError        String?
  localArchivePath    String?   // S3 path to captured PDF
  localArchiveSize    Int?      // File size in bytes

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Phase 3.1: Retraction/Correction Tracking
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  retractionStatus    RetractionStatus @default(none)
  retractionCheckedAt DateTime?
  retractionNoticeUrl String?
  retractionReason    String?
  retractionDate      DateTime?

  correctionStatus    CorrectionStatus @default(none)
  correctionUrl       String?
  correctionDate      DateTime?
  correctionSummary   String?

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Phase 1.1: Academic Paper-to-Claim Pipeline Fields
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  identifierType  SourceIdentifierType?   // DOI, ISBN, ARXIV, etc.
  openAlexId      String?                 // OpenAlex work ID for enrichment
  authorOrcids    String[]                // ORCID IDs for authors
  abstractText    String?   @db.Text      // Full abstract text
  keywords        String[]                // Subject keywords
  pdfUrl          String?                 // Direct PDF URL if available
  pdfHash         String?                 // SHA256 hash for deduplication

  // Relations
  citations       Citation[]
  ratings         SourceRating[]
  alerts          SourceAlert[]
  refManagerItems ReferenceManagerItem[]
  claims          Claim[]                 // Phase 1.1: Claims extracted from this source
  quotes          QuoteNode[]             // Phase 2.3: Quote nodes from this source

  @@index([verificationStatus])
  @@index([lastCheckedAt])
  @@index([archiveStatus])
  @@index([retractionStatus])
  @@index([openAlexId])
}

model Citation {
  id          String   @id @default(cuid())
  targetType  String // 'argument' | 'claim' | 'card' | 'comment' | 'move'
  targetId    String
  sourceId    String
  locator     String? // 'p. 13', 'fig. 2', timestamp '08:14', etc.
  quote       String? // short excerpt (<= 280 chars)
  note        String? // optional note / why relevant
  relevance   Int? // 1..5 quick signal
  createdById String
  createdAt   DateTime @default(now())

  // Anchor fields for executable references (Phase 2.1)
  anchorType  CitationAnchorType?
  anchorId    String?   // Reference to Annotation.id or other anchor entity
  anchorData  Json?     // Flexible anchor data (coordinates, ranges, etc.)

  // Semantic intent (Phase 2.3) - optional, null means unspecified
  intent      CitationIntent?

  source     Source      @relation(fields: [sourceId], references: [id])
  annotation Annotation? @relation(fields: [anchorId], references: [id], onDelete: SetNull)

  @@unique([targetType, targetId, sourceId, locator]) // prevents dup cites
  @@index([anchorId])
  @@index([intent])
}

model SourceRating {
  id        String   @id @default(cuid())
  sourceId  String
  userId    BigInt   // Changed to BigInt to match User.id
  rating    Int // 1-10 scale for source quality
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  source Source @relation(fields: [sourceId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([sourceId, userId]) // One rating per user per source
  @@index([sourceId])
  @@index([userId])
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Phase 3.1: Source Alerts (retraction, broken links, etc.)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

model SourceAlert {
  id          String          @id @default(cuid())
  sourceId    String
  alertType   SourceAlertType
  message     String
  metadata    Json?           // Additional alert-specific data
  createdAt   DateTime        @default(now())

  source        Source                    @relation(fields: [sourceId], references: [id], onDelete: Cascade)
  notifications SourceAlertNotification[]

  @@index([sourceId])
  @@index([alertType])
}

model SourceAlertNotification {
  id          String    @id @default(cuid())
  alertId     String
  userId      BigInt
  seenAt      DateTime?
  dismissedAt DateTime?
  createdAt   DateTime  @default(now())

  alert SourceAlert @relation(fields: [alertId], references: [id], onDelete: Cascade)
  user  User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([alertId, userId])
  @@index([userId])
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Phase 2.3: Quote Nodes & Interpretations
// First-class addressable quote objects for HSS scholarly work
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

enum LocatorType {
  PAGE          // p. 42
  SECTION       // Â§3.2
  CHAPTER       // Ch. 5
  VERSE         // 3:16
  TIMESTAMP     // 01:23:45
  LINE          // line 123
  PARAGRAPH     // Â¶12
  CUSTOM        // User-defined
}

enum QuoteUsageType {
  EVIDENCE      // Quote supports the claim/argument
  COUNTER       // Quote challenges the claim/argument
  CONTEXT       // Quote provides background
  DEFINITION    // Quote defines a key term
  METHODOLOGY   // Quote describes method
}

model QuoteNode {
  id              String      @id @default(cuid())
  
  // Source reference
  sourceId        String
  source          Source      @relation(fields: [sourceId], references: [id])
  
  // Quote content
  text            String      @db.Text
  locator         String?     // Page number, section, timestamp, verse
  locatorType     LocatorType @default(PAGE)
  context         String?     @db.Text  // Surrounding text for context
  
  // Metadata
  language        String?     @default("en")
  isTranslation   Boolean     @default(false)
  originalQuoteId String?     // Link to original language quote
  originalQuote   QuoteNode?  @relation("QuoteTranslations", fields: [originalQuoteId], references: [id])
  translations    QuoteNode[] @relation("QuoteTranslations")
  
  // Interpretations
  interpretations QuoteInterpretation[]
  
  // Usage tracking
  usedInClaims    ClaimQuote[]
  usedInArguments ArgumentQuote[]
  
  // Mini-deliberation for discussing the quote
  deliberationId  String?     @unique
  deliberation    Deliberation? @relation("QuoteDeliberation", fields: [deliberationId], references: [id])
  
  // Ownership
  createdById     String
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  
  @@index([sourceId])
  @@index([createdById])
  // Note: PostgreSQL doesn't support @@fulltext, use raw SQL for text search
}

model QuoteInterpretation {
  id              String      @id @default(cuid())
  quoteId         String
  quote           QuoteNode   @relation(fields: [quoteId], references: [id], onDelete: Cascade)
  
  // The interpretation
  interpretation  String      @db.Text  // "This passage means..."
  framework       String?     // Theoretical framework (e.g., "Marxist", "Poststructuralist")
  methodology     String?     // Interpretive method used
  
  // Community engagement
  votes           InterpretationVote[]
  voteScore       Int         @default(0)
  
  // Relations to other interpretations
  supportsId      String?
  supports        QuoteInterpretation? @relation("InterpretationSupport", fields: [supportsId], references: [id])
  supportedBy     QuoteInterpretation[] @relation("InterpretationSupport")
  
  challengesId    String?
  challenges      QuoteInterpretation? @relation("InterpretationChallenge", fields: [challengesId], references: [id])
  challengedBy    QuoteInterpretation[] @relation("InterpretationChallenge")
  
  // Authorship
  authorId        String
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  
  @@index([quoteId])
  @@index([authorId])
  @@index([voteScore])
}

model InterpretationVote {
  id                  String              @id @default(cuid())
  interpretationId    String
  interpretation      QuoteInterpretation @relation(fields: [interpretationId], references: [id], onDelete: Cascade)
  
  userId              String
  vote                Int                 // +1 or -1
  createdAt           DateTime            @default(now())
  
  @@unique([interpretationId, userId])
  @@index([userId])
}

// Junction table: Quote usage in Claims
model ClaimQuote {
  id              String          @id @default(cuid())
  claimId         String
  claim           Claim           @relation(fields: [claimId], references: [id], onDelete: Cascade)
  
  quoteId         String
  quote           QuoteNode       @relation(fields: [quoteId], references: [id], onDelete: Cascade)
  
  usageType       QuoteUsageType  @default(EVIDENCE)
  usageNote       String?         @db.Text  // Why this quote is being used
  
  addedById       String
  addedAt         DateTime        @default(now())
  
  @@unique([claimId, quoteId])
  @@index([claimId])
  @@index([quoteId])
}

// Junction table: Quote usage in Arguments
model ArgumentQuote {
  id              String          @id @default(cuid())
  argumentId      String
  argument        Argument        @relation(fields: [argumentId], references: [id], onDelete: Cascade)
  
  quoteId         String
  quote           QuoteNode       @relation(fields: [quoteId], references: [id], onDelete: Cascade)
  
  usageType       QuoteUsageType  @default(EVIDENCE)
  premiseIndex    Int?            // Which premise this supports (0-indexed)
  usageNote       String?         @db.Text
  
  addedById       String
  addedAt         DateTime        @default(now())
  
  @@unique([argumentId, quoteId])
  @@index([argumentId])
  @@index([quoteId])
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Phase 3.2: Reference Manager Integration
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

enum ReferenceManagerProvider {
  zotero
  mendeley
}

enum SyncDirection {
  import_only  // Only import from reference manager to Mesh
  export_only  // Only export from Mesh to reference manager
  bidirectional // Two-way sync
}

enum SyncStatus {
  pending
  syncing
  synced
  error
}

model ReferenceManagerConnection {
  id               String                    @id @default(cuid())
  userId           BigInt
  provider         ReferenceManagerProvider
  
  // OAuth / API credentials (encrypted)
  accessToken      String?
  refreshToken     String?
  tokenExpiresAt   DateTime?
  apiKey           String?                   // For Zotero API key auth
  
  // User identifier in external system
  externalUserId   String?
  externalUsername String?
  
  // Sync configuration
  syncDirection    SyncDirection             @default(bidirectional)
  autoSync         Boolean                   @default(false)
  syncIntervalMins Int                       @default(60)
  
  // Library/collection targeting
  libraryType      String?                   // "user" or "group"
  libraryId        String?                   // Zotero library ID
  collectionId     String?                   // Optional: sync specific collection only
  
  // Default target for imported items
  defaultStackId   String?
  
  // Sync state
  lastSyncAt       DateTime?
  lastSyncStatus   SyncStatus                @default(pending)
  lastSyncError    String?
  lastLibraryVersion Int?                    // Zotero library version for incremental sync
  
  createdAt        DateTime                  @default(now())
  updatedAt        DateTime                  @updatedAt

  user         User                     @relation(fields: [userId], references: [id], onDelete: Cascade)
  defaultStack Stack?                   @relation(fields: [defaultStackId], references: [id], onDelete: SetNull)
  items        ReferenceManagerItem[]

  @@unique([userId, provider])
  @@index([provider])
}

model ReferenceManagerItem {
  id              String    @id @default(cuid())
  connectionId    String
  sourceId        String
  
  // External reference
  externalId      String    // Item key in reference manager
  externalVersion Int?      // Version number for conflict detection
  externalParentId String?  // Parent item key (for attachments, notes)
  
  // Sync tracking
  lastSyncedAt    DateTime?
  localModifiedAt DateTime? // When local copy was modified
  remoteModifiedAt DateTime? // When remote copy was modified
  syncStatus      SyncStatus @default(pending)
  syncError       String?
  
  // Conflict resolution
  hasConflict     Boolean   @default(false)
  conflictData    Json?     // Store both versions for manual resolution
  
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  connection ReferenceManagerConnection @relation(fields: [connectionId], references: [id], onDelete: Cascade)
  source     Source                     @relation(fields: [sourceId], references: [id], onDelete: Cascade)

  @@unique([connectionId, externalId])
  @@unique([connectionId, sourceId])
  @@index([sourceId])
  @@index([syncStatus])
}

model Annotation {
  id         String   @id @default(cuid())
  post_id    String
  page       Int
  rect       Json
  text       String
  author_id  BigInt
  created_at DateTime @default(now()) @db.Timestamptz(6)

  post      LibraryPost @relation(fields: [post_id], references: [id], onDelete: Cascade)
  author    User        @relation(fields: [author_id], references: [id])
  citations Citation[]  // Citations that reference this annotation (Phase 2.1)

  @@index([post_id])
  @@map("annotations")
}

model CommentThread {
  id        String    @id @default(cuid())
  articleId String
  article   Article   @relation(fields: [articleId], references: [id], onDelete: Cascade)
  anchor    Json // { startPath, startOffset, endPath, endOffset }
  resolved  Boolean   @default(false)
  createdBy String
  createdAt DateTime  @default(now())
  comments  Comment[]

  @@index([articleId])
}

model Comment {
  id        String        @id @default(cuid())
  threadId  String
  thread    CommentThread @relation(fields: [threadId], references: [id], onDelete: Cascade)
  body      String
  createdBy String
  createdAt DateTime      @default(now())
  upvotes   Int           @default(0)
  downvotes Int           @default(0)

  @@index([threadId])
}

model Article {
  id           String        @id @default(uuid())
  authorId     String
  title        String
  slug         String        @unique
  heroImageKey String?
  template     String        @default("standard")
  astJson      Json
  status       ArticleStatus @default(DRAFT)
  revisions    Revision[]
  analytics    Json?
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  excerpt      String?
  readingTime  Int? // minutes
  publishedAt  DateTime? // set on publish

  allowAnnotations Boolean         @default(true)
  revisionId       String?
  threads          CommentThread[]
  deletedAt        DateTime?

  @@index([authorId, deletedAt, updatedAt])
  @@index([authorId, status, updatedAt])
  @@map("articles")
}

model Revision {
  id        String   @id @default(uuid())
  articleId String
  astJson   Json
  createdAt DateTime @default(now())

  article Article @relation(fields: [articleId], references: [id], onDelete: Cascade)

  @@map("article_revisions")
}

/// ---------- SHEAF (facets layered on existing Message) ----------
model SheafFacet {
  id        BigInt  @id @default(autoincrement())
  messageId BigInt
  message   Message @relation(fields: [messageId], references: [id])

  audienceKind      AudienceKind
  audienceMode      AudienceMode
  audienceRole      String?
  audienceListId    String?
  snapshotMemberIds String[]
  listVersionAtSend Int?
  audienceUserIds   String[]

  sharePolicy SharePolicy
  expiresAt   DateTime?
  createdAt   DateTime    @default(now()) @db.Timestamptz(6)
  updatedAt   DateTime    @updatedAt

  body Json

  priorityRank  Int     @default(0)
  visibilityKey String?

  // âœ… opposite side of the relation:
  attachments      SheafAttachment[]
  SheafMessageMeta SheafMessageMeta[]

  reactions      MessageReaction[]
  MessageMention MessageMention[]
  LinkPreview    LinkPreview[]

  @@index([messageId])
  @@index([audienceKind, audienceMode])
  @@index([audienceRole])
  @@index([audienceListId])
  @@index([priorityRank, createdAt])
  @@map("sheaf_facets")
}

model SheafMessageMeta {
  // 1:1 with Message; keeps default facet without touching your Message shape
  messageId      BigInt      @id
  message        Message     @relation(fields: [messageId], references: [id], onDelete: Cascade)
  defaultFacetId BigInt?
  defaultFacet   SheafFacet? @relation(fields: [defaultFacetId], references: [id])

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@map("sheaf_message_meta")
}

model SheafAudienceList {
  id        String   @id @default(cuid())
  ownerId   BigInt
  owner     User     @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  name      String
  memberIds String[] // Postgres text[]
  version   Int      @default(1)
  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([ownerId])
  @@map("sheaf_audience_lists")
}

model SheafBlob {
  id        String   @id @default(cuid())
  sha256    String   @unique
  mime      String
  size      Int
  path      String?
  createdAt DateTime @default(now()) @db.Timestamptz(6)

  attachments SheafAttachment[]

  @@map("sheaf_blobs")
}

model SheafAttachment {
  id        BigInt   @id @default(autoincrement())
  facetId   BigInt
  blobId    String
  name      String
  createdAt DateTime @default(now()) @db.Timestamptz(6)

  facet SheafFacet @relation(fields: [facetId], references: [id], onDelete: Cascade)
  blob  SheafBlob  @relation(fields: [blobId], references: [id])

  @@index([facetId])
  @@index([blobId])
  @@map("sheaf_attachments")
}

enum SharePolicy {
  ALLOW
  REDACT
  FORBID
}

enum AudienceKind {
  EVERYONE
  ROLE
  LIST
  USERS
}

enum AudienceMode {
  DYNAMIC
  SNAPSHOT
}

model UserRole {
  userId    BigInt
  role      String
  createdAt DateTime @default(now()) @db.Timestamptz(6)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, role])
  @@index([role])
  @@map("user_roles")
}

model MessageReaction {
  id        BigInt  @id @default(autoincrement())
  messageId BigInt
  message   Message @relation(fields: [messageId], references: [id], onDelete: Cascade)

  /// Optional: the facet the viewer reacted to (safe to store; we filter on read)
  facetId BigInt?
  facet   SheafFacet? @relation(fields: [facetId], references: [id], onDelete: Cascade)

  userId BigInt
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  emoji     String
  createdAt DateTime @default(now())

  @@unique([messageId, facetId, userId, emoji], map: "uniq_reaction_per_facet")
  @@index([messageId])
  @@index([userId])
}

// --- Mentions ---
model MessageMention {
  id        BigInt   @id @default(autoincrement())
  messageId BigInt
  facetId   BigInt? // mention occurred in this facet body (optional for plain)
  userId    BigInt
  createdAt DateTime @default(now()) @db.Timestamptz(6)

  message Message     @relation(fields: [messageId], references: [id], onDelete: Cascade)
  facet   SheafFacet? @relation(fields: [facetId], references: [id], onDelete: Cascade)
  user    User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([messageId])
  @@index([facetId])
  @@map("message_mentions")
}

// --- Link preview cache (server-fetched, SSRF-safe) ---
model LinkPreview {
  urlHash   String   @id
  url       String
  title     String?
  desc      String?
  image     String?
  fetchedAt DateTime @default(now()) @db.Timestamptz(6)
  status    String // "ok" | "blocked" | "noindex" | "error"
  facetId   BigInt?

  facet SheafFacet? @relation(fields: [facetId], references: [id], onDelete: SetNull)

  @@index([facetId])
  @@index([fetchedAt])
  @@map("link_previews")
}

model ConversationState {
  conversationId BigInt
  userId         BigInt
  lastReadAt     DateTime @default(now()) @db.Timestamptz(6)

  @@id([conversationId, userId])
  @@index([userId])
  @@map("conversation_state")
}

model ActivityPubKey {
  user_id     BigInt   @id
  public_pem  String   @db.Text
  private_pem String   @db.Text
  created_at  DateTime @default(now()) @db.Timestamptz(6)
  updated_at  DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@map("activitypub_keys")
}

// --- ActivityPub federation state ---
enum ApFollowState {
  PENDING
  ACCEPTED
  REJECTED
}

model ApRemoteActor {
  id                BigInt    @id @default(autoincrement())
  url               String    @unique // canonical actor IRI
  inbox             String?
  sharedInbox       String?
  preferredUsername String?
  domain            String?
  publicKeyPem      String?   @db.Text
  lastSeen          DateTime? @db.Timestamptz(6)
  blocked           Boolean   @default(false)

  followers ApFollower[]
  following ApFollowing[]

  @@map("ap_remote_actors")
}

model ApFollower {
  id              BigInt        @id @default(autoincrement())
  user_id         BigInt
  remote_actor_id BigInt
  state           ApFollowState @default(ACCEPTED)
  created_at      DateTime      @default(now()) @db.Timestamptz(6)
  accepted_at     DateTime?     @db.Timestamptz(6)

  user   User          @relation(fields: [user_id], references: [id], onDelete: Cascade)
  remote ApRemoteActor @relation(fields: [remote_actor_id], references: [id], onDelete: Cascade)

  @@unique([user_id, remote_actor_id])
  @@index([user_id])
  @@map("ap_followers")
}

model ApFollowing {
  id              BigInt        @id @default(autoincrement())
  user_id         BigInt
  remote_actor_id BigInt
  state           ApFollowState @default(PENDING)
  created_at      DateTime      @default(now()) @db.Timestamptz(6)
  accepted_at     DateTime?     @db.Timestamptz(6)

  user   User          @relation(fields: [user_id], references: [id], onDelete: Cascade)
  remote ApRemoteActor @relation(fields: [remote_actor_id], references: [id], onDelete: Cascade)

  @@unique([user_id, remote_actor_id])
  @@index([user_id])
  @@map("ap_following")
}

model ApOutboxActivity {
  id            BigInt   @id @default(autoincrement())
  actor_user_id BigInt
  activity_json Json
  created_at    DateTime @default(now()) @db.Timestamptz(6)

  user User @relation(fields: [actor_user_id], references: [id], onDelete: Cascade)

  @@index([actor_user_id, created_at])
  @@map("ap_outbox")
}

enum ApDomainRuleMode {
  ALLOW
  DENY
}

model ApDomainRule {
  id         BigInt           @id @default(autoincrement())
  domain     String           @unique
  mode       ApDomainRuleMode
  created_at DateTime         @default(now()) @db.Timestamptz(6)

  @@map("ap_domain_rules")
}

model Room {
  id               String   @id @default(cuid())
  kind             RoomKind
  conversation_id  BigInt?
  realtime_room_id String?

  isSharded   Boolean @default(false)
  shardUrl    String?
  mediaBucket String?
  kmsKeyArn   String?

  created_at DateTime @default(now()) @db.Timestamptz(6)
  updated_at DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@unique([conversation_id], map: "uniq_room_conversation")
  @@unique([realtime_room_id], map: "uniq_room_realtime")
  @@index([isSharded])
}

enum RoomKind {
  CONVERSATION
  REALTIME
}

model BlockManifest {
  id         String   @id // nanoid
  ownerId    BigInt   @map("owner_id")
  component  String
  props      Json
  originSlug String?  @map("origin_slug")
  originElId String?  @map("origin_el_id")
  forkOfId   String?  @map("fork_of_id")
  isPublic   Boolean  @default(true) @map("is_public")
  thumbnail  String?  @map("thumbnail") // ðŸ‘ˆ NEW
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")

  @@index([ownerId, createdAt])
  @@map("block_manifests")
}

model PageComment {
  id        BigInt   @id @default(autoincrement())
  pageSlug  String
  elementId String
  authorId  BigInt
  text      String
  xPct      Float
  yPct      Float
  createdAt DateTime @default(now())
}

model PagePatch {
  id        BigInt   @id @default(autoincrement())
  pageSlug  String
  elementId String
  authorId  BigInt
  patch     Json // Partial<ElementRecord>
  status    String // "proposed" | "accepted" | "rejected"
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Site {
  id        BigInt   @id @default(autoincrement())
  ownerId   BigInt
  slug      String   @unique
  theme     Json?
  createdAt DateTime @default(now())
}

model SitePage {
  id        BigInt   @id @default(autoincrement())
  siteId    BigInt
  slug      String // "home", "work", â€¦
  payload   Json // CanvasState-like
  order     Int // nav order
  createdAt DateTime @default(now())

  @@unique([siteId, slug])
  @@index([siteId, order])
}

// ----------------------------------------------------------
// GitChat: Merge receipts (append-only audit of version merges)
// ----------------------------------------------------------
model MergeReceipt {
  id                BigInt   @id @default(autoincrement())
  message_id        BigInt
  version_hash      String   @db.VarChar(128)
  merged_at         DateTime @default(now()) @db.Timestamptz(6)
  parents           Json?
  approvals         Json?
  blocks            Json?
  policy_id         String?  @db.VarChar(64)
  prev_receipt_hash String?  @db.VarChar(128)
  snapshot          Json?
  signature         String?  @db.VarChar(512)

  merged_by BigInt
  // â¬‡ï¸ name the relation so we can specify the opposite on User
  mergedBy  User   @relation("UserMergedReceipts", fields: [merged_by], references: [id], onDelete: Cascade)

  message Message @relation(fields: [message_id], references: [id], onDelete: Cascade)

  @@index([message_id, merged_at])
  @@index([version_hash])
  @@map("merge_receipts")
}

// ----------------------------------------------------------
// GitChat: Proposal signals (Approve/Block per proposal facet)
// ----------------------------------------------------------
enum ProposalSignalKind {
  APPROVE
  BLOCK
}

model ProposalSignal {
  id              BigInt             @id @default(autoincrement())
  conversation_id BigInt
  message_id      BigInt
  facet_id        String             @db.VarChar(64)
  user_id         BigInt
  kind            ProposalSignalKind
  created_at      DateTime           @default(now()) @db.Timestamptz(6)

  // â¬‡ï¸ name each relation
  message      Message      @relation("MessageProposalSignals", fields: [message_id], references: [id], onDelete: Cascade)
  user         User         @relation("UserProposalSignals", fields: [user_id], references: [id], onDelete: Cascade)
  conversation Conversation @relation("ConversationProposalSignals", fields: [conversation_id], references: [id], onDelete: Cascade)

  @@unique([facet_id, user_id])
  @@index([message_id])
  @@index([conversation_id])
  @@map("proposal_signals")
}

model AgreementLock {
  id         BigInt   @id @default(autoincrement())
  message_id BigInt   @unique
  locked_by  BigInt
  locked_at  DateTime @default(now()) @db.Timestamptz(6)

  @@map("agreement_locks")
}

model AgreementAck {
  message_id BigInt
  user_id    BigInt
  ack_at     DateTime @default(now()) @db.Timestamptz(6)

  @@id([message_id, user_id])
  @@map("agreement_acks")
}

//Deliberation models and enums

// Proposition model
model Proposition {
  id             String            @id @default(cuid())
  deliberationId String
  authorId       String
  text           String
  mediaType      String            @default("text")
  mediaUrl       String?
  status         PropositionStatus @default(PUBLISHED)

  // Keep the FK here and make it one-to-one:
  promotedClaimId String? @unique
  promotedClaim   Claim?  @relation("PropositionClaim", fields: [promotedClaimId], references: [id], onDelete: SetNull)

  promotedAt DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  // workshop counters etcâ€¦
  voteUpCount   Int @default(0)
  voteDownCount Int @default(0)
  endorseCount  Int @default(0)
  replyCount    Int @default(0)

  votes        PropositionVote[]
  endorsements PropositionEndorsement[]
  replies      PropositionReply[]
  tags         PropositionTag[]

  // optional helper for idempotent migration
  legacyArgumentId String? @unique

  @@index([deliberationId, createdAt])
}

enum PropositionStatus {
  DRAFT
  PUBLISHED
  CLAIMED
  ARCHIVED
}

model PropositionVote {
  id            String      @id @default(cuid())
  propositionId String
  userId        String
  value         Int
  createdAt     DateTime    @default(now())
  proposition   Proposition @relation(fields: [propositionId], references: [id], onDelete: Cascade)

  @@unique([propositionId, userId], name: "propositionId_userId")
}

model PropositionEndorsement {
  id            String      @id @default(cuid())
  propositionId String
  userId        String
  createdAt     DateTime    @default(now())
  proposition   Proposition @relation(fields: [propositionId], references: [id], onDelete: Cascade)

  @@unique([propositionId, userId], name: "propositionId_userId")
}

model PropositionReply {
  id            String      @id @default(cuid())
  propositionId String
  authorId      String
  text          String
  createdAt     DateTime    @default(now())
  proposition   Proposition @relation(fields: [propositionId], references: [id], onDelete: Cascade)

  @@index([propositionId, createdAt])
}

model PropositionTag {
  id            String      @id @default(cuid())
  propositionId String
  key           String // e.g. "topic:education"
  createdAt     DateTime    @default(now())
  proposition   Proposition @relation(fields: [propositionId], references: [id], onDelete: Cascade)

  @@index([propositionId, key])
}

model Argument {
  id             String  @id @default(cuid())
  deliberationId String
  authorId       String
  text           String  @db.Text
  sources        Json?
  confidence     Float?
  isImplicit     Boolean @default(false)

  // DEPRECATED: Legacy single scheme field (Phase 1-3)
  // Use argumentSchemes many-to-many relation instead (Phase 4+)
  schemeId String?         @db.VarChar(64)
  scheme   ArgumentScheme? @relation("LegacyArgumentScheme", fields: [schemeId], references: [id])

  // NEW: Many-to-many relation for multi-scheme classification (Phase 4)
  argumentSchemes ArgumentSchemeInstance[]

  // NEW: Phase 5 - Nets of Argumentation Schemes (sequential composition)
  schemeNet SchemeNet? @relation("ArgumentSchemeNet")

  conclusionClaimId String?
  conclusion        Claim?            @relation("Conclusion", fields: [conclusionClaimId], references: [id])
  premises          ArgumentPremise[]
  implicitWarrant   Json? // optional enthymeme/warrant text or rule

  // NEW P1b metadata
  quantifier String?
  modality   String?
  mediaType  MediaType @default(text)
  mediaUrl   String?
  createdAt  DateTime  @default(now())

  // Phase 2.2: Temporal confidence decay
  lastUpdatedAt DateTime @default(now())

  claimId String?
  claim   Claim?  @relation("ArgumentClaim", fields: [claimId], references: [id])

  // Dialogue Visualization System - Phase 1.1
  // Tracks which DialogueMove created this argument (typically GROUNDS move)
  createdByMoveId String?
  createdByMove   DialogueMove? @relation("ArgumentCreatedByMove", fields: [createdByMoveId], references: [id], onDelete: SetNull)

  deliberation      Deliberation        @relation(fields: [deliberationId], references: [id], onDelete: Cascade)
  outgoingEdges     ArgumentEdge[]      @relation("fromArg")
  incomingEdges     ArgumentEdge[]      @relation("toArg")
  approvals         ArgumentApproval[]
  ViewpointArgument ViewpointArgument[]
  IssueLink         IssueLink[]

  // âœ… back-relations for ArgumentImport (argument side)
  argImportsSource ArgumentImport[] @relation("ArgImpFromArg")
  argImportsTarget ArgumentImport[] @relation("ArgImpToArg")

  debateNodes DebateNode[] @relation(name: "ArgumentDebateNodes")

  // Thesis relations
  thesisProngArguments ThesisProngArgument[] @relation("ThesisProngArguments")

  // ArgumentChain relations
  chainNodes ArgumentChainNode[]

  // Phase 2.2: Fork/Branch/Merge - Import tracking
  importedFromArgs ImportedArgument[] @relation("ArgumentImports")
  importedAsArgs   ImportedArgument[] @relation("ImportedAsArg")

  // Phase 2.3: Quote nodes linked to this argument
  linkedQuotes ArgumentQuote[]
  
  // Phase 3.1: Claim Provenance - Attack/Defense tracking
  attacksAsAttacker  ClaimAttack[]   @relation("AttackingArgument")
  defensesAsDefender ClaimDefense[]  @relation("DefendingArgument")

  // Phase 3.2: Argument-Level Citations
  citationsMade       ArgumentCitation[]        @relation("CitingArguments")
  citationsReceived   ArgumentCitation[]        @relation("CitedByArguments")
  permalink           ArgumentPermalink?
  citationMetrics     ArgumentCitationMetrics?

  @@index([deliberationId])
  @@index([deliberationId, createdAt])
  @@index([deliberationId, claimId, createdAt])
}

// ASPIC+ RuleType enum for strict vs defeasible rules
enum RuleType {
  STRICT      // R_s: Strict rules (cannot rebut conclusions, sound deduction)
  DEFEASIBLE  // R_d: Defeasible rules (rebuttable presumptive inference)
}

// Junction table for many-to-many Argument-ArgumentScheme relation with confidence scores
// Phase 1.1: Enhanced for multi-scheme arguments with roles and explicitness
model ArgumentSchemeInstance {
  id         String   @id @default(cuid())
  argumentId String
  schemeId   String
  confidence Float    @default(1.0) // Scheme inference confidence (0.0-1.0)
  isPrimary  Boolean  @default(false) // Marks the highest-confidence scheme
  
  // Phase 1.1: Multi-scheme support
  role         String  @default("primary") // "primary" | "supporting" | "presupposed" | "implicit"
  explicitness String  @default("explicit") // "explicit" | "presupposed" | "implied"
  order        Int     @default(0) // Display order within role group
  textEvidence String? @db.Text // For explicit schemes: text evidence showing scheme usage
  justification String? @db.Text // For presupposed/implicit: justification for reconstruction
  
  // ASPIC+ Strict Rules Phase 1b
  ruleType RuleType @default(DEFEASIBLE) // Strict rules cannot be rebutted
  ruleName String? // Optional name for undercutting attacks (e.g., "Modus Ponens")
  
  createdAt  DateTime @default(now())
  updatedAt  DateTime @default(now()) @updatedAt

  argument Argument       @relation(fields: [argumentId], references: [id], onDelete: Cascade)
  scheme   ArgumentScheme @relation("ArgumentSchemeInstances", fields: [schemeId], references: [id], onDelete: Cascade)

  @@unique([argumentId, schemeId])
  @@index([argumentId])
  @@index([schemeId])
  @@index([argumentId, role, order])
}


// ============================
// Phase 5: Nets of Argumentation Schemes
// (Sequential composition of schemes for complex multi-step arguments)
// Based on Macagno & Walton Section 7
// ============================

model SchemeNet {
  id          String  @id @default(cuid())
  argumentId  String  @unique
  description String? @db.Text // User description of the argumentative chain

  // Computed confidence (weakest link in chain)
  overallConfidence Float @default(1.0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  argument Argument        @relation("ArgumentSchemeNet", fields: [argumentId], references: [id], onDelete: Cascade)
  steps    SchemeNetStep[]

  @@index([argumentId])
}

model SchemeNetStep {
  id        String  @id @default(cuid())
  netId     String
  schemeId  String
  stepOrder Int // 1, 2, 3... (sequential position in chain)
  label     String? // User-friendly label for this step (e.g., "Classification", "Commitment")

  // Linkage between steps (how output of previous step feeds into this step)
  inputFromStep    Int? // Which step's conclusion feeds into this premise? (null for first step)
  inputSlotMapping Json? // Map conclusion variables to premise variables
  // e.g., { "A": "P1.E", "B": "P2.S" } means conclusion var A maps to premise 1 var E

  // Step-specific text and confidence
  stepText   String? @db.Text // Text excerpt for this inferential step
  confidence Float   @default(1.0) // Confidence for this specific step

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  net    SchemeNet      @relation(fields: [netId], references: [id], onDelete: Cascade)
  scheme ArgumentScheme @relation("SchemeNetSteps", fields: [schemeId], references: [id], onDelete: Restrict)

  @@unique([netId, stepOrder])
  @@index([netId])
  @@index([schemeId])
}

// ============================
// Phase 1.1: Argument Dependencies
// (Tracks relationships between arguments and between schemes within arguments)
// ============================

model ArgumentDependency {
  id             String   @id @default(cuid())
  sourceArgId    String? // Source argument (null for intra-argument scheme dependencies)
  targetArgId    String? // Target argument (null for intra-argument scheme dependencies)
  sourceSchemeId String? // Source scheme instance (for scheme-to-scheme dependencies)
  targetSchemeId String? // Target scheme instance (for scheme-to-scheme dependencies)
  
  dependencyType String // "premise_conclusion" | "enables_premise" | "supports_inference" | "presupposes" | "sequential"
  description    String? @db.Text // User-provided explanation of dependency
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([sourceArgId, targetArgId, dependencyType])
  @@index([sourceArgId])
  @@index([targetArgId])
  @@index([sourceSchemeId])
  @@index([targetSchemeId])
  @@index([dependencyType])
}

// ============================
// Phase 1.1: Scheme Net Patterns (Knowledge Base)
// (Common patterns of multi-scheme arguments for discovery and templates)
// ============================

model SchemeNetPattern {
  id          String   @id @default(cuid())
  name        String   @db.VarChar(255)
  description String   @db.Text
  domain      String? // Application domain (e.g., "policy", "science", "ethics")
  
  // Pattern structure (JSON describing scheme roles and dependencies)
  structure   Json // e.g., {"primary": "practical-reasoning", "supporting": ["expert-opinion", "consequences"]}
  
  // Usage statistics
  usageCount  Int      @default(0)
  
  // Examples
  examples    String[] @default([])
  tags        String[] @default([])
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([domain])
  @@index([usageCount])
}

enum ArgumentAttackSubtype {
  SUPPORT_ATTACK
  CONSEQUENCE_ATTACK
  JUSTIFICATION_ATTACK
  UNDERMINE
  REBUT
  UNDERCUT
  OVERCUT
}

model ArgumentPremise {
  argumentId String
  claimId    String
  isImplicit Boolean  @default(false)
  
  // ASPIC+ Phase B: Axioms Designation
  // Marks premise as axiom (K_n) vs ordinary premise (K_p)
  // Axioms cannot be undermined (attack restriction)
  isAxiom    Boolean  @default(false)
  
  argument   Argument @relation(fields: [argumentId], references: [id], onDelete: Cascade)
  groupKey   String?
  claim      Claim    @relation(fields: [claimId], references: [id], onDelete: Cascade)

  // PK
  @@id([argumentId, claimId])
}

model ArgumentEdge {
  id             String                 @id @default(cuid())
  deliberationId String
  fromArgumentId String
  toArgumentId   String
  type           EdgeType
  attackSubtype  ArgumentAttackSubtype? // NEW

  createdById String
  createdAt   DateTime @default(now())

  targetScope       TargetScope @default(conclusion)
  targetInferenceId String? // NEW: specific inference inside toArgument
  inferenceId       String?

  cqKey           String? // optional Critical Question key
  targetPremiseId String? // target premise Claim (for undermines)
  targetClaimId   String? // target Claim (for rebuttals)
  attackType      AttackType?

  deliberation Deliberation @relation(fields: [deliberationId], references: [id], onDelete: Cascade)
  from         Argument     @relation("fromArg", fields: [fromArgumentId], references: [id], onDelete: Cascade)
  to           Argument     @relation("toArg", fields: [toArgumentId], references: [id], onDelete: Cascade)

  @@index([deliberationId])
  @@index([fromArgumentId])
  @@index([toArgumentId])
}

// --- lib/models/schema.prisma (additions) ---

model ConflictScheme {
  id          String   @id @default(cuid())
  key         String   @unique
  name        String
  description String?  @db.Text
  createdAt   DateTime @default(now())

  // Optional: pre-map to a legacy "attackType"/"targetScope" for AF compatibility
  legacyAttackType  String? // 'REBUTS' | 'UNDERCUTS' | 'UNDERMINES'
  legacyTargetScope String? // 'conclusion' | 'inference' | 'premise'

  applications ConflictApplication[]
}

model ConflictApplication {
  id             String   @id @default(cuid())
  deliberationId String
  schemeId       String? // nullable: ad-hoc conflicts still allowed
  createdById    String
  createdAt      DateTime @default(now())

  // Conflicting element: exactly one of these must be non-null
  conflictingClaimId    String?
  conflictingArgumentId String?

  // Conflicted element: exactly one of these must be non-null
  conflictedClaimId    String?
  conflictedArgumentId String?

  // Optional: keep legacy AF view in sync
  legacyAttackType  String? // 'REBUTS'|'UNDERCUTS'|'UNDERMINES'
  legacyTargetScope String? // 'conclusion'|'inference'|'premise'

  // Metadata: track which CQ this attack addresses, source, etc.
  metaJson Json? @default("{}")

  // Dialogue Visualization System - Phase 1.1
  // Tracks which DialogueMove created this conflict (typically ATTACK move)
  createdByMoveId String?
  createdByMove   DialogueMove? @relation("ConflictCreatedByMove", fields: [createdByMoveId], references: [id], onDelete: SetNull)

  // ASPIC+ Integration - Phase 1d
  // Formal argumentation semantics for attacks and defeats
  aspicAttackType  String? // 'undermining' | 'rebutting' | 'undercutting'
  aspicDefeatStatus Boolean? // true if attack succeeded as defeat (after preference check)
  aspicMetadata    Json? // Full ASPIC+ attack details: { attackerId, defenderId, targetPremiseIndex, ruleId, preferenceResult, ... }

  scheme ConflictScheme? @relation(fields: [schemeId], references: [id], onDelete: SetNull)

  // CQ Enhancement: Back-reference to CQAttack linkage
  cqAttacks CQAttack[]

  @@index([deliberationId])
  @@index([conflictingClaimId])
  @@index([conflictingArgumentId])
  @@index([conflictedClaimId])
  @@index([conflictedArgumentId])
}

// ASPIC+ Explicit Contraries - Phase D-1
// Allows users to explicitly mark claim pairs as contrary/contradictory
// independent of attack relationships
model ClaimContrary {
  id             String   @id @default(cuid())
  deliberationId String
  claimId        String // First claim
  contraryId     String // Contradictory/contrary claim
  isSymmetric    Boolean  @default(true) // true = contradictory (mutual), false = contrary (one-way)
  
  // Provenance tracking for transparency
  createdById BigInt
  createdAt   DateTime @default(now())
  
  // Status for future challenge/moderation system
  status String @default("ACTIVE") // "ACTIVE" | "PROPOSED" | "DISPUTED" | "RETRACTED"
  
  // Optional metadata
  reason String? @db.Text // User's explanation for why these are contrary
  
  // Relations
  deliberation Deliberation @relation(fields: [deliberationId], references: [id], onDelete: Cascade)
  claim        Claim        @relation("ClaimContraries", fields: [claimId], references: [id], onDelete: Cascade)
  contrary     Claim        @relation("ContraryOf", fields: [contraryId], references: [id], onDelete: Cascade)
  createdBy    User         @relation(fields: [createdById], references: [id], onDelete: Cascade)
  
  @@unique([claimId, contraryId])
  @@index([deliberationId])
  @@index([claimId])
  @@index([contraryId])
  @@index([createdById])
  @@index([deliberationId, status])
}

// Dialogue Action Tracking Models (Phase 2.1)

model ResponseVote {
  id             String   @id @default(cuid())
  dialogueMoveId String
  voterId        String
  voteType       String // "UPVOTE", "DOWNVOTE", "FLAG"
  createdAt      DateTime @default(now())

  dialogueMove DialogueMove @relation(fields: [dialogueMoveId], references: [id], onDelete: Cascade)

  @@unique([dialogueMoveId, voterId])
  @@index([dialogueMoveId])
  @@index([voterId])
}

model PreferenceScheme {
  id          String   @id @default(cuid())
  key         String   @unique
  name        String
  description String?  @db.Text
  // optional: scope info (preferences between information, between RAs, or between schemes)
  scope       String? // 'info' | 'inference' | 'scheme' | 'mixed'
  createdAt   DateTime @default(now())

  applications PreferenceApplication[]
}

model PreferenceApplication {
  id             String   @id @default(cuid())
  deliberationId String
  schemeId       String? // nullable
  createdById    String
  createdAt      DateTime @default(now())

  // Preferred element (exactly one of these)
  preferredClaimId    String?
  preferredArgumentId String?
  preferredSchemeId   String? // when preferring an inference scheme

  // Dispreferred element (exactly one of these)
  dispreferredClaimId    String?
  dispreferredArgumentId String?
  dispreferredSchemeId   String?

  // ASPIC+ Phase 4.2: Ordering metadata (optional - defaults to system-wide policy)
  orderingPolicy String? // "last-link" | "weakest-link" | null (use deliberation default)
  setComparison  String? // "elitist" | "democratic" | null (use default elitist)
  justification  String? @db.Text // Fix bug: UI collects but doesn't save

  // ASPIC+ Phase 5.3: Conflict resolution (weighted preferences deferred)
  weight                 Float?    @default(1.0) // Confidence score [0.0, 1.0] (deferred)
  conflictStatus         String?   @default("none") // "none" | "detected" | "resolved"
  conflictResolution     Json? // Resolution metadata (strategy, timestamp, resolvedBy)
  conflictResolvedAt     DateTime?
  conflictResolvedBy     String?

  scheme PreferenceScheme? @relation(fields: [schemeId], references: [id], onDelete: SetNull)

  @@index([deliberationId])
  @@index([preferredClaimId])
  @@index([preferredArgumentId])
  @@index([dispreferredClaimId])
  @@index([dispreferredArgumentId])
  @@index([conflictStatus])
}

model DefaultRule {
  id             String   @id @default(cuid())
  deliberationId String
  argumentId     String
  role           String // 'premise' | 'claim'
  antecedent     String // Î±
  justification  String // Î²
  consequent     String // Î³
  createdBy      String
  createdAt      DateTime @default(now())
}

model ArgumentApproval {
  id             String   @id @default(cuid())
  deliberationId String
  argumentId     String
  userId         String
  createdAt      DateTime @default(now())

  deliberation Deliberation @relation(fields: [deliberationId], references: [id], onDelete: Cascade)
  argument     Argument     @relation(fields: [argumentId], references: [id], onDelete: Cascade)

  @@unique([argumentId, userId])
  @@index([deliberationId, userId])
  @@index([deliberationId, argumentId], name: "argapproval_delib_argument") // NEW
}

model ViewpointSelection {
  id             String             @id @default(cuid())
  deliberationId String
  rule           RepresentationRule
  k              Int
  coverageAvg    Float
  coverageMin    Float
  jrSatisfied    Boolean            @default(false)
  explainJson    Json
  createdById    String
  createdAt      DateTime           @default(now())

  deliberation Deliberation @relation(fields: [deliberationId], references: [id], onDelete: Cascade)

  amplificationEvents AmplificationEvent[] @relation("SelectionEvents")

  viewpointArgs ViewpointArgument[]

  @@index([deliberationId, rule, k, createdAt], name: "vp_sel_delib_rule_k_createdAt") // NEW
  @@index([deliberationId, createdAt])
}

model ViewpointArgument {
  selectionId String
  argumentId  String
  viewpoint   Int // 0..k-1 index

  selection ViewpointSelection @relation(fields: [selectionId], references: [id], onDelete: Cascade)
  argument  Argument           @relation(fields: [argumentId], references: [id], onDelete: Cascade)

  @@id([selectionId, argumentId])
  @@index([viewpoint])
  @@index([selectionId, viewpoint, argumentId], name: "vp_arg_selection_viewpoint_argument") // NEW
}

// --------- Clusters (basic) ----------
enum ClusterType {
  topic
  affinity
}

model Cluster {
  id             String   @id @default(cuid())
  deliberationId String
  type           String // 'affinity' | 'topic' (keep string for flexibility)
  label          String?
  createdAt      DateTime @default(now())

  deliberation            Deliberation      @relation(fields: [deliberationId], references: [id], onDelete: Cascade)
  users                   UserCluster[]
  arguments               ArgumentCluster[]
  bridgeRequestsTargeting BridgeRequest[]   @relation("BridgeTargetCluster")

  @@index([deliberationId, type, createdAt])
  @@index([deliberationId, type])
  @@index([deliberationId, createdAt])
}

model UserCluster {
  id        String @id @default(cuid())
  clusterId String
  userId    String
  score     Float  @default(0)

  cluster Cluster @relation(fields: [clusterId], references: [id], onDelete: Cascade)

  @@index([clusterId])
  @@index([userId])
}

model ArgumentCluster {
  id         String @id @default(cuid())
  clusterId  String
  argumentId String
  score      Float  @default(0)

  cluster Cluster @relation(fields: [clusterId], references: [id], onDelete: Cascade)

  // argumentId refers to your existing Argument model
  @@index([clusterId, argumentId])
  @@index([clusterId])
  @@index([argumentId])
}

// --------- Bridge Builder ----------
enum BridgeRequestStatus {
  open
  assigned
  completed
  expired
}

model BridgeRequest {
  id              String              @id @default(cuid())
  deliberationId  String
  requestedById   String
  targetClusterId String
  targetCluster   Cluster             @relation("BridgeTargetCluster", fields: [targetClusterId], references: [id], onDelete: Cascade)
  status          BridgeRequestStatus @default(open)
  expiresAt       DateTime?
  createdAt       DateTime            @default(now())

  assignments BridgeAssignment[]
}

model BridgeAssignment {
  id            String            @id @default(cuid())
  requestId     String
  assigneeId    String
  assignedAt    DateTime          @default(now())
  acceptedAt    DateTime?
  completedAt   DateTime?
  summaryCardId String?
  summaryCard   DeliberationCard? @relation("BridgeSummaryCard", fields: [summaryCardId], references: [id], onDelete: SetNull)
  rewardCare    Int               @default(0)

  request BridgeRequest @relation(fields: [requestId], references: [id], onDelete: Cascade)
}

model AmplificationEvent {
  id             String             @id @default(cuid())
  deliberationId String? // ðŸ‘ˆ make optional for now
  hostType       ContentTargetType?
  hostId         String?
  eventType      String? // ðŸ‘ˆ make optional for now
  reason         String?
  payload        Json?
  createdById    String?
  createdAt      DateTime           @default(now())

  viewpointSelectionId String?
  viewpointSelection   ViewpointSelection? @relation("SelectionEvents", fields: [viewpointSelectionId], references: [id])
}

model SchemeVariant {
  id       String         @id @default(cuid())
  schemeId String
  key      String // e.g., 'pos_conseq' | 'neg_conseq'
  name     String
  notes    String?
  scheme   ArgumentScheme @relation(fields: [schemeId], references: [id], onDelete: Cascade)
}

// --------- Briefs ----------
enum BriefStatus {
  draft
  published
}

enum Visibility {
  public
  unlisted
  room_only
}

model Brief {
  id               String      @id @default(cuid())
  roomId           String
  title            String
  slug             String      @unique
  status           BriefStatus @default(draft)
  visibility       Visibility  @default(public)
  createdById      String
  currentVersionId String?     @unique // ðŸ‘ˆ must be unique
  createdAt        DateTime    @default(now())

  // Relation 1: one-to-one
  currentVersion BriefVersion? @relation("BriefCurrentVersion", fields: [currentVersionId], references: [id])

  // Relation 2: one-to-many
  versions BriefVersion[] @relation("BriefVersions")
}

model BriefVersion {
  id                         String   @id @default(cuid())
  briefId                    String
  number                     Int
  compiledFromDeliberationId String?
  sectionsJson               Json
  citations                  Json
  createdById                String
  createdAt                  DateTime @default(now())

  // Relation 1 (opposite of Brief.currentVersion)
  briefAsCurrent Brief? @relation("BriefCurrentVersion")

  // Relation 2 (opposite of Brief.versions)
  brief Brief @relation("BriefVersions", fields: [briefId], references: [id], onDelete: Cascade)

  links BriefLink[] @relation("BriefVersionLinks")

  @@unique([briefId, number])
}

enum BriefSourceType {
  card
  argument
  post
  claim
}

model BriefLink {
  id             String          @id @default(cuid())
  briefVersionId String
  sourceType     BriefSourceType
  sourceId       String

  version BriefVersion @relation("BriefVersionLinks", fields: [briefVersionId], references: [id], onDelete: Cascade)
}

enum IssueState {
  open
  pending
  closed
}

enum IssueLinkTargetType {
  argument
  claim
  card
  inference
}

enum IssueLinkRole {
  related
  blocks
  depends_on
  warrant
  evidence
}

enum IssueKind {
  general
  cq
  moderation
  evidence
  structural
  governance
  clarification // NEW: For clarification requests (Q&A)
  community_defense // NEW: For non-canonical move reviews
}

model Issue {
  id             String     @id @default(cuid())
  deliberationId String
  label          String
  description    String?
  state          IssueState @default(open)
  createdById    BigInt // <-- FIXED: Was String
  closedById     String?
  closedAt       DateTime?
  kind           IssueKind  @default(general)
  key            String?
  assigneeId     BigInt? // <-- FIXED: Was String?
  createdAt      DateTime   @default(now())
  updatedAt      DateTime   @updatedAt

  // --- NEW: For clarification requests ---
  questionText String? // The actual question being asked
  answerText   String? // Author's answer (when provided)
  answeredAt   DateTime? // When the question was answered
  answeredById BigInt? // Who answered the question

  // --- NEW: For community defense (NCM) reviews ---
  ncmId       String? // Link to NonCanonicalMove being reviewed
  ncmStatus   NCMStatus? // Status of the NCM (PENDING, APPROVED, REJECTED, EXECUTED)
  reviewedAt  DateTime? // When author reviewed the NCM
  reviewNotes String? // Author's notes on approval/rejection

  // --- Relations ---
  deliberation     Deliberation      @relation(fields: [deliberationId], references: [id])
  createdBy        User              @relation("CreatedIssues", fields: [createdById], references: [id])
  assignee         User?             @relation("AssignedIssues", fields: [assigneeId], references: [id])
  answeredBy       User?             @relation("AnsweredIssues", fields: [answeredById], references: [id])
  nonCanonicalMove NonCanonicalMove? @relation(fields: [ncmId], references: [id])
  links            IssueLink[]

  @@index([deliberationId])
  @@index([deliberationId, state])
  @@index([deliberationId, kind])
  @@index([kind, key], map: "issues_kind_key_idx")
  @@index([ncmId])
  @@index([assigneeId])
}

model IssueLink {
  id             String              @id @default(cuid())
  issueId        String
  targetType     IssueLinkTargetType // NEW
  targetId       String // NEW
  // Back-compat (nullable): keep while migrating
  argumentId     String?
  claimId        String?
  deliberationId String?
  role           IssueLinkRole? // tighten if you like (else String)
  createdAt      DateTime            @default(now())

  issue        Issue         @relation(fields: [issueId], references: [id], onDelete: Cascade)
  Argument     Argument?     @relation(fields: [argumentId], references: [id])
  Claim        Claim?        @relation(fields: [claimId], references: [id])
  Deliberation Deliberation? @relation(fields: [deliberationId], references: [id])

  @@unique([issueId, targetType, targetId])
  @@index([targetType, targetId])
  @@index([claimId]) // supports current counts route
}

// ---------- Enums ----------
enum ModerationStatus {
  OK
  NEEDS_SOURCES
  WORKSHOP
  OFF_TOPIC_REDIRECT
  DUPLICATE_MERGE
  DISPUTED
  OUT_OF_BOUNDS
}

enum ContentTargetType {
  article
  post
  room_thread
  deliberation
  argument
  card
  claim
  brief
  brief_version
}

enum PanelistRole {
  member
  chair
  observer
}

enum PanelDecisionType {
  APPROVE
  WORKSHOP
  REDIRECT
}

enum LogEntryType {
  STATUS_CHANGE
  PANEL_OPEN
  PANEL_CLOSE
  PANEL_DECISION
  POLICY_CHANGE
  NOTE
}

/// --- P1: Deliberation Core ---
enum DeliberationHostType {
  article
  post
  room_thread
  library_stack
  site
  discussion
  free
  inbox_thread
  work
}

enum RepresentationRule {
  utilitarian
  harmonic
  maxcov
}

enum EdgeType {
  support
  rebut
  undercut
  concede
  CA
}

// IAMT granularity for counters
enum TargetScope {
  conclusion
  premise
  inference
}

enum Quantifier {
  SOME
  MANY
  MOST
  ALL
}

enum Modality {
  COULD
  LIKELY
  NECESSARY
}

enum MediaType {
  text
  image
  video
  audio
}

enum TargetType {
  argument
  claim
  card
  warrant
  rebuttal
}

// ---------- Governance core ----------
model DecisionReceipt {
  id         String            @id @default(cuid())
  roomId     String
  actorId    String
  action     String // e.g., "STATUS_CHANGE", "PANEL_DECISION"
  reason     String?
  targetType ContentTargetType
  targetId   String
  panelId    String?
  policyId   String?
  createdAt  DateTime          @default(now())

  panel Panel? @relation(fields: [panelId], references: [id])

  @@index([roomId, createdAt])
}

model RoomLogbook {
  id        String       @id @default(cuid())
  roomId    String
  entryType LogEntryType
  summary   String
  payload   Json?
  createdAt DateTime     @default(now())
}

// Latest status for any polymorphic content in a room.
// History is kept via DecisionReceipt + RoomLogbook (immutable).
model ContentStatus {
  id            String            @id @default(cuid())
  roomId        String?
  targetType    ContentTargetType
  targetId      String
  currentStatus ModerationStatus
  prevStatus    ModerationStatus?
  reason        String?
  decidedById   String?
  panelId       String?
  createdAt     DateTime          @default(now())

  @@unique([roomId, targetType, targetId])
}

model Panel {
  id        String            @id @default(cuid())
  roomId    String
  openedAt  DateTime          @default(now())
  closedAt  DateTime?
  panelists Panelist[]
  receipts  DecisionReceipt[]
}

model Panelist {
  id       String       @id @default(cuid())
  panelId  String
  userId   String
  role     PanelistRole @default(member)
  joinedAt DateTime     @default(now())

  panel Panel @relation(fields: [panelId], references: [id])

  @@unique([panelId, userId])
}

model DeliberationCard {
  id                        String   @id @default(cuid())
  deliberationId            String
  authorId                  String
  status                    String
  createdAt                 DateTime @default(now())
  updatedAt                 DateTime @updatedAt
  claimText                 String
  reasonsText               String[]
  evidenceLinks             String[]
  anticipatedObjectionsText String[]
  counterText               String?
  confidence                Float?
  warrantText               String?
  hostEmbed                 String?
  hostId                    String?
  moid                      String   @unique

  bridgeSummaryAssignments BridgeAssignment[] @relation("BridgeSummaryCard")

  // New relation to Claim
  claimId String?
  claim   Claim?  @relation(fields: [claimId], references: [id], onDelete: SetNull)

  // Relation to Deliberation
  deliberation Deliberation @relation(fields: [deliberationId], references: [id])

  // Back relation for CardCitation
  citations CardCitation[]

  @@index([deliberationId, createdAt]) // cards by delib, time-sorted
  @@index([deliberationId, status, createdAt])
  @@index([deliberationId, authorId, createdAt])
}

model CardCitation {
  id     String @id @default(cuid())
  cardId String
  uri    String

  locatorStart String? // e.g., CSS/XPath/char off
  locatorEnd   String?
  excerptHash  String?
  snapshotKey  String?
  cslJson      Json?

  card DeliberationCard @relation(fields: [cardId], references: [id], onDelete: Cascade)
}

model MissingPremise {
  id             String    @id @default(cuid())
  deliberationId String
  targetType     String // 'argument' | 'card'
  targetId       String
  proposedById   String
  text           String
  status         String    @default("proposed") // 'proposed'|'accepted'|'declined'
  premiseType    String    @default("premise") // 'premise'|'warrant'
  createdAt      DateTime  @default(now())
  decidedAt      DateTime?
}

// Optional storage for Rhetoric Lens v0 (client-heuristic can be ephemeral)
model ArgumentAnnotation {
  id          String   @id @default(cuid())
  targetType  String // 'argument' | 'card'
  targetId    String
  type        String // 'metaphor'|'analogy'|'hedge'|'intensifier'|'implicature'
  offsetStart Int
  offsetEnd   Int
  text        String
  source      String // 'heuristic'|'human'|'ml'
  createdAt   DateTime @default(now())
}

enum AttackType {
  REBUTS
  UNDERCUTS
  UNDERMINES
}

// =====================
// Phase 0.1: Burden of Proof Enums
// =====================

enum BurdenOfProof {
  PROPONENT // Raising the question shifts burden to the argument's proponent
  CHALLENGER // The challenger must provide evidence to support their challenge
}

enum PremiseType {
  ORDINARY // Must always be supported
  ASSUMPTION // Accepted unless questioned (Carneades)
  EXCEPTION // Challenger must prove it applies (Carneades)
}

// =====================
// Phase 0.2: Epistemic Mode Enum
// =====================

enum EpistemicMode {
  FACTUAL // Real events, actual states of affairs
  HYPOTHETICAL // Future scenarios, possible situations
  COUNTERFACTUAL // What-if reasoning, contrary-to-fact situations
}

// =====================
// M3: Attack-kind enum
// =====================

enum ClaimAttackType {
  SUPPORTS
  REBUTS
  UNDERCUTS
  UNDERMINES
}

enum ClaimEdgeType {
  supports
  rebuts
}

enum EvidenceKind {
  primary
  secondary
  dataset
  code
}

enum UrnEntityType {
  claim
  card
  brief_version
}

enum GroundLabel {
  IN
  OUT
  UNDEC
}

model Claim {
  id          String             @id @default(cuid())
  text        String
  createdById String
  moid        String             @unique
  createdAt   DateTime           @default(now())
  cards       DeliberationCard[]
  warrant     ClaimWarrant? // ðŸ‘ˆ back-relation

  deliberationId String?
  deliberation   Deliberation? @relation(fields: [deliberationId], references: [id], onDelete: Cascade)

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Phase 1.1: Academic Paper-to-Claim Pipeline Fields
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  sourceId          String?               // Link to academic source
  source            Source?               @relation(fields: [sourceId], references: [id], onDelete: SetNull)
  academicClaimType AcademicClaimType?    // Thesis, Empirical, Causal, etc.
  pageNumber        Int?                  // Page number in source
  sectionName       String?               // Section name (Introduction, Methods, etc.)
  paragraphIndex    Int?                  // Paragraph index within section
  supportingQuote   String?   @db.Text    // Exact quote from source
  quoteLocator      String?               // "p.42, para.3"
  extractedByAI     Boolean   @default(false) // Was this claim AI-extracted?
  aiConfidence      Float?                // AI confidence score 0.0-1.0
  humanVerified     Boolean   @default(false) // Has a human verified this claim?
  verifiedById      String?               // Who verified it
  verifiedAt        DateTime?             // When it was verified

  // Dialogue Visualization System - Phase 1.1
  // Tracks which DialogueMove introduced this claim into the deliberation
  introducedByMoveId String?
  introducedByMove   DialogueMove? @relation("ClaimIntroducedByMove", fields: [introducedByMoveId], references: [id], onDelete: SetNull)

  arguments Argument[] @relation("ArgumentClaim")

  edgesFrom ClaimEdge[]     @relation("fromClaim")
  edgesTo   ClaimEdge[]     @relation("toClaim")
  citations ClaimCitation[]

  claimType String? // "Agent" | "Assertion" | "Domain" | ...

  urns        Urn[]        @relation("ClaimUrns")
  ClaimLabel  ClaimLabel?
  claimValues ClaimValue[] // <â€” opposite side for ClaimValue.claim

  ClaimEvidence ClaimEvidence[]

  sourceProposition Proposition? @relation("PropositionClaim")

  IssueLink IssueLink[]

  // NEW
  canonicalClaimId String?
  canonical        CanonicalClaim? @relation(fields: [canonicalClaimId], references: [id], onDelete: SetNull)

  // NEW (optional negation link for DS pl later)
  negatesClaimId String?
  negates        Claim?  @relation("NegationClaims", fields: [negatesClaimId], references: [id], onDelete: SetNull)
  negatedBy      Claim[] @relation("NegationClaims")

  // NegationMap relations (for explicit negation mappings)
  negationMaps  NegationMap[] @relation("NegationMapClaim")
  negatedByMaps NegationMap[] @relation("NegationMapNegatedClaim")

  debateNodes  DebateNode[] @relation(name: "ClaimDebateNodes")
  canonicalKey String?      @unique

  asPremiseOf  ArgumentPremise[]
  asConclusion Argument[]        @relation("Conclusion")

  // Thesis relations
  thesisReferences Thesis[]      @relation("ThesisMainClaim")
  prongClaims      ThesisProng[] @relation("ProngMainClaim")

  // ASPIC+ Explicit Contraries - Phase D-1
  contraries   ClaimContrary[] @relation("ClaimContraries")
  contraryOf   ClaimContrary[] @relation("ContraryOf")

  // Phase 2.2: Fork/Branch/Merge - Import tracking
  importedFromClaims ImportedClaim[] @relation("ClaimImports")
  importedAsClaims   ImportedClaim[] @relation("ImportedAs")

  // Phase 2.3: Quote nodes linked to this claim
  linkedQuotes ClaimQuote[]

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Phase 3.1: Claim Provenance Tracking
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  
  // Origin tracking - when/where claim was first made
  originDate        DateTime?             // When first asserted
  originAuthorId    String?               // Who first made this claim (auth_id)
  
  // Version tracking
  versions          ClaimVersion[]
  currentVersionId  String?               @unique
  currentVersion    ClaimVersion?         @relation("CurrentVersion", fields: [currentVersionId], references: [id])
  
  // Challenge tracking (aggregated counts for performance)
  challengeCount    Int                   @default(0)
  openChallenges    Int                   @default(0)
  defendedCount     Int                   @default(0)
  concededCount     Int                   @default(0)
  
  // Consensus status
  consensusStatus   ConsensusStatus       @default(UNDETERMINED)
  consensusUpdatedAt DateTime?
  
  // Relations to attacks and defenses
  attacksReceived   ClaimAttack[]         @relation("AttackedClaim")
  defensesFor       ClaimDefense[]        @relation("DefendedClaim")
  
  // Canonical claim instances (for cross-deliberation tracking)
  claimInstances    ClaimInstance[]
  
  // Claim Prediction System
  predictions       ClaimPrediction[]
  hasPredictions    Boolean               @default(false)
  predictionCount   Int                   @default(0)
  confirmedCount    Int                   @default(0)
  disconfirmedCount Int                   @default(0)
  pendingCount      Int                   @default(0)

  @@index([deliberationId, id], name: "claim_delib_id") // NEW
  @@index([deliberationId, createdAt]) // claims by delib, time-sorted
  @@index([canonicalClaimId])
  @@index([negatesClaimId])
  @@index([deliberationId])
  @@index([deliberationId, createdById, createdAt])
  @@index([sourceId])                                    // Phase 1.1: Index for source lookups
  @@index([academicClaimType])                           // Phase 1.1: Index for claim type filtering
  @@index([consensusStatus])                             // Phase 3.1: Consensus status filtering
}

model ClaimEdge {
  id          String        @id @default(cuid())
  fromClaimId String
  toClaimId   String
  type        ClaimEdgeType
  targetScope String? // 'premise' | 'inference' | 'conclusion'

  createdAt  DateTime         @default(now())
  attackType ClaimAttackType? // UNDERCUTS | UNDERMINES | REBUTS | SUPPORTS?

  deliberationId String?
  Deliberation   Deliberation? @relation(fields: [deliberationId], references: [id])

  // CQ Enhancement: Metadata for provenance tracking (cqKey, schemeKey, source)
  metaJson Json? @default("{}")

  from Claim @relation("fromClaim", fields: [fromClaimId], references: [id], onDelete: Cascade)
  to   Claim @relation("toClaim", fields: [toClaimId], references: [id], onDelete: Cascade)

  // CQ Enhancement: Back-reference to CQAttack linkage
  cqAttacks CQAttack[]

  @@unique([fromClaimId, toClaimId, type, attackType], name: "unique_from_to_type_attack")
  @@index([deliberationId, fromClaimId], name: "claimedge_delib_from") // NEW
  @@index([deliberationId, toClaimId], name: "claimedge_delib_to") // NEW
  @@index([fromClaimId])
  @@index([toClaimId])
  @@index([deliberationId])
  @@index([toClaimId, createdAt]) // inbound edges
  @@index([fromClaimId, createdAt]) // outbound edges
}

model ClaimLabel {
  id             String      @id @default(cuid())
  deliberationId String?
  claimId        String      @unique
  semantics      String // 'grounded'
  label          GroundLabel
  explainJson    Json?
  computedAt     DateTime    @default(now())

  claim Claim @relation(fields: [claimId], references: [id], onDelete: Cascade)

  @@index([deliberationId])
}

model ClaimCitation {
  id           String  @id @default(cuid())
  claimId      String
  uri          String
  locatorStart Int?
  locatorEnd   Int?
  excerptHash  String
  snapshotKey  String?
  cslJson      Json?
  note         String?

  claim Claim @relation(fields: [claimId], references: [id], onDelete: Cascade)

  @@index([claimId])
}

model ClaimStats {
  deliberationId String
  claimId        String
  approvalsCount Int      @default(0)
  supportsCount  Int      @default(0)
  rebutsCount    Int      @default(0)
  undercutsCount Int      @default(0)
  updatedAt      DateTime @default(now())

  @@id([deliberationId, claimId])
  @@index([deliberationId])
  @@index([approvalsCount])
  @@index([undercutsCount])
  @@map("claim_stats")
}

model CanonicalClaim {
  id        String   @id @default(cuid())
  slug      String   @unique
  title     String
  summary   String?
  createdAt DateTime @default(now())

  claims Claim[]
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Phase 3.1: Enhanced Canonical Claim for Cross-Deliberation Identity
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  
  // Representative text (from most authoritative instance)
  representativeText String?  @db.Text
  
  // Instances across deliberations
  instances         ClaimInstance[]
  
  // Global metrics
  totalInstances    Int      @default(1)
  totalChallenges   Int      @default(0)
  globalStatus      ConsensusStatus @default(UNDETERMINED)
  
  // Discovery metadata
  lastActivityAt    DateTime @default(now())
  
  // Semantic fingerprint for matching (hash of normalized text)
  semanticHash      String?
  
  @@index([globalStatus])
}

model ClaimEvidence {
  id        String   @id @default(cuid())
  claimId   String
  uri       String
  title     String?
  citation  String?
  addedById String?
  createdAt DateTime @default(now())

  claim Claim @relation(fields: [claimId], references: [id], onDelete: Cascade)

  @@index([claimId])
}

model Urn {
  id         String   @id @default(cuid())
  entityId   String
  entityType String
  urn        String   @unique
  createdAt  DateTime @default(now())

  claim Claim? @relation("ClaimUrns", fields: [entityId], references: [id])
}

model ArgumentScheme {
  id          String  @id @default(cuid())
  key         String  @unique
  name        String?
  description String?
  title       String?

  summary        String
  cq             Json             @default("{}") // we'll set a DB default to [] below; this avoids null
  SchemeInstance SchemeInstance[]

  // Formal scheme structure (Walton-style)
  premises   Json? // Array of premise templates: [{ id: "P1", type: "major|minor", text: "Source E is an expert...", variables: ["E", "S", "A"] }]
  conclusion Json? // Conclusion template: { text: "A is true", variables: ["A"] }

  // Macagno taxonomy:
  purpose          String? // 'action' | 'state_of_affairs'
  source           String? // 'internal' | 'external'
  materialRelation String? // 'cause' | 'definition' | 'analogy' | 'authority' | ...
  reasoningType    String? // 'deductive' | 'inductive' | 'abductive' | 'practical'
  ruleForm         String? // 'MP' | 'MT' | 'defeasible_MP' | ...
  conclusionType   String? // 'ought' | 'is' | ...
  slotHints        Json? // UI slot descriptions
  variants         SchemeVariant[]
  cqs              CriticalQuestion[]
  validators       Json? // CAS2-style v/e metadata (optional)

  // DEPRECATED: Legacy single argument relation (Phase 1-3)
  Argument Argument[] @relation("LegacyArgumentScheme")

  // NEW: Many-to-many relation for multi-scheme classification (Phase 4)
  argumentSchemeInstances ArgumentSchemeInstance[] @relation("ArgumentSchemeInstances")

  // NEW: Phase 5 - Scheme net steps (for sequential scheme composition)
  schemeNetSteps SchemeNetStep[] @relation("SchemeNetSteps")

  // NEW: Phase 6 - Scheme clustering & family resemblances (Macagno & Walton Section 6)
  // Enables hierarchical classification and CQ inheritance
  parentSchemeId String?          @db.VarChar(64)
  parentScheme   ArgumentScheme?  @relation("SchemeHierarchy", fields: [parentSchemeId], references: [id], onDelete: SetNull)
  childSchemes   ArgumentScheme[] @relation("SchemeHierarchy")

  clusterTag String? // e.g., "practical_reasoning_family", "authority_family"
  inheritCQs Boolean @default(true) // Whether to inherit parent scheme's CQs

  // NEW: Module 8 - ASPIC+ integration metadata
  // Maps this scheme to ASPIC+ constructs for formal argumentation semantics
  aspicMapping Json? // { ruleType: 'strict' | 'defeasible', ruleId?: string, preferenceLevel?: number }

  // NEW: Phase 0.2 - Epistemic Mode (Kienpointner dimension)
  // Distinguishes factual, hypothetical, and counterfactual reasoning
  epistemicMode EpistemicMode @default(FACTUAL)

  // NEW: Phase 0.3 - Enhanced Scheme Metadata
  // Better discovery, organization, and user guidance
  tags       String[] @default([]) // Searchable tags: ["politics", "science", "ethics"]
  examples   String[] @default([]) // Concrete usage examples
  usageCount Int      @default(0) // Popularity tracking for recommendations
  difficulty String   @default("intermediate") // "beginner" | "intermediate" | "advanced"

  // NEW: Phase 0.5 - Identification Conditions (Walton)
  // Help users identify when this scheme is applicable
  identificationConditions String[] @default([]) // Pattern-matching conditions: ["source expertise", "claim about future"]
  whenToUse                String?   @default("") // Natural language guidance: "Use when arguing from authority..."

  // NEW: Phase 2 Week 6 - Semantic Clustering
  // Organizes schemes by topic/domain for cluster browser navigation
  semanticCluster String? // "authority" | "causality" | "decision_making" | "analogy" | "classification" | "values" | "evidence" | "opposition"

  @@index([parentSchemeId])
  @@index([clusterTag])
  @@index([epistemicMode])
  @@index([usageCount])
  @@index([semanticCluster])
}

model CQStatus {
  id         String     @id @default(cuid())
  targetType TargetType
  targetId   String
  argumentId String?
  status     String? // DEPRECATED: use statusEnum instead

  // New status enum for multi-layer system
  statusEnum CQStatusEnum @default(OPEN)

  schemeKey   String
  cqKey       String
  satisfied   Boolean @default(false) // DEPRECATED: check statusEnum instead
  groundsText String? // DEPRECATED: use responses relation instead

  // Multi-response system
  canonicalResponseId String?
  canonicalResponse   CQResponse?  @relation("CanonicalResponse", fields: [canonicalResponseId], references: [id], onDelete: SetNull)
  responses           CQResponse[] @relation("AllResponses")

  // Review tracking
  lastReviewedAt DateTime?
  lastReviewedBy String?

  createdById String
  roomId      String? // denormalized at write-time for RLS
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Activity log
  activities CQActivityLog[]

  // CQ Enhancement: Track attacks created from this CQ
  attacks CQAttack[] @relation("CQAttacks")

  @@unique([targetType, targetId, schemeKey, cqKey])
  @@index([targetType, targetId, schemeKey])
  @@index([targetType, targetId])
  @@index([roomId])
  @@index([statusEnum, roomId])
}

enum CQStatusEnum {
  OPEN // No responses yet
  PENDING_REVIEW // Has responses awaiting approval
  PARTIALLY_SATISFIED // Some responses approved, but incomplete
  SATISFIED // Author accepted canonical response
  DISPUTED // Conflicting responses or new challenges
}

model CQResponse {
  id String @id @default(cuid())

  cqStatusId String
  cqStatus   CQStatus @relation("AllResponses", fields: [cqStatusId], references: [id], onDelete: Cascade)

  // Response content
  groundsText      String // The actual response text
  evidenceClaimIds String[] // Claims that serve as evidence
  sourceUrls       String[] // External citations

  // Workflow state
  responseStatus ResponseStatus @default(PENDING)

  // Provenance
  contributorId String // Who wrote this response (auth_id string)

  reviewedAt  DateTime?
  reviewedBy  String? // Author or moderator who approved/rejected (auth_id)
  reviewNotes String? // Why approved/rejected

  // Community validation
  upvotes      Int             @default(0)
  downvotes    Int             @default(0)
  endorsements CQEndorsement[]

  // Execution (if approved and converted to canonical move)
  canonicalMoveId String?
  executedAt      DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Back-reference for canonical selection
  canonicalFor CQStatus[] @relation("CanonicalResponse")

  // Activity log
  activities CQActivityLog[]

  @@index([cqStatusId, responseStatus])
  @@index([contributorId])
  @@index([responseStatus, createdAt])
}

enum ResponseStatus {
  PENDING // Awaiting review
  APPROVED // Accepted by author/moderator
  CANONICAL // Selected as THE official answer
  REJECTED // Not accepted
  SUPERSEDED // Was canonical, but replaced
  WITHDRAWN // Contributor removed it
}

model CQEndorsement {
  id         String     @id @default(cuid())
  responseId String
  response   CQResponse @relation(fields: [responseId], references: [id], onDelete: Cascade)

  userId String // auth_id of endorser

  weight  Int     @default(1) // Could vary by user reputation
  comment String? // Optional explanation

  createdAt DateTime @default(now())

  @@unique([responseId, userId])
  @@index([responseId])
  @@index([userId])
}

// CQ Enhancement: Explicit linkage between CQs and attacks for provenance tracking
model CQAttack {
  id        String   @id @default(cuid())
  cqStatusId String
  cqStatus  CQStatus @relation("CQAttacks", fields: [cqStatusId], references: [id], onDelete: Cascade)

  // Exactly one of these should be set
  conflictApplicationId String?
  conflictApplication   ConflictApplication? @relation(fields: [conflictApplicationId], references: [id], onDelete: Cascade)

  claimEdgeId String?
  claimEdge   ClaimEdge? @relation(fields: [claimEdgeId], references: [id], onDelete: Cascade)

  createdById String
  createdAt   DateTime @default(now())

  @@index([cqStatusId])
  @@index([conflictApplicationId])
  @@index([claimEdgeId])
}

model CQActivityLog {
  id String @id @default(cuid())

  cqStatusId String
  cqStatus   CQStatus @relation(fields: [cqStatusId], references: [id], onDelete: Cascade)

  action CQAction

  actorId String // Who performed the action (auth_id)

  responseId String? // If action relates to a specific response
  response   CQResponse? @relation(fields: [responseId], references: [id], onDelete: SetNull)

  metadata  Json? // Additional context
  createdAt DateTime @default(now())

  @@index([cqStatusId, createdAt])
  @@index([actorId])
  @@index([action, createdAt])
}

enum CQAction {
  RESPONSE_SUBMITTED
  RESPONSE_APPROVED
  RESPONSE_REJECTED
  RESPONSE_WITHDRAWN
  STATUS_CHANGED
  CANONICAL_SELECTED
  ENDORSEMENT_ADDED
  CLARIFICATION_REQUESTED
}

enum Illocution {
  Assert
  Question
  Argue
  Concede
  Retract
  Close
  Therefore
  Suppose
  Discharge
}

// If you need a simple edge model for the /api/attacks route (optional â€” skip if you already have edges):
model GraphEdge {
  id          String   @id @default(cuid())
  fromId      String
  toId        String
  type        String // 'undercut' | 'rebut'
  scope       String? // 'premise' | 'conclusion' (for rebut)
  roomId      String
  createdById String
  meta        Json? // { schemeKey, cqKey }
  createdAt   DateTime @default(now())

  @@index([roomId])
  @@index([fromId, toId])
}

model SchemeInstance {
  id          String   @id @default(cuid())
  targetType  String // 'card'|'claim'
  targetId    String
  schemeId    String
  data        Json // filled slots: {expert:{name,field}, statement, sourceUri, ...}
  createdById String
  createdAt   DateTime @default(now())

  scheme           ArgumentScheme     @relation(fields: [schemeId], references: [id], onDelete: Cascade)
  CriticalQuestion CriticalQuestion[]

  @@index([targetType, targetId])
}

model CriticalQuestion {
  id           String          @id @default(cuid())
  instanceId   String?
  schemeId     String?
  scheme       ArgumentScheme? @relation(fields: [schemeId], references: [id], onDelete: Cascade)
  cqKey        String?
  cqId         String?
  text         String
  attackKind   String // 'UNDERMINES'|'UNDERCUTS'|'REBUTS'
  status       String // 'open'|'addressed'|'counter-posted'
  openedById   String?
  resolvedById String?
  createdAt    DateTime        @default(now())
  // for automation: how the CQ maps to an attack
  attackType   AttackType? // REBUTS | UNDERCUTS | UNDERMINES
  targetScope  TargetScope? // conclusion | inference | premise
  instance     SchemeInstance? @relation(fields: [instanceId], references: [id], onDelete: Cascade)

  // NEW: Module 8 - ASPIC+ attack formalization
  // Maps this CQ to specific ASPIC+ attack parameters
  aspicMapping Json? // { ruleId?: string, premiseIndex?: number, defeasibleRuleRequired?: boolean }

  // NEW: Phase 0.1 - Burden of Proof Enhancement
  // Different CQs function differently - some shift burden, others require evidence
  burdenOfProof    BurdenOfProof @default(PROPONENT) // Who has burden to support their position
  requiresEvidence Boolean       @default(false) // Must evidence be provided or does asking suffice
  premiseType      PremiseType? // Carneades premise classification (ordinary | assumption | exception)

  @@unique([schemeId, cqKey])
  @@index([instanceId])
}

model ClaimWarrant {
  id        String   @id @default(cuid())
  claimId   String   @unique
  text      String
  createdBy String
  createdAt DateTime @default(now())
  claim     Claim    @relation(fields: [claimId], references: [id], onDelete: Cascade)
}

enum ReplyTarget {
  claim
  argument
  premise
  link
  presupposition
}

model DialogueMove {
  id         String      @id @default(cuid())
  authorId   String?
  type       String? // existing kind: ASSERT|WHY|GROUNDS|CONCEDE|RETRACT|CLOSE...
  illocution Illocution?

  deliberationId String
  targetType     String // 'argument'|'claim'
  targetId       String
  kind           String // 'ASSERT'|'WHY'|'GROUNDS'|'RETRACT'
  payload        Json?
  actorId        String
  createdAt      DateTime @default(now())

  replyToMoveId String? // explicit reply threading (nullable, backfill later)
  replyTarget   ReplyTarget? // scope of reply (nullable, backfill later)

  // add fields (null-safe for backward compat)
  polarity       String? // 'P'|'O'
  locusId        String?
  endsWithDaimon Boolean @default(false)
  argumentId     String? // GROUNDS (anchors an RA)

  signature String @db.VarChar(255)

  // Completion tracking (merged from DialogueAction)
  completed   Boolean   @default(false)
  completedAt DateTime?
  completedBy String?

  // Vote integration (merged from DialogueAction)
  votes ResponseVote[]

  // Dialogue Visualization System - Phase 1.1
  // Reverse relations for dialogue provenance tracking
  createdArguments   Argument[]                  @relation("ArgumentCreatedByMove")
  createdConflicts   ConflictApplication[]       @relation("ConflictCreatedByMove")
  introducedClaims   Claim[]                     @relation("ClaimIntroducedByMove")
  visualizationNodes DialogueVisualizationNode[] @relation("DialogueMoveVisualizationNodes")

  // Link to AIF nodes this move created (via GROUNDS, THEREFORE, etc.)
  createdAifNodes AifNode[] @relation("AifNodeCreatedBy")

  // Primary AIF node representing this move as a DM-node
  aifRepresentation String?  @unique
  aifNode           AifNode? @relation("MoveRepresentation", fields: [aifRepresentation], references: [id], onDelete: SetNull)

  // Edges caused by this dialogue move
  causedEdges AifEdge[] @relation("EdgeCausedBy")

  // Phase 2.3: Link to DebateNode (Debate Layer Modernization)
  debateNodeId String?
  debateNode   DebateNode? @relation("DialogueMoveDebateNode", fields: [debateNodeId], references: [id], onDelete: SetNull)

  @@unique([deliberationId, signature], name: "dm_unique_signature")
  @@index([deliberationId, targetType, targetId, kind, createdAt], name: "dm_by_target_kind_time")
  @@index([payload], type: Gin, name: "dm_payload_gin")
  @@index([deliberationId])
  @@index([targetType, targetId])
  @@index([completed])
}

// Dialogue Visualization System - Phase 1.1
// Represents pure dialogue moves (WHY, CONCEDE, RETRACT, etc.) that don't create Arguments/Conflicts
// These are the ONLY moves that need dedicated visualization nodes
model DialogueVisualizationNode {
  id             String   @id @default(cuid())
  deliberationId String
  dialogueMoveId String
  nodeKind       String // WHY | CONCEDE | RETRACT | CLOSE | ACCEPT_ARGUMENT
  metadata       Json? // Store move-specific data (e.g., WHY target, CONCEDE reasoning)
  createdAt      DateTime @default(now())

  dialogueMove DialogueMove @relation("DialogueMoveVisualizationNodes", fields: [dialogueMoveId], references: [id], onDelete: Cascade)

  @@unique([dialogueMoveId])
  @@index([deliberationId])
  @@index([deliberationId, nodeKind])
  @@index([deliberationId, createdAt])
}

enum ProofMode {
  symmetric
  asymmetric // stricter burden for Proponent
}

model Deliberation {
  id              String               @id @default(cuid())
  hostType        DeliberationHostType
  hostId          String
  rule            RepresentationRule   @default(utilitarian)
  k               Int                  @default(3)
  createdById     String
  createdAt       DateTime             @default(now())
  updatedAt       DateTime             @updatedAt
  cards           DeliberationCard[]
  title           String?
  AgoraRoom       AgoraRoom?           @relation(fields: [agoraRoomId], references: [id], onDelete: SetNull)
  agoraRoomId     String?
  agoraRoomID     String?
  roomId          String?
  arguments       Argument[]
  edges           ArgumentEdge[]
  approvals       ArgumentApproval[]
  selections      ViewpointSelection[]
  Issue           Issue[]
  Claim           Claim[]
  ClaimEdge       ClaimEdge[]
  Cluster         Cluster[]
  TheoryWork      TheoryWork[]
  KnowledgeEdge   KnowledgeEdge[]
  workProvenances WorkProvenance[] // For WorkProvenance.deliberation

  IssueLink IssueLink[]

  proofMode ProofMode @default(symmetric)

  // Phase 2.3: Dempster-Shafer mode toggle
  dsMode Boolean @default(false)

  // Phase 2.5: NLI threshold configuration (0.0 to 1.0)
  nliThreshold Float @default(0.5)

  tags    String[]             @default([])
  roles   DeliberationRole[]
  calls   DeliberationCall[]
  anchors DeliberationAnchor[]

  upgradedFromDiscussionId String?     @unique
  upgradedFromDiscussion   Discussion? @relation("DiscussionToDeliberation", fields: [upgradedFromDiscussionId], references: [id])

  // âœ… back-relations for StackReference (two directed edges to Deliberation)
  stackRefsFrom StackReference[] @relation("StackRefFrom")
  stackRefsTo   StackReference[] @relation("StackRefTo")

  // âœ… back-relations for ArgumentImport (two directed edges to Deliberation)
  argImportsFrom ArgumentImport[] @relation("ArgImpFrom")
  argImportsTo   ArgumentImport[] @relation("ArgImpTo")

  // âœ… back-relations for SharedAuthorRoomEdge (two directed edges to Deliberation)
  sharedAuthorsFrom SharedAuthorRoomEdge[] @relation("SharedAuthorFrom")
  sharedAuthorsTo   SharedAuthorRoomEdge[] @relation("SharedAuthorTo")

  // âœ… back-relation for NegationMap
  negationMaps NegationMap[] @relation("NegationMapDeliberation")

  DebateSheet            DebateSheet[]
  WorkSourceDeliberation WorkSourceDeliberation[]

  // Glossary system
  glossaryTerms GlossaryTerm[]
  Thesis        Thesis[]

  // KB bidirectional linking
  debateCitations DebateCitation[]

  // Dialogue Visualization System - Phase 1.1
  // AIF graph nodes and edges for this deliberation
  aifNodes AifNode[]
  aifEdges AifEdge[]

  // ASPIC+ Explicit Contraries - Phase D-1
  claimContraries ClaimContrary[]

  // ArgumentChain relations
  argumentChains ArgumentChain[]

  // Phase 2.1: Debate Releases & Versioned Memory
  releases          DebateRelease[]
  latestReleaseId   String?

  // Phase 2.2: Fork/Branch/Merge
  forkedFromId      String?
  forkedFrom        Deliberation?  @relation("DeliberationForks", fields: [forkedFromId], references: [id], onDelete: SetNull)
  forks             Deliberation[] @relation("DeliberationForks")
  forkReason        String?        @db.Text
  forkType          ForkType?
  forkedAtReleaseId String?
  
  // Phase 2.2: Imported content tracking
  importedClaims    ImportedClaim[]
  importedArguments ImportedArgument[]
  
  // Phase 2.2: Merge requests
  mergeRequests     MergeRequest[] @relation("MergeTarget")
  outgoingMerges    MergeRequest[] @relation("MergeSource")

  // Phase 2.3: Quote discussion deliberation (back-relation)
  quoteBeingDiscussed QuoteNode? @relation("QuoteDeliberation")
  
  // Phase 3.1: Claim provenance - cross-deliberation identity tracking
  claimInstances      ClaimInstance[]
  
  // Claim Prediction System
  claimPredictions    ClaimPrediction[]

  @@index([agoraRoomID])
  @@index([hostType, hostId])
  @@index([roomId])
  @@index([forkedFromId])
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Phase 2.1: Debate Releases & Versioned Memory
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

model DebateRelease {
  id                    String   @id @default(cuid())
  deliberationId        String
  deliberation          Deliberation @relation(fields: [deliberationId], references: [id], onDelete: Cascade)
  
  // Version info (semantic versioning)
  version               String   // "1.0.0", "1.1.0", etc.
  major                 Int      // For easy querying
  minor                 Int
  patch                 Int
  
  // Content
  title                 String
  summary               String?  @db.Text
  releaseNotes          String?  @db.Text
  
  // Snapshots (JSON for flexibility)
  claimSnapshot         Json     // Full claim state at release
  argumentSnapshot      Json     // Full argument state at release
  statsSnapshot         Json     // Summary statistics
  
  // Changelog
  changelogFromPrevious Json?    // Diff from previous version
  changelogText         String?  @db.Text  // Human-readable changelog
  previousReleaseId     String?
  previousRelease       DebateRelease? @relation("ReleaseChain", fields: [previousReleaseId], references: [id], onDelete: SetNull)
  nextReleases          DebateRelease[] @relation("ReleaseChain")
  
  // Citation
  citationUri           String?  @unique  // Stable URI for citation
  doi                   String?  @unique  // Optional DOI
  bibtex                String?  @db.Text  // Pre-generated BibTeX
  
  // Metadata
  releasedById          String
  releasedAt            DateTime @default(now())
  isLatest              Boolean  @default(true)
  
  @@unique([deliberationId, version])
  @@index([deliberationId])
  @@index([releasedAt])
  @@index([isLatest])
}

model DeliberationAnchor {
  id String @id @default(cuid())

  deliberationId String
  deliberation   Deliberation @relation(fields: [deliberationId], references: [id], onDelete: Cascade)

  targetType   String // 'stack' | 'stack:item' | 'article' | 'comment' | 'selection' | 'image' | 'video'
  targetId     String? // id when applicable
  selectorJson Json? // W3C Web Annotation selectors, media fragments (#t=), bbox, etc.
  title        String?
  snippet      String?
  createdById  String
  createdAt    DateTime @default(now())
  // Optional: avoid duplicate anchors per target
  // @@unique([deliberationId, targetType, targetId])

  @@index([deliberationId])
  @@index([targetType, targetId])
  @@index([createdById])
}

model DeliberationRole {
  id             String   @id @default(cuid())
  deliberationId String
  userId         String
  role           String // 'author'|'methodologist'|'practitioner'|â€¦
  invitedById    String?
  createdAt      DateTime @default(now())

  deliberation Deliberation @relation(fields: [deliberationId], references: [id], onDelete: Cascade)

  @@unique([deliberationId, userId, role])
  @@index([deliberationId, role])
}

model DeliberationCall {
  id             String    @id @default(cuid())
  deliberationId String
  description    String
  deadline       DateTime?
  rolesNeeded    String[]  @default([]) // ['methodologist','domain-expert']
  createdById    String
  createdAt      DateTime  @default(now())

  deliberation Deliberation @relation(fields: [deliberationId], references: [id], onDelete: Cascade)

  @@index([deliberationId, createdAt])
}

model DeliberationPref {
  deliberationId   String   @id
  profile          String // 'community' | 'policy' | 'scientific'
  minRelevance     Float    @default(0.5)
  minSufficiency   Float    @default(0.5)
  minAcceptability Float    @default(0.5)
  updatedAt        DateTime @updatedAt
  createdAt        DateTime @default(now())
}

model Value {
  id          String       @id @default(cuid())
  key         String       @unique
  label       String
  // ADD THIS:
  claimValues ClaimValue[] // <â€” opposite side for ClaimValue.value
}

model ClaimValue {
  claimId String
  valueId String
  weight  Int    @default(1)

  claim Claim @relation(fields: [claimId], references: [id], onDelete: Cascade)
  value Value @relation(fields: [valueId], references: [id], onDelete: Cascade)

  @@id([claimId, valueId])
  @@index([valueId])
}

model AudiencePreference {
  id        String   @id @default(cuid())
  ownerType String // 'user'|'room'|'cohort'
  ownerId   String
  order     String // e.g. "Fairness>Autonomy>Efficiency"
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([ownerType, ownerId])
}

model CareLedger {
  id        String   @id @default(cuid())
  userId    String
  delta     Int
  reason    String // 'bridge_completed'|'synthesis_accepted'|...
  refType   String // 'assignment'|'bounty'
  refId     String
  createdAt DateTime @default(now())

  @@index([userId, createdAt])
}

model Commitment {
  id             String   @id @default(cuid())
  deliberationId String
  participantId  String
  proposition    String   @db.Text
  isRetracted    Boolean  @default(false)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@unique([deliberationId, participantId, proposition])
  @@index([deliberationId, participantId])
}

// ----- commitment-ludics mapping -----
model CommitmentLudicMapping {
  id String @id @default(cuid())

  // Dialogue commitment reference
  dialogueCommitmentId String
  deliberationId       String
  participantId        String
  proposition          String @db.Text

  // Ludics commitment reference
  ludicCommitmentElementId String
  ludicOwnerId             String
  ludicLocusId             String

  // Metadata
  promotedAt      DateTime @default(now())
  promotedBy      String // userId who clicked promote
  promotionContext Json? // Additional context (e.g., which panel)

  // Relations
  ludicCommitmentElement LudicCommitmentElement @relation(fields: [ludicCommitmentElementId], references: [id], onDelete: Cascade)

  @@unique([dialogueCommitmentId, ludicCommitmentElementId])
  @@index([deliberationId, participantId])
  @@index([ludicOwnerId])
}

// ----- bounties -----
model Bounty {
  id          String             @id @default(cuid())
  roomId      String
  type        String // 'synthesis' | 'source' | 'replication' | 'bridge'
  title       String
  brief       String
  rewardCare  Int
  status      String             @default("open")
  opensAt     DateTime?
  closesAt    DateTime?
  createdAt   DateTime           @default(now())
  // ADD THIS:
  submissions BountySubmission[] // <â€” opposite side
}

model BountySubmission {
  id             String   @id @default(cuid())
  bountyId       String
  submitterId    String
  submissionType String // 'card'|'brief'|'claim'
  submissionId   String
  status         String   @default("submitted")
  createdAt      DateTime @default(now())

  bounty Bounty @relation(fields: [bountyId], references: [id], onDelete: Cascade)
}

/// ====== Theory Models ======

enum PhilosophyTheoryType {
  DN // Descriptiveâ€“Nomological
  IH // Idealizingâ€“Hermeneutic
  TC // Technicalâ€“Constructive
  OP // Onticâ€“Practical
}

enum WorkStatus {
  DRAFT
  ACTIVE
  PUBLISHED
  ARCHIVED
}

model TheoryWork {
  id             String               @id @default(cuid())
  slug           String               @unique
  title          String
  authorId       String
  theoryType     PhilosophyTheoryType
  summary        String?              @db.Text
  body           String               @db.Text
  standardOutput String?

  // â†“ Decouple: deliberation is provenance, not container
  deliberationId String? // was required â†’ optional
  deliberation   Deliberation? @relation(fields: [deliberationId], references: [id], onDelete: SetNull)

  // âœ… ADD ALL THESE BACK-RELATIONS:
  claims                 TheoryWorkClaim[] // Line 3614 error
  ihProject              WorkIhProject? // Line 3630 error
  dnProject              WorkDnProject? // Line 3648 error
  tcProject              WorkTcProject? // Line 3657 error
  opProject              WorkOpProject? // Line 3665 error
  dnStructure            WorkDNStructure? // Line 3676 error
  ihTheses               WorkIHTheses? // Line 3686 error
  tcTheses               WorkTCTheses? // Line 3696 error
  opTheses               WorkOPTheses? // Line 3705 error
  provenances            WorkProvenance[] // Line 3724 error
  practicalJustification WorkPracticalJustification? @relation("Work_to_Practical")
  hermeneuticProject     WorkHermeneuticProject?     @relation("Work_to_HermeneuticProject")
  pascalModel            WorkPascalModel?            @relation("Work_to_PascalModel")

  rules Rule[] // Line 3797 error

  // NEW: KB anchoring
  kbPageId String?
  kbPage   KbPage? @relation(fields: [kbPageId], references: [id])

  // Integrity & publication
  integrityChecks Json? // dn/ih/tc/op adequacy payloads + mcda snapshot refs
  integrityValid  Boolean    @default(false)
  status          WorkStatus @default(DRAFT)
  visibility      String     @default("room")
  publishedAt     DateTime?
  lastExport      Json?

  // Existing 1:1s unchanged (dn/tc/op/ihâ€¦), snapshots, practicalJustification etc.

  // NEW: citations bridge (polymorphic targets)
  citations TheoryWorkCitation[]

  createdAt              DateTime                 @default(now())
  updatedAt              DateTime                 @updatedAt
  WorkSourceDeliberation WorkSourceDeliberation[]

  @@index([kbPageId])
  @@index([authorId, createdAt])
}

/// Bridge: a Work can cite claims, arguments, propositions, and other works
model TheoryWorkCitation {
  id         String   @id @default(cuid())
  workId     String
  targetType String // 'claim' | 'argument' | 'proposition' | 'work'
  targetId   String
  section    String? // optional: where in the Work was it used
  role       String // 'premise' | 'evidence' | 'example' | 'counterpoint' | 'reference' | 'thesis'
  note       String?
  createdAt  DateTime @default(now())
  kbPageId   String?
  kbPage     KbPage?  @relation(fields: [kbPageId], references: [id])

  work TheoryWork @relation(fields: [workId], references: [id], onDelete: Cascade)

  @@unique([workId, targetType, targetId, section])
  @@index([kbPageId])
  @@index([targetType, targetId])
}

/// Optional: track additional source deliberations beyond the Work's home one
model WorkSourceDeliberation {
  workId         String
  deliberationId String
  role           String   @default("source") // 'source' | 'context' | ...
  createdAt      DateTime @default(now())

  work         TheoryWork   @relation(fields: [workId], references: [id], onDelete: Cascade)
  deliberation Deliberation @relation(fields: [deliberationId], references: [id], onDelete: Cascade)

  @@id([workId, deliberationId])
  @@index([deliberationId])
}

model TheoryWorkClaim {
  id      String     @id @default(cuid())
  workId  String
  claimId String
  role    String // 'thesis'|'premise'|'exception'|'application'|'counter' etc.
  order   Int        @default(0)
  work    TheoryWork @relation(fields: [workId], references: [id], onDelete: Cascade)

  @@unique([workId, claimId, role])
  @@index([claimId])
}

model WorkIhProject {
  workId              String     @id
  practiceDescription String?
  idealStandard       String? // TIH9 seed
  methodNotes         String?
  // NEW: explicit reasons
  subjectiveReasons   Json? // [{source, agent, reason, evidenceIds[]}]
  objectiveReasons    Json? // [{criterion, evaluation, warrant}]
  corroborationJson   Json?
  applicationsJson    Json?
  TheoryWork          TheoryWork @relation(fields: [workId], references: [id])
}

model WorkDnProject {
  workId           String     @id
  definitionsJson  Json?
  axiomsJson       Json?
  theoremsJson     Json?
  confirmingJson   Json? // link to claim/evidence ids
  // NEW: first-class DN5 scoring on GDN*
  optimalityJson   Json? // {
  //   coherence:{ok:boolean, notes:string},  // GDN1
  //   confirmation:{ok:boolean, refs:[]},    // GDN2
  //   noFalsification:{status:'none'|'minor'|'serious'}, // GDN3
  //   simplicity:{ontological:number, semantic:number}, // GDN4-5
  //   scope:number, connectivity:number, predictivePower:number // GDN6-8
  // }
  applicationsJson Json?
  TheoryWork       TheoryWork @relation(fields: [workId], references: [id])
}

model WorkTcProject {
  workId                 String     @id
  structureDescription   String?
  functionDescription    String?
  explanationFunctioning String?
  applicationsJson       Json? // {context, howToUse, expectedOutcomes}
  TheoryWork             TheoryWork @relation(fields: [workId], references: [id])
}

model WorkOpProject {
  workId                         String     @id
  unrecognizabilityJustification String? // TOP2
  // TOP3: link to Pascal.propositions/actions/utilities already stored
  alternativesJson               Json? // aliased to pascal.propositions (optional copy)
  TheoryWork                     TheoryWork @relation(fields: [workId], references: [id])
}

model WorkDNStructure {
  id             String  @id @default(cuid())
  workId         String  @unique
  // TDN*: keep it simple and explicit
  explanandum    String? // phenomenon described
  nomological    String? // laws/regularities
  ceterisParibus String?

  work TheoryWork @relation(fields: [workId], references: [id], onDelete: Cascade)
}

model WorkIHTheses {
  id          String  @id @default(cuid())
  workId      String  @unique
  structure   String? // TIH: structure
  function    String? // TIH: function
  objectivity String? // TIH: objectivity

  work TheoryWork @relation(fields: [workId], references: [id], onDelete: Cascade)
}

model WorkTCTheses {
  id                 String   @id @default(cuid())
  workId             String   @unique
  instrumentFunction String? // TTC: function
  explanation        String? // TTC: explanation
  applications       String[] // TTC: applications

  work TheoryWork @relation(fields: [workId], references: [id], onDelete: Cascade)
}

model WorkOPTheses {
  id                String   @id @default(cuid())
  workId            String   @unique
  unrecognizability String? // TOP: unrecognizability
  alternatives      String[] // TOP: considered alts (labels)

  work TheoryWork @relation(fields: [workId], references: [id], onDelete: Cascade)
}

model TheoryWorkSnapshot {
  id        String   @id @default(cuid())
  workId    String
  kind      String // 'sheet'|'kb'|'aif'
  payload   Json // frozen expansion (claims, edges, CQ stats, evidence)
  createdAt DateTime @default(now())

  @@index([workId, createdAt])
}

model WorkProvenance {
  id             String   @id @default(cuid())
  workId         String
  deliberationId String
  role           String // 'source' | 'context'
  createdAt      DateTime @default(now())

  work         TheoryWork   @relation(fields: [workId], references: [id], onDelete: Cascade)
  deliberation Deliberation @relation(fields: [deliberationId], references: [id], onDelete: Cascade)

  @@unique([workId, deliberationId, role])
  @@index([deliberationId])
}

model WorkPracticalJustification {
  id        String     @id @default(cuid())
  workId    String     @unique
  purpose   String     @default("")
  criteria  Json       @default("[]")
  options   Json       @default("[]")
  scores    Json       @default("{}")
  result    Json       @default("{}")
  // NEW:
  adequacy  Json       @default("{}") // { completeness:true|false, dominance:'none'|'weak'|'strong', robustness:{sensitivityNotes:string} }
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  work      TheoryWork @relation("Work_to_Practical", fields: [workId], references: [id], onDelete: Cascade)
}

/// ========= IH (interpretive phase) =========
model WorkHermeneuticProject {
  id           String   @id @default(cuid())
  workId       String   @unique
  corpusUrl    String?
  facts        Json     @default("[]")
  hypotheses   Json     @default("[]")
  plausibility Json     @default("[]")
  selectedIds  Json     @default("[]")
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // child owns FK and declares fields/references + SAME relation name
  work TheoryWork @relation("Work_to_HermeneuticProject", fields: [workId], references: [id], onDelete: Cascade)
}

/// ========= OP (Pascal-as-if) =========
model WorkPascalModel {
  id                    String     @id @default(cuid())
  workId                String     @unique
  propositions          Json       @default("[]") // worlds
  actions               Json       @default("[]")
  utilities             Json       @default("{}")
  assumption            String? // notes
  // NEW:
  exhaustiveExclusive   Boolean? // PP1/TOP3
  noTheoreticalEvidence Boolean? // PP3/TOP2
  orientationCriteria   String? // what counts as 'orientation-relevant' (TOP4)
  decision              Json       @default("{}") // include method + laplace details
  createdAt             DateTime   @default(now())
  updatedAt             DateTime   @updatedAt
  work                  TheoryWork @relation("Work_to_PascalModel", fields: [workId], references: [id], onDelete: Cascade)
}

// (optional) history table if you want revisions now
model WorkPracticalRevision {
  id        String   @id @default(cuid())
  workId    String
  snapshot  Json // entire justification row at save time
  createdAt DateTime @default(now())

  @@index([workId, createdAt])
}

model Rule {
  id     String     @id @default(cuid())
  workId String
  kind   String // 'STRICT' | 'DEFEASIBLE'
  head   String // x
  body   String // y1 & ... & yn
  meta   Json?
  work   TheoryWork @relation(fields: [workId], references: [id], onDelete: Cascade)
}

model ReasonPair {
  id             String   @id @default(cuid())
  deliberationId String
  claimId        String
  reasonId       String // could point to a Claim, or a literal string y
  stance         String // 'FOR'|'AGAINST'|'NOT_FOR'|'NOT_AGAINST'
  strong         Boolean? // true if (Â¬y âˆ¨ x) holds (LA strong link)
  meta           Json?
  createdAt      DateTime @default(now())
}

/// =========================
/// Aux: Knowledge / NLI / Eristic
/// =========================

enum KnowledgeEdgeKind {
  SUPPLIES_PREMISE
  REVISES
  CHALLENGES
  SUPPORTS
  REBUTS
  UNDERCUTS
  UNDERMINES
  ALTERNATIVE_TO
  EVALUATES
  REASON_FOR
  REASON_AGAINST
  NOT_REASON_FOR // Â¬(x, y)
  NOT_REASON_AGAINST // Â¬(Â¬x, y)
  CONCLUSIVE_ABOUT // (x, y) âˆ¨ (Â¬x, y)
  INCONCLUSIVE_ABOUT
  ENTAILS // strong link (Â¬y âˆ¨ x, >)
}

model KnowledgeEdge {
  id             String            @id @default(cuid())
  deliberationId String
  kind           KnowledgeEdgeKind
  meta           Json?
  fromWorkId     String?
  toWorkId       String?
  fromClaimId    String?
  toClaimId      String?
  createdAt      DateTime          @default(now())

  deliberation Deliberation @relation(fields: [deliberationId], references: [id], onDelete: Cascade)

  @@unique([deliberationId, kind, fromWorkId, toWorkId])
  @@index([deliberationId, kind, createdAt])
  @@index([fromWorkId, toWorkId])
  @@index([fromClaimId, toClaimId])
}

model NLILink {
  id          String   @id @default(cuid())
  fromId      String?
  toId        String?
  relation    String
  score       Float
  createdById String?
  createdAt   DateTime @default(now())

  @@index([fromId, toId])
  @@index([relation, score])
}

model EristicMark {
  id             String   @id @default(cuid())
  deliberationId String
  targetType     String
  targetId       String
  tactic         String
  detector       String
  strength       Float    @default(0)
  createdById    String?
  createdAt      DateTime @default(now())

  @@index([deliberationId, targetType, targetId])
}

/// =========================
/// Ludics: enums
/// =========================
enum LudicPolarity {
  P
  O
  DAIMON
}

enum LudicActKind {
  PROPER
  DAIMON
}

enum LudicTraceStatus {
  ONGOING
  CONVERGENT
  DIVERGENT
}

/// =========================
/// Ludics: core models
/// =========================

model LudicLocus {
  id              String       @id @default(cuid())
  dialogueId      String? // NEW: scope by dialogue to avoid global "0" clashes
  path            String       @db.VarChar(255)
  parentId        String?
  parent          LudicLocus?  @relation("LocusChildren", fields: [parentId], references: [id])
  children        LudicLocus[] @relation("LocusChildren")
  createdByTurnId String?
  extJson         Json?

  // existing back-relations...
  faxFrom                LudicFaxMap[]            @relation("FaxFrom")
  faxTo                  LudicFaxMap[]            @relation("FaxTo")
  LudicDesign            LudicDesign[]
  LudicAct               LudicAct[]
  LudicCommitmentElement LudicCommitmentElement[]

  @@unique([dialogueId, path]) // âœ… was: @unique on path; now scoped
  @@index([dialogueId, path])
}

model LudicDesign {
  id             String     @id @default(cuid())
  deliberationId String
  participantId  String
  rootLocusId    String
  rootLocus      LudicLocus @relation(fields: [rootLocusId], references: [id])
  semantics      String     @default("ludics-v1")
  hasDaimon      Boolean    @default(false)
  version        Int        @default(1)
  extJson        Json?

  // Scoped Designs Architecture (Phase 1)
  scope         String? // 'topic:<id>' | 'actors:<id1>:<id2>' | 'argument:<id>' | null (legacy)
  scopeType     String? // 'topic' | 'actor-pair' | 'argument' | null
  scopeMetadata Json?   // { label, actors, topicId, argumentId, moveCount, ... }

  // Phase 4: Cross-Scope References (Delocation)
  referencedScopes String[] @default([]) // List of scope keys this design references (e.g., ["topic:arg_123", "topic:arg_456"])
  crossScopeActIds String[] @default([]) // Act IDs that use delocation (fax) to import from other scopes

  chronicles LudicChronicle[]
  acts       LudicAct[]

  // traces (already fixed)
  tracesAsPos LudicTrace[] @relation("Trace_Pos")
  tracesAsNeg LudicTrace[] @relation("Trace_Neg")

  // â¬‡ï¸ add this (implicit M:N back-relation)
  commitmentElements LudicCommitmentElement[]

  // DDS Phase 1: Views and Disputes
  views            LudicView[]    @relation("DesignViews")
  positiveDisputes LudicDispute[] @relation("PositiveDisputes")
  negativeDisputes LudicDispute[] @relation("NegativeDisputes")

  // DDS Phase 2: Strategies
  strategies       LudicStrategy[] @relation("DesignStrategies")

  // DDS Phase 3: Correspondences
  correspondences  LudicCorrespondence[] @relation("DesignCorrespondences")
  disputeCache     LudicDisputeCache?    @relation("DesignDisputeCache")

  @@index([deliberationId, participantId])
  @@index([deliberationId, scope]) // NEW: Query designs by scope
  @@index([deliberationId, scopeType]) // NEW: Query by scope type
  @@index([deliberationId, participantId, scope]) // NEW: Find P/O pair for scope
}

model LudicAct {
  id       String      @id @default(cuid())
  designId String
  design   LudicDesign @relation(fields: [designId], references: [id])

  kind     LudicActKind
  polarity LudicPolarity?
  locusId  String?
  locus    LudicLocus?    @relation(fields: [locusId], references: [id])

  ramification String[] // allowed next sub-addresses
  expression   String?
  metaJson     Json?
  isAdditive   Boolean  @default(false)

  orderInDesign  Int
  extJson        Json?
  LudicChronicle LudicChronicle[]

  // Ludics integration (Phase 1) - back-relation to AIF
  aifNode AifNode?

  @@index([designId, orderInDesign])
  @@index([locusId])
  @@index([designId, locusId])
}

model LudicChronicle {
  id       String      @id @default(cuid())
  designId String
  design   LudicDesign @relation(fields: [designId], references: [id])
  order    Int
  actId    String
  act      LudicAct    @relation(fields: [actId], references: [id])
}

model LudicTrace {
  id                            String           @id @default(cuid())
  deliberationId                String
  posDesignId                   String
  negDesignId                   String
  startLocusId                  String?
  steps                         Json
  status                        LudicTraceStatus
  endedAtDaimonForParticipantId String?
  createdAt                     DateTime         @default(now())
  extJson                       Json?

  posDesign LudicDesign @relation("Trace_Pos", fields: [posDesignId], references: [id])
  negDesign LudicDesign @relation("Trace_Neg", fields: [negDesignId], references: [id])

  @@index([deliberationId, createdAt])
  @@index([posDesignId])
  @@index([negDesignId])
}

model LudicCommitmentElement {
  id           String     @id @default(cuid())
  ownerId      String
  basePolarity String // 'pos' | 'neg'
  baseLocusId  String
  baseLocus    LudicLocus @relation(fields: [baseLocusId], references: [id])
  label        String?
  entitled     Boolean?   @default(true) // ðŸ‘ˆ NEW

  extJson Json?

  // â¬‡ï¸ implicit M:N (no @relation name needed)
  designs                LudicDesign[]
  LudicCommitmentState   LudicCommitmentState? @relation(fields: [ludicCommitmentStateId], references: [id])
  ludicCommitmentStateId String?
  
  // Reverse relation for commitment-ludics mapping
  commitmentMappings     CommitmentLudicMapping[]

  @@index([ownerId, basePolarity])
}

model LudicCommitmentState {
  id        String   @id @default(cuid())
  ownerId   String
  updatedAt DateTime @default(now())
  extJson   Json?

  elements LudicCommitmentElement[]

  @@index([ownerId])
}

model LudicFaxMap {
  id          String   @id @default(cuid())
  fromLocusId String
  toLocusId   String
  createdBy   String?
  createdAt   DateTime @default(now())
  extJson     Json?

  from LudicLocus @relation("FaxFrom", fields: [fromLocusId], references: [id])
  to   LudicLocus @relation("FaxTo", fields: [toLocusId], references: [id])
}

/// =========================
/// DDS (Designs, Disputes, Strategies) - Phase 1
/// Based on Faggian & Hyland (2002)
/// =========================

/// LudicView - First-class view representation
/// Views are what a player "sees" at any point in the interaction
model LudicView {
  id              String       @id @default(cuid())
  designId        String
  design          LudicDesign  @relation("DesignViews", fields: [designId], references: [id], onDelete: Cascade)
  player          String       // "P" | "O"
  viewSequence    Json         // Array of actions in view: { focus, ramification, polarity, actId? }[]
  parentDisputeId String?
  parentDispute   LudicDispute? @relation("DisputeViews", fields: [parentDisputeId], references: [id], onDelete: SetNull)
  extJson         Json?
  createdAt       DateTime     @default(now())

  @@index([designId, player])
  @@index([parentDisputeId])
}

/// LudicDispute - First-class dispute representation
/// Disputes are interactions between a positive (P) and negative (O) design
model LudicDispute {
  id              String          @id @default(cuid())
  deliberationId  String
  posDesignId     String
  posDesign       LudicDesign     @relation("PositiveDisputes", fields: [posDesignId], references: [id], onDelete: Cascade)
  negDesignId     String
  negDesign       LudicDesign     @relation("NegativeDisputes", fields: [negDesignId], references: [id], onDelete: Cascade)
  actionPairs     Json            // Array of {posActId, negActId, locusPath, ts?}
  status          LudicDisputeStatus @default(ONGOING)
  length          Int             @default(0)
  isLegal         Boolean?        // Cached legality check result
  legalityLog     Json?           // Details of legality validation
  extJson         Json?
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  views           LudicView[]     @relation("DisputeViews")
  positions       LudicPosition[] @relation("DisputePositions")

  @@index([deliberationId])
  @@index([posDesignId, negDesignId])
  @@index([status])
}

enum LudicDisputeStatus {
  ONGOING
  CONVERGENT
  DIVERGENT
  STUCK
}

/// LudicPosition - Legal position in a dispute
/// A position is a sequence of actions satisfying legality conditions
model LudicPosition {
  id              String        @id @default(cuid())
  disputeId       String?
  dispute         LudicDispute? @relation("DisputePositions", fields: [disputeId], references: [id], onDelete: SetNull)
  sequence        Json          // Ordered action sequence
  isLinear        Boolean       @default(true)   // No address appears twice
  isParity        Boolean       @default(true)   // Polarity alternates
  isJustified     Boolean       @default(true)   // Each move justified
  isVisible       Boolean       @default(true)   // Justifier in view
  isLegal         Boolean       @default(false)  // All conditions satisfied
  player          String        // "P" | "O" - whose turn is next
  validationLog   Json?         // Details of validation checks
  extJson         Json?
  createdAt       DateTime      @default(now())

  @@index([disputeId])
  @@index([isLegal])
}

model LudicBehaviour {
  id             String   @id @default(cuid())
  deliberationId String // scope to a dialogue
  base           String // e.g., "âŠ¢ Î¾" or "Î¾ âŠ¢"
  polarity       String // 'positive' | 'negative'
  regular        Boolean? // computed flag
  uniformBound   Int? // if known/claimed
  createdAt      DateTime @default(now())

  // Membership (incarnation)
  materialDesigns LudicMaterialDesign[]
}

model LudicMaterialDesign {
  id               String          @id @default(cuid())
  behaviourId      String
  designId         String // FK to your existing ludicDesign
  asOfStepId       String? // provenance
  pathsJson        Json // positive-ended chronicles for this material design
  LudicBehaviour   LudicBehaviour? @relation(fields: [ludicBehaviourId], references: [id])
  ludicBehaviourId String?
}

model LudicDecisionReceipt {
  id             String   @id @default(cuid())
  deliberationId String
  kind           String // 'epistemic' | 'procedural' | 'allocative' | 'editorial'
  subjectType    String // 'claim' | 'locus' | 'view' | 'option' | 'card'
  subjectId      String
  issuedBy       String // 'system' | 'panel:<userId>' | 'vote'
  rationale      String?  @db.Text
  inputsJson     Json // AF labels, CQ summary, tally, RV, ludics trace id, etc.
  version        Int      @default(1)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@index([deliberationId, subjectType, subjectId])
}

// =============================================================================
// DDS Phase 2: Strategy Layer (Strategies, Innocence, Propagation)
// Based on Faggian & Hyland (2002) - Definitions 4.8, 4.10, 4.11, 4.25
// =============================================================================

/// LudicStrategy - First-class strategy representation
/// A strategy is a set of plays (positions) that determines responses to opponent moves
model LudicStrategy {
  id                   String               @id @default(cuid())
  designId             String
  design               LudicDesign          @relation("DesignStrategies", fields: [designId], references: [id], onDelete: Cascade)
  player               String               // "P" | "O"
  isInnocent           Boolean              @default(false)
  satisfiesPropagation Boolean              @default(false)
  playCount            Int                  @default(0)
  extJson              Json?                // Stores: determinism map, saturation info
  createdAt            DateTime             @default(now())
  updatedAt            DateTime             @updatedAt

  plays                LudicPlay[]          @relation("StrategyPlays")
  viewCache            LudicStrategyView[]  @relation("StrategyViews")
  innocenceCheck       LudicInnocenceCheck? @relation("StrategyInnocence")
  propagationCheck     LudicPropagationCheck? @relation("StrategyPropagation")

  // DDS Phase 3: Correspondences
  correspondences      LudicCorrespondence[] @relation("StrategyCorrespondences")
  chronicleCache       LudicChronicleCache?  @relation("StrategyChronicleCache")

  @@unique([designId, player])
  @@index([isInnocent, satisfiesPropagation])
}

/// LudicPlay - Individual play in a strategy
/// A play is a sequence of actions representing one complete interaction path
model LudicPlay {
  id           String             @id @default(cuid())
  strategyId   String
  strategy     LudicStrategy      @relation("StrategyPlays", fields: [strategyId], references: [id], onDelete: Cascade)
  sequence     Json               // Array of actions: {focus, ramification, polarity, actId?}[]
  length       Int                @default(0)
  isPositive   Boolean            // Ends on player's own polarity
  viewId       String?            // Cached view reference
  view         LudicStrategyView? @relation("PlayView", fields: [viewId], references: [id], onDelete: SetNull)
  extJson      Json?
  createdAt    DateTime           @default(now())

  @@index([strategyId])
  @@index([isPositive])
}

/// LudicStrategyView - Views in strategy (for view-stability check)
/// Views(S) is the set of all player views extracted from plays
model LudicStrategyView {
  id             String        @id @default(cuid())
  strategyId     String
  strategy       LudicStrategy @relation("StrategyViews", fields: [strategyId], references: [id], onDelete: Cascade)
  viewSequence   Json          // Array of actions in view
  determinedMove Json?         // Next move determined by this view (for determinism)
  playCount      Int           @default(0) // How many plays have this view
  extJson        Json?
  createdAt      DateTime      @default(now())

  plays          LudicPlay[]   @relation("PlayView")

  @@index([strategyId])
}

/// LudicInnocenceCheck - Cached innocence validation result
/// A strategy is innocent if: same view â†’ same response (Definition 4.8)
model LudicInnocenceCheck {
  id              String        @id @default(cuid())
  strategyId      String        @unique
  strategy        LudicStrategy @relation("StrategyInnocence", fields: [strategyId], references: [id], onDelete: Cascade)
  isInnocent      Boolean
  isDeterministic Boolean       // sÌ„b, sÌ„c âˆˆ Sâ€  âŸ¹ b = c
  isViewStable    Boolean       // Views(S) âŠ† S
  violationLog    Json?         // Details of violations if not innocent
  checkedAt       DateTime      @default(now())

  @@index([isInnocent])
}

/// LudicPropagationCheck - Cached propagation validation result
/// Propagation: same prefix â†’ same addresses (Definition 4.25)
model LudicPropagationCheck {
  id            String        @id @default(cuid())
  strategyId    String        @unique
  strategy      LudicStrategy @relation("StrategyPropagation", fields: [strategyId], references: [id], onDelete: Cascade)
  satisfiesProp Boolean
  violations    Json?         // Details of propagation failures
  checkedAt     DateTime      @default(now())

  @@index([satisfiesProp])
}

// =============================================================================
// DDS Phase 3: Correspondences & Isomorphisms
// Based on Faggian & Hyland (2002) - Propositions 4.18 and 4.27
// =============================================================================

/// LudicCorrespondence - Cached correspondence mapping between design and strategy
/// Records verified Design â†” Strategy correspondences
model LudicCorrespondence {
  id                 String                    @id @default(cuid())
  designId           String
  design             LudicDesign               @relation("DesignCorrespondences", fields: [designId], references: [id], onDelete: Cascade)
  strategyId         String
  strategy           LudicStrategy             @relation("StrategyCorrespondences", fields: [strategyId], references: [id], onDelete: Cascade)
  correspondenceType String                    // "design-to-strategy" | "strategy-to-design"
  isVerified         Boolean                   @default(false)
  isomorphisms       Json                      // Which isomorphisms hold: {playsViews, viewsPlays, dispCh, chDisp}
  createdAt          DateTime                  @default(now())
  updatedAt          DateTime                  @updatedAt

  isomorphismChecks  LudicIsomorphismCheck[]   @relation("CorrespondenceIsomorphisms")

  @@unique([designId, strategyId])
  @@index([isVerified])
}

/// LudicIsomorphismCheck - Cached isomorphism validation result
/// One of four isomorphisms: plays-views, views-plays, disp-ch, ch-disp
model LudicIsomorphismCheck {
  id               String              @id @default(cuid())
  correspondenceId String
  correspondence   LudicCorrespondence @relation("CorrespondenceIsomorphisms", fields: [correspondenceId], references: [id], onDelete: Cascade)
  isomorphismType  String              // "plays-views" | "views-plays" | "disp-ch" | "ch-disp"
  holds            Boolean
  evidence         Json?               // Proof/counterexample details
  checkedAt        DateTime            @default(now())

  @@unique([correspondenceId, isomorphismType])
  @@index([holds])
}

/// LudicDisputeCache - Precomputed disputes for Disp(D) operation
/// Caches all disputes of a design with orthogonal counter-designs
model LudicDisputeCache {
  id           String      @id @default(cuid())
  designId     String      @unique
  design       LudicDesign @relation("DesignDisputeCache", fields: [designId], references: [id], onDelete: Cascade)
  allDisputes  Json        // Array of all disputes Disp(D)
  disputeCount Int         @default(0)
  computedAt   DateTime    @default(now())
}

/// LudicChronicleCache - Precomputed chronicles for Ch(S) operation
/// Caches all chronicles extracted from strategy
model LudicChronicleCache {
  id             String        @id @default(cuid())
  strategyId     String        @unique
  strategy       LudicStrategy @relation("StrategyChronicleCache", fields: [strategyId], references: [id], onDelete: Cascade)
  allChronicles  Json          // Array of all chronicles Ch(S)
  chronicleCount Int           @default(0)
  computedAt     DateTime      @default(now())
}

// =============================================================================
// DDS Phase 5 Part 1: Orthogonality & Behaviours
// Based on Faggian & Hyland (2002) - Definition 6.1, biorthogonal closure
// =============================================================================

/// LudicOrthogonalityCheck - Cached orthogonality check between strategies
/// Two strategies S, T are orthogonal (S âŠ¥ T) if all disputes converge
model LudicOrthogonalityCheck {
  id             String   @id @default(cuid())
  strategyAId    String
  strategyBId    String
  isOrthogonal   Boolean
  reason         String?
  counterDesigns Json?    // Counter-examples if not orthogonal
  checkedAt      DateTime @default(now())

  @@unique([strategyAId, strategyBId])
  @@index([isOrthogonal])
}

/// LudicBiorthogonalClosure - Biorthogonal closure computation (DâŠ¥âŠ¥)
/// The smallest behaviour containing a set of designs
model LudicBiorthogonalClosure {
  id             String   @id @default(cuid())
  deliberationId String
  inputDesignIds Json     // Array of input design IDs
  closureIds     Json     // Array of design IDs in closure
  iterations     Int      @default(0)
  reachedFixpoint Boolean @default(false)
  computedAt     DateTime @default(now())

  @@index([deliberationId])
  @@index([reachedFixpoint])
}

/// LudicGame - Game constructed from behaviour pair (A, AâŠ¥)
/// Games are pairs of mutually orthogonal behaviours
model LudicGame {
  id             String   @id @default(cuid())
  deliberationId String
  name           String?
  positiveBehaviourId String
  negativeBehaviourId String
  arenaJson      Json?    // Arena structure: {Î“, Î›, Î»}
  positionsJson  Json?    // Legal positions in game
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@index([deliberationId])
}

/// LudicGamePosition - Position in a game (legal or not)
model LudicGamePosition {
  id          String   @id @default(cuid())
  gameId      String
  sequence    Json     // Action sequence reaching this position
  isLegal     Boolean  @default(false)
  player      String   // "P" | "O" - whose turn
  validMoves  Json?    // Available moves from this position
  createdAt   DateTime @default(now())

  @@index([gameId])
  @@index([isLegal])
}

// =============================================================================
// DDS Phase 5 Part 2: Incarnation & Types
// Based on Faggian & Hyland (2002) - Definition 6.3, 6.4
// =============================================================================

/// LudicIncarnation - Incarnation relationship between designs
/// D incarnates in E (D âŠ‚ E) if actions of D are subset of actions of E
model LudicIncarnation {
  id              String   @id @default(cuid())
  sourceDesignId  String
  targetDesignId  String
  incarnationType String   // "lax" | "sharp"
  isValid         Boolean
  witnessActions  Json?    // Actions proving incarnation
  checkedAt       DateTime @default(now())

  @@unique([sourceDesignId, targetDesignId, incarnationType])
  @@index([incarnationType, isValid])
}

/// LudicType - Type as behaviour (types are specific behaviours)
model LudicType {
  id             String   @id @default(cuid())
  name           String
  deliberationId String
  typeCategory   String   // "base" | "arrow" | "product" | "sum" | "variable"
  behaviourId    String?  // Reference to underlying behaviour
  inhabitants    Json     // Array of design IDs inhabiting this type
  formula        String?  // Type formula (e.g., "A â†’ B")
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relations
  typingsAsType  LudicTyping[]         @relation("TypingType")
  inferenceFrom  LudicTypeInference[]  @relation("InferenceType")
  equiv1         LudicTypeEquivalence[] @relation("TypeEquiv1")
  equiv2         LudicTypeEquivalence[] @relation("TypeEquiv2")

  @@index([deliberationId])
  @@index([typeCategory])
}

/// LudicTyping - Design typing judgment (D : A)
model LudicTyping {
  id        String   @id @default(cuid())
  designId  String
  typeId    String
  isValid   Boolean
  proof     Json?    // Proof/witness of typing judgment
  checkedAt DateTime @default(now())

  type LudicType @relation("TypingType", fields: [typeId], references: [id], onDelete: Cascade)

  @@unique([designId, typeId])
  @@index([isValid])
}

/// LudicTypeInference - Type inference result for a design
model LudicTypeInference {
  id           String   @id @default(cuid())
  designId     String
  inferredType Json     // TypeStructure: {kind, name?, left?, right?}
  confidence   Float    @default(0.5)
  method       String   // "structural" | "behavioural"
  alternatives Json?    // Alternative type interpretations
  inferredAt   DateTime @default(now())

  typeId String?
  type   LudicType? @relation("InferenceType", fields: [typeId], references: [id], onDelete: SetNull)

  @@index([designId])
  @@index([method, confidence])
}

/// LudicTypeEquivalence - Type equivalence checking
model LudicTypeEquivalence {
  id              String   @id @default(cuid())
  type1Id         String
  type2Id         String
  areEquivalent   Boolean
  equivalenceType String   // "syntactic" | "semantic" | "behavioural"
  proof           Json?    // Proof/witness of equivalence
  checkedAt       DateTime @default(now())

  type1 LudicType @relation("TypeEquiv1", fields: [type1Id], references: [id], onDelete: Cascade)
  type2 LudicType @relation("TypeEquiv2", fields: [type2Id], references: [id], onDelete: Cascade)

  @@unique([type1Id, type2Id, equivalenceType])
  @@index([areEquivalent])
}

// =============================================================================
// DDS Phase 5 Part 3: Saturation & Advanced Analysis
// Based on Faggian & Hyland (2002) - Proposition 4.17
// =============================================================================

/// LudicSaturation - Saturation analysis (Proposition 4.17: Views(S) = S)
model LudicSaturation {
  id              String   @id @default(cuid())
  strategyId      String   @unique
  isSaturated     Boolean
  saturationProof Json?    // Witness of saturation property
  violations      Json?    // Counter-examples if not saturated
  checkedAt       DateTime @default(now())

  @@index([isSaturated])
}

/// LudicCorrespondenceValidation - Full correspondence chain validation
/// Validates: Design â†” Strategy â†” Game â†” Type
model LudicCorrespondenceValidation {
  id                  String   @id @default(cuid())
  designId            String
  strategyId          String?
  gameId              String?
  typeId              String?
  validationLevel     String   // "design-strategy" | "strategy-game" | "design-game" | "full"
  isValid             Boolean
  correspondenceChain Json     // Full transformation chain details
  validatedAt         DateTime @default(now())

  @@unique([designId, validationLevel])
  @@index([isValid])
}

/// LudicPropertyAnalysis - Advanced property analysis for designs/strategies/games
model LudicPropertyAnalysis {
  id         String   @id @default(cuid())
  targetId   String
  targetType String   // "design" | "strategy" | "game"
  properties Json     // Map of property â†’ boolean
  proofs     Json?    // Proofs for each property
  analyzedAt DateTime @default(now())

  @@unique([targetId, targetType])
  @@index([targetType])
}

/// LudicComplexity - Complexity metrics for designs
model LudicComplexity {
  id          String   @id @default(cuid())
  designId    String   @unique
  depthMetric Int      // Max depth of design tree
  widthMetric Int      // Max branching factor
  actCount    Int      // Total actions
  locuCount   Int      // Total loci
  complexity  String   // "low" | "medium" | "high"
  computedAt  DateTime @default(now())

  @@index([complexity])
}

/// LudicPerformanceMetric - Performance tracking for operations
model LudicPerformanceMetric {
  id         String   @id @default(cuid())
  operation  String   // Operation name
  inputSize  Int      // Size of input
  duration   Float    // Duration in seconds
  memoryUsed Float?   // Memory in MB
  successful Boolean  @default(true)
  metadata   Json?
  recordedAt DateTime @default(now())

  @@index([operation, recordedAt])
  @@index([successful])
}

model VoteSession {
  id             String    @id @default(cuid())
  deliberationId String
  subjectType    String // 'option' | 'view' | 'claim'
  subjectId      String
  method         String // 'approval' | 'rcv'
  optionsJson    Json // [{id,label,rvViewIndex?}]
  quorumMinCount Int?
  quorumMinPct   Float? // active-30d share
  closesAt       DateTime
  closedAt       DateTime?
  tallyJson      Json? // cached final tally
  winnerId       String?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  ballots VoteBallot[]

  @@index([deliberationId, subjectType, subjectId])
}

model VoteBallot {
  id            String   @id @default(cuid())
  sessionId     String
  voterId       String
  approvalsJson Json? // approval: {optId:true}
  rankingJson   Json? // rcv:     [optId,...]
  createdAt     DateTime @default(now())

  session VoteSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@unique([sessionId, voterId])
}

model XRef {
  id        String   @id @default(cuid())
  fromType  String
  fromId    String
  toType    String
  toId      String
  relation  String // 'cites'|'evidence-for'|'discusses'|'originates-from'|'replies-to'|'cross-claim'|...
  metaJson  Json?
  createdAt DateTime @default(now())

  @@unique([fromType, fromId, toType, toId, relation])
  @@index([fromType, fromId])
  @@index([toType, toId])
  @@index([relation])
  @@index([fromType, fromId, relation])
  @@index([toType, toId, relation])
}

model WikiPage {
  id          String   @id @default(cuid())
  slug        String   @unique
  title       String
  entityUrn   String
  createdById String
  createdAt   DateTime @default(now())

  // 1â€“1 pointer to the current revision
  currentId String?       @unique
  current   WikiRevision? @relation("CurrentRev", fields: [currentId], references: [id])

  // 1â€“N: all revisions
  revisions WikiRevision[] @relation("AllRevs")

  @@index([entityUrn])
}

model WikiRevision {
  id          String   @id @default(cuid())
  pageId      String
  body        String   @db.Text
  citations   Json
  createdById String
  createdAt   DateTime @default(now())

  // backref for 1â€“N
  page WikiPage @relation("AllRevs", fields: [pageId], references: [id], onDelete: Cascade)

  // backref for 1â€“1 "current"
  currentOf WikiPage? @relation("CurrentRev")

  @@index([pageId])
}

model AgoraFollow {
  userId    String
  kind      String // 'room' | 'tag'
  targetId  String
  createdAt DateTime @default(now())

  @@id([userId, kind, targetId])
  @@index([kind, targetId])
}

model Discussion {
  id          String  @id @default(cuid())
  slug        String? @unique
  title       String
  description String?
  createdById String
  visibility  String  @default("public") // "public" | "private" | "unlisted"

  // Link to existing chat conversation (optional at creation; we can create on demand)
  conversationId BigInt? @unique

  conversation Conversation? @relation(fields: [conversationId], references: [id])

  // Polymorphic attachment to any object (optional)
  attachedToType String? // e.g. "article" | "comment" | "stack" | "claim" | "post"
  attachedToId   String? // store as string; can hold cuid, uuid, bigint, etc.

  upgradedToDeliberation Deliberation?           @relation("DiscussionToDeliberation")
  messages               DiscussionMessage[] // ðŸ‘ˆ back-rel for DiscussionMessage.discussion
  participants           DiscussionParticipant[] // ðŸ‘ˆ back-rel for DiscussionParticipant.discussion

  subscriptions DiscussionSubscription[]

  replyCount   Int      @default(0)
  viewCount    Int      @default(0)
  lastActiveAt DateTime @default(now())

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  forumComments ForumComment[]
  deliberations DiscussionDeliberation[]

  ConversationParticipant ConversationParticipant[]

  @@index([attachedToType, attachedToId])
}

model DiscussionSubscription {
  id           String   @id @default(cuid())
  discussionId String
  userId       String
  createdAt    DateTime @default(now())

  discussion Discussion @relation(fields: [discussionId], references: [id], onDelete: Cascade)

  @@unique([discussionId, userId])
  @@index([userId])
  @@index([discussionId])
  @@map("DiscussionSubscription")
}

model ForumComment {
  id           BigInt     @id @default(autoincrement())
  discussionId String
  discussion   Discussion @relation(fields: [discussionId], references: [id])
  parentId     BigInt?
  authorId     String

  // content
  body     Json // tiptap JSON (or your rich JSON format)
  bodyText String? // search/snippet convenience

  // cross-post source (chat â†’ forum)
  sourceMessageId      Int? // original chat message id, for â€œpromoted from chatâ€
  // (optional) if you ever need the conversation too:
  sourceConversationId Int?

  score     Int      @default(0)
  isDeleted Boolean  @default(false)
  isRemoved Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([discussionId, sourceMessageId])
  // prevents duplicate promote spam:
  @@index([discussionId, parentId]) // on ForumComment
  @@index([discussionId])
  @@index([parentId])
  @@index([sourceMessageId])
}

model DiscussionDeliberation {
  id             String     @id @default(cuid())
  discussionId   String
  discussion     Discussion @relation(fields: [discussionId], references: [id])
  deliberationId String // your existing deliberation id (string in your events route)
  createdById    String
  createdAt      DateTime   @default(now())

  @@unique([discussionId, deliberationId])
}

model DiscussionMessage {
  id String @id @default(cuid())

  discussionId String
  discussion   Discussion @relation(fields: [discussionId], references: [id], onDelete: Cascade)

  // Threading
  parentId String?
  parent   DiscussionMessage?  @relation("DiscussionMessageReplies", fields: [parentId], references: [id], onDelete: SetNull)
  replies  DiscussionMessage[] @relation("DiscussionMessageReplies")

  authorId String
  kind     String  @default("text") // text | media | system | poll | note | â€¦
  text     String?
  richJson Json?

  // Ephemeral / pinning
  isPinned    Boolean   @default(false)
  isEphemeral Boolean   @default(false)
  expiresAt   DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  reactions DiscussionReaction[]

  @@index([discussionId])
  @@index([parentId])
  @@index([authorId])
  @@index([expiresAt])
  @@index([isPinned])
}

model DiscussionReaction {
  id        String            @id @default(cuid())
  messageId String
  message   DiscussionMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  userId    String
  kind      String // e.g. 'like', 'emoji:ðŸ‘', 'flag'
  createdAt DateTime          @default(now())

  @@unique([messageId, userId, kind])
  @@index([userId])
}

model DiscussionParticipant {
  discussionId String
  userId       String
  role         String    @default("member") // member | moderator | owner
  lastReadAt   DateTime?
  createdAt    DateTime  @default(now())

  discussion Discussion @relation(fields: [discussionId], references: [id], onDelete: Cascade)

  @@id([discussionId, userId])
  @@index([userId])
}

model ForumVote {
  userId    BigInt
  commentId BigInt
  dir       Int // -1, 0, 1
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@id([userId, commentId])
  @@index([commentId])
}

// Saves (bookmarks) are simple toggles
model ForumSave {
  userId    BigInt
  commentId BigInt
  createdAt DateTime @default(now())

  @@id([userId, commentId])
  @@index([commentId])
}

model AgoraOutbox {
  id             String   @id @default(cuid())
  ts             DateTime @default(now())
  topic          String
  roomId         String?
  deliberationId String?
  targetType     String?
  targetId       String?
  payload        Json?
  delivered      Boolean  @default(false)

  @@index([ts])
  @@index([topic, deliberationId])
}

// ---------- Enums (top-level) ----------
enum DebateEdgeKind {
  supports
  rebuts
  objects
  undercuts
  refines
  restates
  clarifies
  depends_on
}

enum StatementRole {
  premise
  intermediate
  conclusion
  assumption
  question
  warrant
}

enum InferenceKind {
  presumptive
  deductive
  inductive
  abductive
  defeasible
  analogy
}

model Outcome {
  id            String       @id @default(cuid())
  kind          String?
  summary       String?
  DebateSheet   DebateSheet? @relation(fields: [debateSheetId], references: [id])
  debateSheetId String?
}

// ---------- DebateSheet substrate ----------

// --- DebateSheet: keep ONE link to AgoraRoom ---
model DebateSheet {
  id          String   @id @default(cuid())
  title       String
  scope       String?
  roles       String[] @default([])
  rulesetJson Json?

  // (optional) link to a deliberation if you added it earlier
  deliberationId String?
  deliberation   Deliberation? @relation(fields: [deliberationId], references: [id], onDelete: SetNull)

  // âœ… keep ONE FK + relation to AgoraRoom, with a named relation
  roomId String?
  room   AgoraRoom? @relation(name: "RoomSheets", fields: [roomId], references: [id], onDelete: SetNull)

  // REMOVE any duplicate fields like:
  // AgoraRoom AgoraRoom? @relation(...)     // âŒ delete this line if present
  // agoraRoom AgoraRoom? @relation(...)     // âŒ delete this line if present

  nodes      DebateNode[]
  edges      DebateEdge[]
  loci       LocusStatus[]
  acceptance SheetAcceptance?
  unresolved UnresolvedCQ[]
  outcomes   Outcome[]

  createdById String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([deliberationId])
  @@index([roomId])
}

model DebateNode {
  id      String      @id @default(cuid())
  sheetId String
  sheet   DebateSheet @relation(fields: [sheetId], references: [id], onDelete: Cascade)

  title   String?
  summary String?

  // link to internal diagram
  diagramId String?          @unique
  diagram   ArgumentDiagram? @relation(fields: [diagramId], references: [id])

  // NEW: actual relations (instead of just scalar ids)
  argumentId String?
  argument   Argument? @relation(name: "ArgumentDebateNodes", fields: [argumentId], references: [id])

  claimId String?
  claim   Claim?  @relation(name: "ClaimDebateNodes", fields: [claimId], references: [id])

  authorsJson Json?
  createdAt   DateTime @default(now())

  // Phase 2.3: Reverse relation for DialogueMove (Debate Layer Modernization)
  dialogueMoves DialogueMove[] @relation("DialogueMoveDebateNode")
}

model DebateEdge {
  id        String         @id @default(cuid())
  sheetId   String
  sheet     DebateSheet    @relation(fields: [sheetId], references: [id], onDelete: Cascade)
  fromId    String
  toId      String
  kind      DebateEdgeKind
  thread    String?
  ord       Int?
  rationale String?

  // Phase 2.2: Enhanced edge metadata (Debate Layer Modernization)
  attackSubtype ArgumentAttackSubtype? // rebut | undercut | undermine (for attack edges)
  schemeKey     String? // if edge represents scheme application
  cqKey         String? // if edge is a critical question challenge

  createdAt DateTime @default(now())

  @@unique([sheetId, fromId, toId, kind, thread], name: "edge_idempotent")
  @@index([sheetId, fromId, toId, kind, thread])
}

model LocusStatus {
  id        String      @id @default(cuid())
  sheetId   String
  sheet     DebateSheet @relation(fields: [sheetId], references: [id], onDelete: Cascade)
  locusPath String
  open      Boolean     @default(true)
  closable  Boolean?
}

model SheetAcceptance {
  id        String      @id @default(cuid())
  sheetId   String      @unique
  sheet     DebateSheet @relation(fields: [sheetId], references: [id], onDelete: Cascade)
  semantics String // 'grounded' | 'preferred' | 'hybrid'
  labels    Json // { "nodeId": "skeptical-accepted" | "credulous-accepted" | "rejected" | "undecided" }
}

model UnresolvedCQ {
  id      String      @id @default(cuid())
  sheetId String
  sheet   DebateSheet @relation(fields: [sheetId], references: [id], onDelete: Cascade)
  nodeId  String
  cqKey   String

  @@index([sheetId, nodeId, cqKey], name: "unresolved_cq_idx")
}

// ---------- Argument internals (two-level detail) ----------
model ArgumentDiagram {
  id         String         @id @default(cuid())
  title      String?
  statements Statement[]
  inferences Inference[]
  cqStatus   Json?
  evidence   EvidenceLink[]

  createdById String
  createdAt   DateTime    @default(now())
  DebateNode  DebateNode?
}

model Statement {
  id        String          @id @default(cuid())
  diagramId String
  diagram   ArgumentDiagram @relation(fields: [diagramId], references: [id], onDelete: Cascade)
  text      String
  role      StatementRole
  lang      String?
  tags      String[]

  // back-relation for named relation "InferenceConclusion"
  conclusionFor    Inference[]        @relation("InferenceConclusion")
  InferencePremise InferencePremise[]
}

model Inference {
  id        String          @id @default(cuid())
  diagramId String
  diagram   ArgumentDiagram @relation(fields: [diagramId], references: [id], onDelete: Cascade)

  kind InferenceKind

  conclusionId String
  conclusion   Statement @relation("InferenceConclusion", fields: [conclusionId], references: [id])

  schemeKey String?

  // Many premises via join model
  premises InferencePremise[]

  cqKeys String[] @default([])
}

model InferencePremise {
  inferenceId String
  statementId String

  inference Inference @relation(fields: [inferenceId], references: [id], onDelete: Cascade)
  statement Statement @relation(fields: [statementId], references: [id], onDelete: Cascade)

  @@id([inferenceId, statementId])
}

// ---------- Evidence as first-class ----------
model EvidenceNode {
  id          String   @id @default(cuid())
  url         String
  title       String?
  citation    String?
  kind        String?
  reliability Float?
  addedById   String
  addedAt     DateTime @default(now())

  links EvidenceLink[]
}

model EvidenceLink {
  id String @id @default(cuid())

  // DO NOT auto-generate FKs; they must point to real rows
  evidenceId String?
  evidence   EvidenceNode? @relation(fields: [evidenceId], references: [id], onDelete: SetNull)

  targetKind String  @default("argument") // e.g., "argument" | "claim" | "sheet"
  targetId   String? // FK-ish string; leave nullable

  selectors   Json? // annotation anchors
  note        String?
  uri         String // redundant safety (snapshot of source URL)
  snapshotKey String?

  // Optional link to an argument diagram (kept nullable; set-null on deletion)
  argumentDiagramId String?
  ArgumentDiagram   ArgumentDiagram? @relation(fields: [argumentDiagramId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())

  @@index([targetKind, targetId])
  @@index([argumentDiagramId])
  @@index([evidenceId])
}

/// Edges induced when a stack in room A references (is attached to, cites, embeds) room B.
/// We store both room ids for quick aggregation; optionally keep a stackId for provenance.
model StackReference {
  id                 String  @id @default(cuid())
  fromDeliberationId String
  toDeliberationId   String
  stackId            String?
  relation           String? // 'attached' | 'cites' | 'embeds' | ...

  createdAt DateTime @default(now())

  fromDeliberation Deliberation @relation("StackRefFrom", fields: [fromDeliberationId], references: [id], onDelete: Cascade)
  toDeliberation   Deliberation @relation("StackRefTo", fields: [toDeliberationId], references: [id], onDelete: Cascade)

  // Optional FK to your Stack model if present
  stack Stack? @relation(fields: [stackId], references: [id], onDelete: SetNull)

  @@unique([fromDeliberationId, toDeliberationId, stackId, relation])
  @@index([fromDeliberationId])
  @@index([toDeliberationId])
  @@index([stackId])
}

/// ArgumentImport: Cross-Deliberation Argument Referencing
///
/// Tracks when arguments are imported, restated, or quoted across deliberation rooms.
/// Enables the "Transport Functor" workflow where arguments from one room (source)
/// are brought into another room (target) while preserving provenance.
///
/// **Key Features:**
/// - SHA-1 fingerprint-based identity for idempotent imports
/// - Supports materialized imports (full Argument record created) and virtual imports (read-only reference)
/// - Preserves confidence snapshot at import time (baseAtImport)
/// - Tracks claim mapping between source and target (fromClaimId â†’ toClaimId)
///
/// **Import Kinds:**
/// - 'import': Full argument import with structure preservation (default)
/// - 'restatement': Argument restated in target's language/context
/// - 'quote': Direct quote/citation from source argument
///
/// **Virtual vs Materialized:**
/// - Materialized: toArgumentId != null (full Argument record exists in target room)
/// - Virtual: toArgumentId == null (read-only reference, ID scheme: virt:{fingerprint})
///
/// **Fingerprint Computation:**
/// SHA-1 hash of: fromDeliberationId|toDeliberationId|fromClaimId|toClaimId|fromArgumentId
/// Ensures same argument imported to same target with same claim mapping gets same fingerprint.
///
/// **Referential Integrity:**
/// - Cascade delete when either deliberation is removed
/// - SetNull when argument is deleted (preserves import record for provenance tracking)
///
/// **Related Systems:**
/// - Plexus Visualization: Displays imports as teal edges between rooms
/// - Evidential API: Virtual imports participate in confidence join operations
/// - Transport Functor UI: /functor/transport for claim mapping and import workflow
model ArgumentImport {
  /// Unique identifier for this import record
  id String @id @default(cuid())

  /// Source deliberation ID (where argument originated)
  fromDeliberationId String

  /// Target deliberation ID (where argument is imported to)
  toDeliberationId String

  /// Source argument ID (original argument being imported)
  fromArgumentId String?

  /// Target argument ID (null = virtual import, non-null = materialized)
  /// Virtual imports use synthetic ID: virt:{fingerprint}
  toArgumentId String?

  /// Import kind: 'import' (default), 'restatement', 'quote'
  /// - import: Full argument with structure preservation
  /// - restatement: Argument restated in target context
  /// - quote: Direct citation/reference
  kind String? // 'import' | 'restatement' | 'quote' | ...

  /// Source claim ID (claim in source deliberation)
  /// Preserved for categorical functor verification: F(Ï†_A) = Ïˆ_B
  fromClaimId String? // snapshot at import time

  /// Target claim ID (mapped claim in target deliberation)
  /// Required for DS conflict mass computation
  toClaimId String? // snapshot at import time

  /// Confidence snapshot at import time
  /// Enables historical analysis of confidence drift
  /// No automatic sync - user must manually re-import for updates
  baseAtImport Float? // snapshot

  /// SHA-1 fingerprint: fromId|toId|fromClaimId|toClaimId|fromArgId
  /// Ensures idempotent imports (re-applying same import uses same fingerprint)
  /// Unique constraint prevents duplicate imports
  fingerprint String @unique // sha1(from|to|fromClaim|toClaim|fromArg)

  /// Toulmin structure from source argument (preserves composition)
  /// Stores complete argument graph: statements, inferences, evidence, premises
  /// Enables reconstruction in target deliberation with remapped claim IDs
  /// Schema: { statements: [{id, text, role}], inferences: [{id, schemeId, ...}], premises: [argId], evidence: [...] }
  structureJson Json?

  /// Extensible metadata (JSON)
  /// Future use: composition tracking, source metadata, user notes
  metaJson Json?

  /// Timestamp of import creation
  createdAt DateTime @default(now())

  // Relations
  fromDeliberation Deliberation @relation("ArgImpFrom", fields: [fromDeliberationId], references: [id], onDelete: Cascade)
  toDeliberation   Deliberation @relation("ArgImpTo", fields: [toDeliberationId], references: [id], onDelete: Cascade)
  fromArgument     Argument?    @relation("ArgImpFromArg", fields: [fromArgumentId], references: [id], onDelete: SetNull)
  toArgument       Argument?    @relation("ArgImpToArg", fields: [toArgumentId], references: [id], onDelete: SetNull)

  // Indexes for optimal query performance
  @@unique([fromArgumentId, toArgumentId, kind])
  @@index([fromDeliberationId])
  @@index([toDeliberationId])
  @@index([fromArgumentId])
  @@index([toArgumentId])
  @@index([fromDeliberationId, toDeliberationId])
  @@index([toDeliberationId, toClaimId])
  @@index([fromDeliberationId, fromClaimId])
}

/// Weak ties when the same author(s) produce work in both rooms.
/// Store only one directed record per unordered pair (canonicalize fromId < toId in app code).
model SharedAuthorRoomEdge {
  id        String   @id @default(cuid())
  fromId    String
  toId      String
  strength  Int? // e.g., count of shared authorships or a weighted score
  createdAt DateTime @default(now())

  from Deliberation @relation("SharedAuthorFrom", fields: [fromId], references: [id], onDelete: Cascade)
  to   Deliberation @relation("SharedAuthorTo", fields: [toId], references: [id], onDelete: Cascade)

  @@unique([fromId, toId])
  @@index([fromId])
  @@index([toId])
}

/// NegationMap: Claim Negation Mappings for DS Conflict Mass
///
/// Stores explicit negation relationships between claims within a deliberation.
/// Required for Dempster-Shafer conflict mass computation when importing arguments.
///
/// **Purpose:**
/// When importing argument A that supports claim Ï† from source deliberation,
/// we need to know which claim Â¬Ï† (negation of Ï†) exists in the source to compute
/// conflict mass for the target claim Ïˆ.
///
/// **DS Conflict Mass Algorithm:**
/// 1. Identify attacks on imported arguments in source deliberation
/// 2. Map attacking claims via functor negation: F(Â¬Ï†) = Â¬F(Ï†) if mapping exists
/// 3. Compute conflict mass: m(Â¬Ïˆ) = join({support(Â¬Ïˆ_i)})
/// 4. Reduce plausibility: pl(Ïˆ) = bel(Ïˆ) + m(Î©) - m(Â¬Ïˆ)
///
/// **Example:**
/// - Claim Ï†: "Climate change is caused by humans" (id: clm_abc)
/// - Claim Â¬Ï†: "Climate change is not caused by humans" (id: clm_xyz)
/// - NegationMap record: claimId=clm_abc, negatedClaimId=clm_xyz, deliberationId=delib123
///
/// **Symmetric Mapping:**
/// System should maintain both directions: if (Ï†, Â¬Ï†) exists, then (Â¬Ï†, Ï†) should also exist.
/// Application code responsible for creating symmetric pairs.
///
/// **Related Systems:**
/// - Transport Functor UI: Interface for defining negation mappings during import
/// - Evidential API: Uses negation maps to compute DS conflict mass
/// - ArgumentImport: Negation maps enable functor-based attack propagation
model NegationMap {
  /// Unique identifier
  id String @id @default(cuid())

  /// The claim being negated
  claimId String

  /// The claim that represents the negation
  negatedClaimId String

  /// Deliberation context (negation relationships are deliberation-specific)
  deliberationId String

  /// Optional confidence in the negation relationship (0..1)
  /// 1.0 = perfect logical negation, <1.0 = partial/pragmatic negation
  confidence Float? @default(1.0)

  /// Optional metadata (reason, user notes, etc.)
  metaJson Json?

  /// Creation timestamp
  createdAt DateTime @default(now())

  // Relations
  claim        Claim        @relation("NegationMapClaim", fields: [claimId], references: [id], onDelete: Cascade)
  negatedClaim Claim        @relation("NegationMapNegatedClaim", fields: [negatedClaimId], references: [id], onDelete: Cascade)
  deliberation Deliberation @relation("NegationMapDeliberation", fields: [deliberationId], references: [id], onDelete: Cascade)

  // Ensure one negation relationship per claim pair per deliberation
  @@unique([claimId, negatedClaimId, deliberationId])
  @@index([deliberationId])
  @@index([claimId])
  @@index([negatedClaimId])
}

/// â€”â€”â€” Evidence/strength over arguments that support a claim (hom(I, Ï†)) â€”â€”â€”
model ArgumentSupport {
  id             String @id @default(cuid())
  deliberationId String
  claimId        String // supported Ï†
  argumentId     String // supporting argument a

  mode      String  @default("product") // scoring mode snapshot ("min"|"product"|custom)
  strength  Float   @default(0.6) // 0..1 scalar
  composed  Boolean @default(false) // true if computed via chaining (not atomic)
  rationale String? // why this number (optional)
  base      Float? // Confidence base value for argument support (added for backfill script)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // NEW (lets us â€œinclude imported linesâ€ only when asked)
  provenanceJson Json? // e.g., {kind:'import', fingerprint, fromDeliberationId, fromArgumentId}

  @@unique([claimId, argumentId, mode], name: "arg_support_unique")
  @@index([deliberationId, claimId])
  @@index([argumentId])
}

/// Tag a (possibly implicit) assumption that an argument a relies upon.
model AssumptionUse {
  id             String @id @default(cuid())
  deliberationId String
  argumentId     String? // Phase A: Make optional for standalone assumptions

  // Either tie to an existing claimâ€¦
  assumptionClaimId String? // FK to Claim.id (nullable)
  // â€¦or store freeform text for a local assumption (one of the two must be present)
  assumptionText    String?

  role       String @default("premise") // 'premise'|'warrant'|'value'|â€¦ (open set)
  weight     Float? // local weight 0..1 for this assumption (optional)
  confidence Float? // confidence provided by author/UI (optional)
  metaJson   Json?

  createdAt DateTime @default(now())

  // Phase 2.4: Assumption lifecycle tracking
  status          AssumptionStatus @default(PROPOSED)
  statusChangedAt DateTime         @default(now())
  statusChangedBy String?
  challengeReason String?          @db.Text // Optional reason for CHALLENGED status

  @@index([argumentId])
  @@index([assumptionClaimId])
  @@index([status])
  @@index([deliberationId, status])
}

enum AssumptionStatus {
  PROPOSED // Initial state - awaiting review
  ACCEPTED // Accepted as valid assumption
  RETRACTED // Withdrawn by proposer or community
  CHALLENGED // Under dispute
}

/// Link derivations to assumptions they rely upon.
/// Enables per-derivation assumption tracking for categorical composition.
/// Phase: Gap 4 - Per-Derivation Assumption Tracking
model DerivationAssumption {
  id           String @id @default(cuid())
  derivationId String // FK to ArgumentSupport.id (derivation materializer)
  assumptionId String // FK to AssumptionUse.id

  // Strength of this assumption's contribution to this derivation
  weight Float @default(1.0) // 0..1 multiplier

  // Tracking metadata
  inferredFrom String? // If auto-generated via compose(), reference parent derivation
  createdAt    DateTime @default(now())

  @@unique([derivationId, assumptionId])
  @@index([derivationId])
  @@index([assumptionId])
  @@index([inferredFrom]) // Fast transitive queries
}

model AgoraRoom {
  id         String        @id @default(cuid())
  slug       String        @unique
  title      String
  summary    String?
  visibility String        @default("public") // or an enum if you prefer
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt
  sheets     DebateSheet[] @relation(name: "RoomSheets")

  deliberations Deliberation[]
}

model RoomFunctor {
  id           String   @id @default(cuid())
  fromRoomId   String // deliberationId
  toRoomId     String // deliberationId
  claimMapJson Json // { "<fromClaimId>": "<toClaimId>", ... }
  notes        String?
  createdById  String?
  createdAt    DateTime @default(now())

  @@unique([fromRoomId, toRoomId])
  @@index([fromRoomId, toRoomId])
}

// ---------- Knowledge Base (Phase A) ----------
enum KbVisibility {
  public
  org
  followers
  private
}

enum KbRole {
  owner
  editor
  commenter
  reader
}

enum KbSpaceKind {
  personal
  team
  org
  project
}

enum KbBlockType {
  text
  image
  link
  claim
  claim_set
  argument
  sheet
  room_summary
  transport
  evidence_list
  cq_tracker
  plexus_tile
  theory_work // NEW
  theory_section // (optional) inline a single section from a work
}

model KbSpace {
  id         String       @id @default(cuid())
  slug       String       @unique
  title      String
  summary    String?
  visibility KbVisibility @default(public)

  kind        KbSpaceKind @default(personal) // <â€” added; used by create route
  createdById String
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  pages   KbPage[]
  members KbSpaceMember[]
}

model KbSpaceMember {
  id        String   @id @default(cuid())
  spaceId   String
  userId    String
  role      KbRole   @default(reader)
  createdAt DateTime @default(now())

  space KbSpace @relation(fields: [spaceId], references: [id], onDelete: Cascade)

  @@unique([spaceId, userId])
  @@index([userId])
}

model KbPage {
  id          String       @id @default(cuid())
  spaceId     String
  slug        String
  title       String
  summary     String?
  visibility  KbVisibility @default(public)
  tags        String[] // small, flexible
  frontmatter Json? // { defaultLens, eval: { mode, tau }, ... }

  createdById String
  updatedById String? // <â€” added; used by PATCH
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  space     KbSpace      @relation(fields: [spaceId], references: [id], onDelete: Cascade)
  blocks    KbBlock[]
  snapshots KbSnapshot[]

  theoryWorks        TheoryWork[] // For TheoryWork.kbPage
  TheoryWorkCitation TheoryWorkCitation[]
  debateCitations    DebateCitation[]

  @@unique([spaceId, slug])
  @@index([spaceId, updatedAt])
  @@index([createdById, updatedAt])
}

model KbBlock {
  id          String      @id @default(cuid())
  pageId      String
  ord         Int
  type        KbBlockType
  live        Boolean     @default(true) // live vs pinned
  dataJson    Json // discriminated payload by `type`
  pinnedJson  Json? // when !live, frozen data
  citations   Json? // [{ kind, id, uri, note }]
  createdById String
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  page            KbPage           @relation(fields: [pageId], references: [id], onDelete: Cascade)
  debateCitations DebateCitation[]

  @@index([pageId, ord])
}

// DebateCitation: Tracks when KB blocks cite deliberations (bidirectional linking)
model DebateCitation {
  id             String   @id @default(cuid())
  deliberationId String
  kbPageId       String
  kbBlockId      String
  citedAt        DateTime @default(now())

  deliberation Deliberation @relation(fields: [deliberationId], references: [id], onDelete: Cascade)
  kbPage       KbPage       @relation(fields: [kbPageId], references: [id], onDelete: Cascade)
  kbBlock      KbBlock      @relation(fields: [kbBlockId], references: [id], onDelete: Cascade)

  @@unique([deliberationId, kbPageId, kbBlockId])
  @@index([deliberationId])
  @@index([kbPageId])
}

model KbSnapshot {
  id          String   @id @default(cuid())
  pageId      String
  label       String?
  atTime      DateTime @default(now())
  createdById String
  manifest    Json // { page, blocks: [{id, live, pinnedJson?, liveHash?}] }

  page KbPage @relation(fields: [pageId], references: [id], onDelete: Cascade)

  @@index([pageId, atTime])
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NON-CANONICAL MOVES: Community-sourced dialogue responses with approval
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// Non-canonical dialogue moves submitted by community members
/// These require approval before becoming canonical protocol moves
model NonCanonicalMove {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // â”€â”€â”€ Context & Target â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  deliberationId String
  targetMoveId   String? // The move this responds to (WHY, clarification request, etc.)
  targetType     String // "argument" | "claim" | "clarification_request"
  targetId       String // ID of the argument/claim/request

  // â”€â”€â”€ Authorship â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  contributorId String // User who submitted this non-canonical move
  authorId      String // Original argument/claim author (for approval)

  // â”€â”€â”€ Move Content â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  moveType MoveType // What kind of response this is
  content  Json // Move-specific payload (expression, evidence, etc.)

  // â”€â”€â”€ Approval Workflow â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  status          NCMStatus @default(PENDING)
  approvedBy      String? // userId who approved (author or asker)
  approvedAt      DateTime?
  rejectedBy      String? // userId who rejected
  rejectedAt      DateTime?
  rejectionReason String?   @db.Text

  // â”€â”€â”€ Canonicalization â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  canonicalMoveId String?   @unique // If approved & executed, links to DialogueMove
  executedAt      DateTime?

  // â”€â”€â”€ Metadata â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  metaJson Json @default("{}")

  // â”€â”€â”€ Relations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  reviewIssues Issue[] // Issues created for reviewing this NCM

  @@index([deliberationId, targetType, targetId])
  @@index([targetMoveId])
  @@index([contributorId])
  @@index([authorId])
  @@index([status, createdAt])
  @@index([deliberationId, status])
  @@map("non_canonical_moves")
}

enum NCMStatus {
  PENDING // Awaiting approval
  APPROVED // Approved but not yet canonical
  EXECUTED // Approved and converted to canonical DialogueMove
  REJECTED // Rejected by author/asker
  WITHDRAWN // Withdrawn by contributor
}

enum MoveType {
  GROUNDS_RESPONSE // Answer to WHY challenge
  CLARIFICATION_ANSWER // Answer to clarification request
  CHALLENGE_RESPONSE // Response to a challenge
  EVIDENCE_ADDITION // Additional evidence for existing move
  PREMISE_DEFENSE // Defense of undermined premise
  EXCEPTION_REBUTTAL // Rebuttal to undercut exception
}

/// Clarification requests (non-protocol questions seeking factual details)
model ClarificationRequest {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // â”€â”€â”€ Context â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  deliberationId String
  targetType     String // "argument" | "claim"
  targetId       String // What needs clarification

  // â”€â”€â”€ Question â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  askerId  String // User asking the question
  question String @db.Text

  // â”€â”€â”€ Status â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  status ClarificationStatus @default(OPEN)

  @@index([deliberationId, targetType, targetId])
  @@index([askerId])
  @@index([status, createdAt])
  @@map("clarification_requests")
}

enum ClarificationStatus {
  OPEN // Awaiting answers
  ANSWERED // Has at least one approved answer
  RESOLVED // Asker marked as fully resolved
  CLOSED // No longer accepting answers
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DELIBERATION GLOSSARY: Collaborative term definitions to reduce semantic confusion
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// Glossary terms for a deliberation - key words/phrases that need shared definitions
model GlossaryTerm {
  id             String       @id @default(cuid())
  deliberationId String
  deliberation   Deliberation @relation(fields: [deliberationId], references: [id], onDelete: Cascade)

  term           String // The word/phrase being defined (e.g., "Justice")
  termNormalized String // Lowercase, trimmed version for matching

  status GlossaryTermStatus @default(PENDING)
  // PENDING: awaiting endorsements
  // CONSENSUS: has sufficient endorsements for one definition
  // CONTESTED: multiple competing definitions
  // ARCHIVED: no longer active

  proposedById String
  proposedBy   User   @relation("ProposedTerms", fields: [proposedById], references: [auth_id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  definitions GlossaryDefinition[]
  usages      GlossaryTermUsage[]

  @@unique([deliberationId, termNormalized])
  @@index([deliberationId, status])
  @@index([termNormalized])
  @@map("glossary_terms")
}

/// Definitions for glossary terms - multiple definitions allowed (competing views)
model GlossaryDefinition {
  id     String       @id @default(cuid())
  termId String
  term   GlossaryTerm @relation(fields: [termId], references: [id], onDelete: Cascade)

  definition String  @db.Text // The actual definition text
  examples   String? @db.Text // Optional usage examples
  sources    Json? // References/citations (URLs, books, etc.)

  authorId String
  author   User   @relation("AuthoredDefinitions", fields: [authorId], references: [auth_id])

  isCanonical      Boolean @default(false) // Moderator-endorsed or consensus-reached
  endorsementCount Int     @default(0) // Cached count for performance

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  endorsements GlossaryEndorsement[]
  votes        GlossaryDefinitionVote[]
  history      GlossaryDefinitionHistory[]

  @@index([termId, isCanonical])
  @@index([termId, endorsementCount])
  @@map("glossary_definitions")
}

/// User endorsements of specific definitions
model GlossaryEndorsement {
  id           String             @id @default(cuid())
  definitionId String
  definition   GlossaryDefinition @relation(fields: [definitionId], references: [id], onDelete: Cascade)

  userId String
  user   User   @relation("DefinitionEndorsements", fields: [userId], references: [auth_id])

  createdAt DateTime @default(now())

  @@unique([definitionId, userId])
  @@index([definitionId])
  @@index([userId])
  @@map("glossary_endorsements")
}

/// Votes on competing definitions (when multiple exist)
model GlossaryDefinitionVote {
  id           String             @id @default(cuid())
  definitionId String
  definition   GlossaryDefinition @relation(fields: [definitionId], references: [id], onDelete: Cascade)

  userId String
  user   User   @relation("DefinitionVotes", fields: [userId], references: [auth_id])

  value Int // +1 for upvote, -1 for downvote, 0 for neutral

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([definitionId, userId])
  @@index([definitionId])
  @@map("glossary_definition_votes")
}

/// History of changes to definitions (audit trail)
model GlossaryDefinitionHistory {
  id           String             @id @default(cuid())
  definitionId String
  definition   GlossaryDefinition @relation(fields: [definitionId], references: [id], onDelete: Cascade)

  previousText String @db.Text
  newText      String @db.Text
  changeType   String // "created", "edited", "merged", "endorsed", "canonical_promoted"

  changedById String
  changedBy   User   @relation("DefinitionChanges", fields: [changedById], references: [auth_id])

  createdAt DateTime @default(now())

  @@index([definitionId, createdAt])
  @@map("glossary_definition_history")
}

/// Track where glossary terms are used in arguments/claims
model GlossaryTermUsage {
  id     String       @id @default(cuid())
  termId String
  term   GlossaryTerm @relation(fields: [termId], references: [id], onDelete: Cascade)

  // What used this term?
  targetType String // "claim" | "argument" | "premise" | "comment"
  targetId   String

  // Context where it was used
  contextText    String? @db.Text
  highlightStart Int? // Character position in text where term starts
  highlightEnd   Int? // Character position in text where term ends

  detectedAt DateTime @default(now())

  @@index([termId])
  @@index([targetType, targetId])
  @@map("glossary_term_usages")
}

enum GlossaryTermStatus {
  PENDING // Awaiting endorsements
  CONSENSUS // Has consensus on one definition
  CONTESTED // Multiple competing definitions
  ARCHIVED // No longer active/relevant
}

// ============================================================================
// THESIS BUILDER MODELS
// ============================================================================
// Multi-layered case building system for legal briefs, policy cases, etc.
// Named "Thesis" to avoid conflict with existing Brief model

/// Main thesis document - composed essay/brief with inserted structured objects
model Thesis {
  id    String @id @default(cuid())
  slug  String @unique
  title String

  // Rich text document content (TipTap JSON)
  // Contains composed essay with embedded claims, arguments, citations, etc.
  content Json? // Main document body

  // Optional abstract/summary for metadata
  abstract String? @db.Text

  // Optional main claim reference (not required - user composes freely)
  thesisClaimId String?
  thesisClaim   Claim?  @relation("ThesisMainClaim", fields: [thesisClaimId], references: [id], onDelete: SetNull)

  // Inserted structured objects (referenced within content)
  prongs   ThesisProng[] // Lines of reasoning inserted in document
  sections ThesisSection[] // Prose sections for organization

  // Context
  deliberationId String?
  deliberation   Deliberation? @relation(fields: [deliberationId], references: [id], onDelete: SetNull)

  authorId String
  author   User   @relation("AuthoredTheses", fields: [authorId], references: [auth_id], onDelete: Cascade)

  // Versioning & status
  status      ThesisStatus @default(DRAFT)
  version     Int          @default(1)
  publishedAt DateTime?

  // Metadata
  template ThesisTemplate @default(GENERAL)
  meta     Json?

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([deliberationId])
  @@index([authorId])
  @@index([thesisClaimId])
  @@index([status, publishedAt])
  @@map("theses")
}

/// Individual prong (line of reasoning) within a thesis
model ThesisProng {
  id       String @id @default(cuid())
  thesisId String
  thesis   Thesis @relation(fields: [thesisId], references: [id], onDelete: Cascade)

  order Int // Order within thesis
  title String
  role  ProngRole @default(SUPPORT)

  // Optional sub-claim for this prong
  mainClaimId String?
  mainClaim   Claim?  @relation("ProngMainClaim", fields: [mainClaimId], references: [id], onDelete: SetNull)

  // Argument chain
  arguments ThesisProngArgument[]

  // Prose framing (TipTap JSON)
  introduction Json? // Rich text intro
  conclusion   Json? // Rich text conclusion

  meta Json?

  @@index([thesisId, order])
  @@index([mainClaimId])
  @@map("thesis_prongs")
}

/// Link between prong and argument (ordered)
model ThesisProngArgument {
  id      String      @id @default(cuid())
  prongId String
  prong   ThesisProng @relation(fields: [prongId], references: [id], onDelete: Cascade)

  argumentId String
  argument   Argument @relation("ThesisProngArguments", fields: [argumentId], references: [id], onDelete: Restrict)

  order Int // Order within prong's argument chain
  role  ArgumentRole @default(PREMISE)
  note  String?      @db.Text // Optional annotation

  @@unique([prongId, argumentId])
  @@index([prongId, order])
  @@index([argumentId])
  @@map("thesis_prong_arguments")
}

/// Prose sections (introduction, background, conclusion, etc.)
model ThesisSection {
  id       String @id @default(cuid())
  thesisId String
  thesis   Thesis @relation(fields: [thesisId], references: [id], onDelete: Cascade)

  order       Int
  sectionType ThesisSectionType
  title       String?

  // TipTap JSON content
  content Json? // Rich text content

  @@index([thesisId, order])
  @@map("thesis_sections")
}

// Enums for Thesis system
enum ThesisStatus {
  DRAFT
  SUBMITTED
  PUBLISHED
  ARCHIVED
}

enum ThesisTemplate {
  LEGAL_DEFENSE // "Defendant is not guilty because..."
  POLICY_CASE // "We should adopt policy X because..."
  ACADEMIC_THESIS // "My thesis is X, supported by..."
  GENERAL // Freeform
}

enum ProngRole {
  SUPPORT // Affirmative line of reasoning
  REBUT // Counter opposing argument
  PREEMPT // Address anticipated objection
}

enum ArgumentRole {
  PREMISE // Establishes a premise
  INFERENCE // Links premises to conclusion
  COUNTER_RESPONSE // Responds to counter-argument
}

enum ThesisSectionType {
  INTRODUCTION
  BACKGROUND
  LEGAL_STANDARD // For legal briefs
  CONCLUSION
  APPENDIX
}

// =============================================================================
// DIALOGUE VISUALIZATION SYSTEM - Phase 1.1
// AIF Ontology Extensions for Dialogue Move Integration
// =============================================================================

/// AIF Node model - represents nodes in Argument Interchange Format graphs
/// Extended to support Dialogue Move (DM-node) integration
model AifNode {
  id             String       @id @default(cuid())
  deliberationId String
  deliberation   Deliberation @relation(fields: [deliberationId], references: [id], onDelete: Cascade)

  nodeKind  String // 'I'|'RA'|'CA'|'PA'|'DM' (DM = Dialogue Move node)
  label     String?
  text      String?
  schemeKey String? // For RA/CA/PA nodes with argumentation schemes

  // Dialogue provenance tracking
  dialogueMoveId String?
  dialogueMove   DialogueMove? @relation("AifNodeCreatedBy", fields: [dialogueMoveId], references: [id], onDelete: SetNull)

  // Node subtype for extensibility
  nodeSubtype String? // "dialogue_move", "standard", "scheme_instantiation"

  // Dialogue-specific metadata (JSON for flexibility)
  dialogueMetadata Json?
  /**
   * Example structure:
   * {
   * "locution": "WHY",
   * "speaker": "user123",
   * "speakerName": "Alice",
   * "timestamp": "2025-11-02T10:30:00Z",
   * "replyToMoveId": "move456",
   * "illocution": "Question"
   * }
   */

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations to other AIF structures
  outgoingEdges   AifEdge[]     @relation("EdgeSource")
  incomingEdges   AifEdge[]     @relation("EdgeTarget")
  representedMove DialogueMove? @relation("MoveRepresentation")

  // Ludics integration (Phase 1)
  ludicActId String?   @unique
  ludicAct   LudicAct? @relation(fields: [ludicActId], references: [id], onDelete: SetNull)

  // Locus annotations (denormalized for query performance)
  locusPath String? // e.g., "0.1.2" - position in interaction tree
  locusRole String? // "opener" | "responder" | "daimon" - role at locus

  @@index([deliberationId])
  @@index([dialogueMoveId])
  @@index([nodeKind])
  @@index([nodeSubtype])
  @@index([ludicActId])
  @@index([locusPath])
  @@map("aif_nodes")
}

/// AIF Edge model - represents relationships between AIF nodes
model AifEdge {
  id             String       @id @default(cuid())
  deliberationId String
  deliberation   Deliberation @relation(fields: [deliberationId], references: [id], onDelete: Cascade)

  sourceId String
  source   AifNode @relation("EdgeSource", fields: [sourceId], references: [id], onDelete: Cascade)

  targetId String
  target   AifNode @relation("EdgeTarget", fields: [targetId], references: [id], onDelete: Cascade)

  edgeRole String // 'premise'|'conclusion'|'conflictingElement'|'triggers'|'answers'|'repliesTo'

  // Track which dialogue move caused this edge
  causedByMoveId String?
  causedByMove   DialogueMove? @relation("EdgeCausedBy", fields: [causedByMoveId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())

  @@index([deliberationId])
  @@index([sourceId])
  @@index([targetId])
  @@index([causedByMoveId])
  @@map("aif_edges")
}

// ============================================================================
// ArgumentChain: Deliberation-Level Argument Chains
// Phase 6: Cross-Argument Chains (Nov 2025)
// Based on ArgumentChain design proposal
// ============================================================================

enum ArgumentChainType {
  SERIAL       // A â†’ B â†’ C (linear chain)
  CONVERGENT   // A â†’ C, B â†’ C (multiple premises for one conclusion)
  DIVERGENT    // A â†’ B, A â†’ C (one premise for multiple conclusions)
  TREE         // Hierarchical (premise-conclusion tree)
  GRAPH        // General DAG (complex interdependencies)
}

enum ChainNodeRole {
  PREMISE      // Provides foundational claim
  EVIDENCE     // Supports with data/facts
  CONCLUSION   // Final claim being argued for
  OBJECTION    // Challenges another argument
  REBUTTAL     // Responds to objection
  QUALIFIER    // Adds conditions/scope
  COMMENT      // Lightweight annotation/note
}

enum ArgumentChainEdgeType {
  SUPPORTS        // A supports B (conclusion â†’ premise)
  ENABLES         // A enables B (makes B's claim possible)
  PRESUPPOSES     // B presupposes A (A must be true for B)
  REFUTES         // A challenges B (attack relation)
  QUALIFIES       // A adds conditions to B
  EXEMPLIFIES     // A is example of B's general claim
  GENERALIZES     // A abstracts from B's specific case
  // ASPIC+ attack types
  REBUTS          // Directly contradicts conclusion
  UNDERCUTS       // Challenges inference/reasoning link
  UNDERMINES      // Attacks supporting premise
}

enum ChainAttackTargetType {
  NODE            // Attack targets another node (standard)
  EDGE            // Attack targets a relationship/inference (recursive attack)
}

// Epistemic status for chain nodes (Phase 4: Hypotheticals & Counterfactuals)
enum EpistemicStatus {
  ASSERTED        // Normal assertoric claim (default)
  HYPOTHETICAL    // Assumed true for sake of argument
  COUNTERFACTUAL  // Assumed contrary to known facts
  CONDITIONAL     // Part of an if-then structure
  QUESTIONED      // Under examination, not committed
  DENIED          // Explicitly negated
  SUSPENDED       // Temporarily set aside
}

// Scope types for grouping hypothetical arguments
enum ScopeType {
  HYPOTHETICAL    // "Suppose X..."
  COUNTERFACTUAL  // "Had X been the case..."
  CONDITIONAL     // "If X, then..."
  OPPONENT        // Reasoning within opponent's assumptions (reductio)
  MODAL           // Possibility/necessity reasoning
}

// Dialectical roles for thesis/antithesis/synthesis patterns
enum DialecticalRole {
  THESIS          // Main position being argued
  ANTITHESIS      // Opposing position
  SYNTHESIS       // Resolution/integration
  OBJECTION       // Challenge to thesis
  RESPONSE        // Reply to objection
  CONCESSION      // Acknowledged point from opponent
}

model ArgumentChain {
  id             String   @id @default(cuid())
  deliberationId String
  
  // Metadata
  name           String   @db.VarChar(255)
  description    String?  @db.Text
  purpose        String?  @db.Text
  
  // Structure
  chainType      ArgumentChainType @default(SERIAL)
  rootNodeId     String?
  
  // Ownership & Permissions
  createdBy      BigInt
  isPublic       Boolean  @default(false)
  isEditable     Boolean  @default(false)
  
  // Timestamps
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  
  // Relations
  deliberation   Deliberation        @relation(fields: [deliberationId], references: [id], onDelete: Cascade)
  creator        User                @relation(fields: [createdBy], references: [id], onDelete: Restrict)
  nodes          ArgumentChainNode[]
  edges          ArgumentChainEdge[]
  scopes         ArgumentScope[]     // Hypothetical/counterfactual scopes
  
  @@index([deliberationId])
  @@index([createdBy])
}

// Scope for grouping hypothetical/counterfactual arguments
model ArgumentScope {
  id             String     @id @default(cuid())
  chainId        String
  
  // Scope semantics
  scopeType      ScopeType  @default(HYPOTHETICAL)
  assumption     String     @db.Text       // "If carbon tax passes", "Had we invested earlier"
  description    String?    @db.Text
  
  // Nesting support
  parentScopeId  String?
  depth          Int        @default(0)    // 0 = top-level scope
  
  // Visual grouping
  color          String?    @db.VarChar(7) // Hex color for scope boundary
  collapsed      Boolean    @default(false)
  
  // Timestamps
  createdAt      DateTime   @default(now())
  createdBy      BigInt
  
  // Relations
  chain          ArgumentChain       @relation(fields: [chainId], references: [id], onDelete: Cascade)
  parentScope    ArgumentScope?      @relation("ScopeNesting", fields: [parentScopeId], references: [id], onDelete: SetNull)
  childScopes    ArgumentScope[]     @relation("ScopeNesting")
  nodes          ArgumentChainNode[] @relation("ScopeNodes")
  creator        User                @relation(fields: [createdBy], references: [id])
  
  @@index([chainId])
  @@index([parentScopeId])
}

model ArgumentChainNode {
  id           String   @id @default(cuid())
  chainId      String
  argumentId   String
  
  // Position in chain
  nodeOrder    Int
  role         ChainNodeRole?
  
  // Epistemic status (Phase 4: Hypotheticals & Counterfactuals)
  epistemicStatus  EpistemicStatus @default(ASSERTED)
  scopeId          String?                           // null = actual/assertoric world
  dialecticalRole  DialecticalRole?
  
  // Recursive attack support: Node can target either another node OR an edge
  targetType   ChainAttackTargetType @default(NODE)
  targetEdgeId String?                              // Only populated when targetType = EDGE
  
  // Visual layout
  positionX    Float?
  positionY    Float?
  
  // Contribution metadata
  addedBy      BigInt
  addedAt      DateTime @default(now())
  
  // Relations
  chain        ArgumentChain       @relation(fields: [chainId], references: [id], onDelete: Cascade)
  argument     Argument            @relation(fields: [argumentId], references: [id], onDelete: Cascade)
  contributor  User                @relation(fields: [addedBy], references: [id])
  targetEdge   ArgumentChainEdge?  @relation("EdgeAttacks", fields: [targetEdgeId], references: [id], onDelete: SetNull)
  scope        ArgumentScope?      @relation("ScopeNodes", fields: [scopeId], references: [id], onDelete: SetNull)
  
  outgoingEdges ArgumentChainEdge[] @relation("SourceNode")
  incomingEdges ArgumentChainEdge[] @relation("TargetNode")
  
  @@unique([chainId, argumentId])
  @@index([chainId])
  @@index([argumentId])
  @@index([targetEdgeId])
  @@index([scopeId])
}

model ArgumentChainEdge {
  id             String   @id @default(cuid())
  chainId        String
  sourceNodeId   String
  targetNodeId   String
  
  // Relationship semantics
  edgeType       ArgumentChainEdgeType @default(SUPPORTS)
  strength       Float    @default(1.0)
  
  // Mapping details
  description    String?  @db.Text
  slotMapping    Json?
  
  createdAt      DateTime @default(now())
  
  // Relations
  chain          ArgumentChain     @relation(fields: [chainId], references: [id], onDelete: Cascade)
  sourceNode     ArgumentChainNode @relation("SourceNode", fields: [sourceNodeId], references: [id], onDelete: Cascade)
  targetNode     ArgumentChainNode @relation("TargetNode", fields: [targetNodeId], references: [id], onDelete: Cascade)
  
  // Recursive attack support: Track nodes that attack this edge
  attackingNodes ArgumentChainNode[] @relation("EdgeAttacks")
  
  @@unique([chainId, sourceNodeId, targetNodeId])
  @@index([chainId])
}

// ============================================================================
// Phase 3.2.4: Public Evidence API
// ============================================================================

enum ApiKeyTier {
  free       // 100 requests/hour
  pro        // 1000 requests/hour
  partner    // 10000 requests/hour
  unlimited  // No limit
}

model ApiKey {
  id              String      @id @default(cuid())
  userId          BigInt
  name            String      // Human-readable name for the key
  
  // Security
  keyHash         String      @unique  // SHA-256 hash of the key
  keyPrefix       String      // First 12 chars for identification (e.g., "mesh_pk_xxxx")
  
  // Permissions
  scopes          String[]    @default(["read:sources", "read:stacks"])
  
  // Rate limiting
  tier            ApiKeyTier  @default(free)
  rateLimitOverride Int?      // Custom rate limit (requests/hour)
  
  // Usage tracking
  lastUsedAt      DateTime?
  requestCount    Int         @default(0)
  
  // Status
  isActive        Boolean     @default(true)
  expiresAt       DateTime?
  revokedAt       DateTime?
  revokedReason   String?
  
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  
  // Relations
  user            User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([keyHash])
  @@index([userId])
}

// ============================================================================
// Phase 2.2: Fork/Branch/Merge for Deliberations
// ============================================================================

enum ForkType {
  ASSUMPTION_VARIANT   // Testing different assumptions
  METHODOLOGICAL       // Different analytical approach
  SCOPE_EXTENSION      // Extending to new domain
  ADVERSARIAL          // Devil's advocate exploration
  EDUCATIONAL          // Teaching/learning fork
  ARCHIVAL             // Preserving a branch
}

enum ForkSyncStatus {
  SYNCED               // Matches original
  DIVERGED             // Local modifications made
  ORIGINAL_UPDATED     // Original changed, needs review
  DETACHED             // No longer tracking original
}

enum MergeStatus {
  OPEN
  IN_REVIEW
  APPROVED
  MERGED
  CLOSED
  CONFLICT
}

model ImportedClaim {
  id                  String       @id @default(cuid())
  deliberationId      String
  deliberation        Deliberation @relation(fields: [deliberationId], references: [id], onDelete: Cascade)
  
  originalClaimId     String
  originalClaim       Claim        @relation("ClaimImports", fields: [originalClaimId], references: [id], onDelete: Cascade)
  
  localClaimId        String       @unique
  localClaim          Claim        @relation("ImportedAs", fields: [localClaimId], references: [id], onDelete: Cascade)
  
  importedAt          DateTime     @default(now())
  importedById        String
  syncStatus          ForkSyncStatus   @default(SYNCED)
  lastSyncedAt        DateTime?
  
  @@unique([deliberationId, originalClaimId])
  @@index([deliberationId])
  @@index([originalClaimId])
  @@index([localClaimId])
}

model ImportedArgument {
  id                  String       @id @default(cuid())
  deliberationId      String
  deliberation        Deliberation @relation(fields: [deliberationId], references: [id], onDelete: Cascade)
  
  originalArgumentId  String
  originalArgument    Argument     @relation("ArgumentImports", fields: [originalArgumentId], references: [id], onDelete: Cascade)
  
  localArgumentId     String       @unique
  localArgument       Argument     @relation("ImportedAsArg", fields: [localArgumentId], references: [id], onDelete: Cascade)
  
  importedAt          DateTime     @default(now())
  importedById        String
  syncStatus          ForkSyncStatus   @default(SYNCED)
  
  @@unique([deliberationId, originalArgumentId])
  @@index([deliberationId])
  @@index([originalArgumentId])
}

model MergeRequest {
  id                   String       @id @default(cuid())
  
  // Source (the fork)
  sourceDeliberationId String
  sourceDeliberation   Deliberation @relation("MergeSource", fields: [sourceDeliberationId], references: [id], onDelete: Cascade)
  
  // Target (usually the parent)
  targetDeliberationId String
  targetDeliberation   Deliberation @relation("MergeTarget", fields: [targetDeliberationId], references: [id], onDelete: Cascade)
  
  title                String
  description          String?      @db.Text
  
  // Content to merge (JSON arrays of IDs with strategies)
  claimsToMerge        Json         // Array of { claimId, strategy, targetClaimId? }
  argumentsToMerge     Json         // Array of { argumentId, includeWithClaims }
  
  // Review
  status               MergeStatus  @default(OPEN)
  reviewComments       MergeComment[]
  
  // Author
  authorId             String
  
  createdAt            DateTime     @default(now())
  updatedAt            DateTime     @updatedAt
  mergedAt             DateTime?
  mergedById           String?
  closedAt             DateTime?
  
  @@index([sourceDeliberationId])
  @@index([targetDeliberationId])
  @@index([status])
}

model MergeComment {
  id                  String       @id @default(cuid())
  mergeRequestId      String
  mergeRequest        MergeRequest @relation(fields: [mergeRequestId], references: [id], onDelete: Cascade)
  
  content             String       @db.Text
  authorId            String
  
  // Optional: comment on specific claim/argument
  targetClaimId       String?
  targetArgumentId    String?
  
  createdAt           DateTime     @default(now())
  
  @@index([mergeRequestId])
}

// =====================================================================
// Phase 3.1: Claim Provenance Tracking
// Tracks claim lifecycle, versions, challenges, and cross-deliberation identity
// =====================================================================

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Enums for Claim Provenance
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

enum VersionChangeType {
  CREATED           // Initial version
  REFINED           // Wording improved
  STRENGTHENED      // Scope narrowed for precision
  WEAKENED          // Scope broadened or qualified
  CORRECTED         // Error fixed
  MERGED            // Combined with another claim
  SPLIT             // Split from larger claim
  IMPORTED          // Brought from another deliberation
}

enum ConsensusStatus {
  UNDETERMINED      // Not enough engagement
  EMERGING          // Building support
  ACCEPTED          // Broad acceptance
  CONTESTED         // Active disagreement
  REJECTED          // Broadly rejected
  SUPERSEDED        // Replaced by refined version
}

enum ClaimAttackStatus {
  OPEN              // Not yet addressed
  UNDER_REVIEW      // Being evaluated
  DEFENDED          // Successfully defended
  PARTIALLY_DEFENDED // Partially addressed
  CONCEDED          // Attacker's point accepted
  WITHDRAWN         // Attack withdrawn by attacker
  STALEMATE         // Unresolved disagreement
}

enum ClaimDefenseType {
  DIRECT_REBUTTAL   // Directly counter the attack
  DISTINCTION       // Show attack misunderstands the claim
  CONCESSION_LIMIT  // Partially concede but limit scope
  EVIDENCE          // Provide additional supporting evidence
  AUTHORITY         // Appeal to expert consensus
}

enum ClaimDefenseOutcome {
  SUCCESSFUL        // Defense accepted
  PARTIAL           // Partially successful
  UNSUCCESSFUL      // Defense rejected
  PENDING           // Awaiting evaluation
}

enum ClaimInstanceType {
  ORIGINAL          // First occurrence
  EQUIVALENT        // Marked as equivalent
  IMPORTED          // Explicitly imported
  FORKED            // Created via fork
  DERIVED           // Derived/refined from original
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Claim Version Tracking
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

model ClaimVersion {
  id                String   @id @default(cuid())
  claimId           String
  claim             Claim    @relation(fields: [claimId], references: [id], onDelete: Cascade)
  
  // Content at this version
  text              String   @db.Text
  claimType         String?  // "Agent" | "Assertion" | "Domain" | ...
  
  // Version metadata
  versionNumber     Int
  changeType        VersionChangeType
  changeReason      String?  @db.Text
  changedFields     Json?    // Which fields changed { text: true, type: false, ... }
  
  // Authorship
  authorId          String   // auth_id of user who made change
  createdAt         DateTime @default(now())
  
  // Previous version link (for version chain traversal)
  previousVersionId String?
  previousVersion   ClaimVersion? @relation("VersionChain", fields: [previousVersionId], references: [id])
  nextVersions      ClaimVersion[] @relation("VersionChain")
  
  // Current version back-reference
  currentFor        Claim?   @relation("CurrentVersion")
  
  // Release association (if versioned via release)
  releaseId         String?
  
  @@unique([claimId, versionNumber])
  @@index([claimId])
  @@index([authorId])
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Attack Tracking (Challenges to Claims)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

model ClaimAttack {
  id                String   @id @default(cuid())
  
  // What is being attacked
  targetClaimId     String
  targetClaim       Claim    @relation("AttackedClaim", fields: [targetClaimId], references: [id], onDelete: Cascade)
  
  // The attacking argument
  attackingArgumentId String
  attackingArgument Argument @relation("AttackingArgument", fields: [attackingArgumentId], references: [id], onDelete: Cascade)
  
  // Attack classification (uses existing AttackType enum)
  attackType        AttackType   // REBUTS | UNDERCUTS | UNDERMINES
  attackSubtype     String?      // More specific classification
  
  // Status tracking
  status            ClaimAttackStatus @default(OPEN)
  
  // Defense tracking
  defenses          ClaimDefense[]
  
  // Resolution
  resolvedAt        DateTime?
  resolvedById      String?
  resolutionNote    String?  @db.Text
  
  createdAt         DateTime @default(now())
  createdById       String   // auth_id of user who created attack
  
  @@index([targetClaimId])
  @@index([attackingArgumentId])
  @@index([status])
  @@index([createdById])
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Defense Tracking (Responses to Attacks)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

model ClaimDefense {
  id                String   @id @default(cuid())
  
  // What is being defended
  claimId           String
  claim             Claim    @relation("DefendedClaim", fields: [claimId], references: [id], onDelete: Cascade)
  
  // Against which attack
  attackId          String
  attack            ClaimAttack   @relation(fields: [attackId], references: [id], onDelete: Cascade)
  
  // The defending argument
  defendingArgumentId String
  defendingArgument Argument @relation("DefendingArgument", fields: [defendingArgumentId], references: [id])
  
  // Defense type
  defenseType       ClaimDefenseType
  
  // Outcome
  outcome           ClaimDefenseOutcome?
  outcomeNote       String?  @db.Text
  
  createdAt         DateTime @default(now())
  createdById       String   // auth_id of user who created defense
  
  @@index([attackId])
  @@index([claimId])
  @@index([defendingArgumentId])
  @@index([createdById])
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Claim Instance (Cross-Deliberation Identity Tracking)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

model ClaimInstance {
  id                String   @id @default(cuid())
  
  canonicalClaimId  String
  canonicalClaim    CanonicalClaim @relation(fields: [canonicalClaimId], references: [id], onDelete: Cascade)
  
  claimId           String
  claim             Claim    @relation(fields: [claimId], references: [id], onDelete: Cascade)
  
  deliberationId    String
  deliberation      Deliberation @relation(fields: [deliberationId], references: [id], onDelete: Cascade)
  
  // Instance relationship type
  instanceType      ClaimInstanceType @default(ORIGINAL)
  
  // Local status in this deliberation
  localStatus       ConsensusStatus @default(UNDETERMINED)
  
  linkedAt          DateTime @default(now())
  linkedById        String   // auth_id of user who linked
  
  @@unique([canonicalClaimId, claimId])
  @@index([deliberationId])
  @@index([claimId])
  @@index([canonicalClaimId])
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Claim Prediction System - Models
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

model ClaimPrediction {
  id              String                @id @default(cuid())
  
  // What claim is this prediction about?
  claimId         String
  claim           Claim                 @relation(fields: [claimId], references: [id], onDelete: Cascade)
  
  // Which deliberation context?
  deliberationId  String
  deliberation    Deliberation          @relation(fields: [deliberationId], references: [id], onDelete: Cascade)
  
  // The prediction itself
  predictionText  String                @db.Text    // "I predict this claim will be confirmed within 2 years"
  
  // Optional target date for resolution
  targetDate      DateTime?             @db.Timestamptz(6)
  
  // Confidence level (0.0 to 1.0)
  confidence      Float                 @default(0.5)
  
  // Status tracking
  status          ClaimPredictionStatus @default(PENDING)
  
  // Resolution
  resolution      PredictionResolution?
  resolutionNote  String?               @db.Text
  resolvedAt      DateTime?             @db.Timestamptz(6)
  resolvedById    String?               // auth_id of user who resolved
  
  // Creator info
  createdById     String                // auth_id of user who made prediction
  createdAt       DateTime              @default(now()) @db.Timestamptz(6)
  updatedAt       DateTime              @default(now()) @updatedAt @db.Timestamptz(6)
  
  // Related outcomes (evidence/observations)
  outcomes        PredictionOutcome[]
  
  @@index([claimId])
  @@index([deliberationId])
  @@index([status])
  @@index([createdById])
  @@index([deliberationId, status])
  @@index([claimId, status])
}

model PredictionOutcome {
  id              String                @id @default(cuid())
  
  // Which prediction does this evidence relate to?
  predictionId    String
  prediction      ClaimPrediction       @relation(fields: [predictionId], references: [id], onDelete: Cascade)
  
  // Evidence description
  description     String                @db.Text
  
  // Evidence type
  evidenceType    EvidenceType          @default(OBSERVATION)
  
  // Optional URL to evidence
  evidenceUrl     String?
  
  // When was this outcome observed?
  observedAt      DateTime              @default(now()) @db.Timestamptz(6)
  
  // Who recorded this outcome?
  recordedById    String                // auth_id
  recordedAt      DateTime              @default(now()) @db.Timestamptz(6)
  
  @@index([predictionId])
  @@index([recordedById])
}

// ============================================================
// PHASE 3.2: ARGUMENT-LEVEL CITATIONS
// ============================================================

/// Type of citation relationship between arguments
enum ArgCitationType {
  SUPPORT        // Citing to build upon/strengthen
  EXTENSION      // Extending the argument further
  APPLICATION    // Applying to new domain
  CONTRAST       // Citing as contrast/alternative
  REBUTTAL       // Citing to rebut
  REFINEMENT     // Refining/improving the argument
  METHODOLOGY    // Citing methodology/approach
  CRITIQUE       // Methodological critique
}

/// Citation relationship between arguments
model ArgumentCitation {
  id                String   @id @default(cuid())
  
  // The argument doing the citing
  citingArgumentId  String
  citingArgument    Argument @relation("CitingArguments", fields: [citingArgumentId], references: [id], onDelete: Cascade)
  
  // The argument being cited
  citedArgumentId   String
  citedArgument     Argument @relation("CitedByArguments", fields: [citedArgumentId], references: [id], onDelete: Cascade)
  
  // Type of citation
  citationType      ArgCitationType
  
  // Optional annotation explaining why/how
  annotation        String?  @db.Text
  
  // Context where citation appears - store as JSON with argumentId + claimId
  // (ArgumentPremise uses composite key, so we store reference info as JSON)
  citedInContext    Json?    // { premiseArgumentId, premiseClaimId }
  
  // Who created the citation
  createdById       String   // auth_id
  createdAt         DateTime @default(now())
  
  // Prevent duplicate citations
  @@unique([citingArgumentId, citedArgumentId])
  @@index([citingArgumentId])
  @@index([citedArgumentId])
  @@index([citationType])
}

/// Stable permalink for arguments (for academic citations)
model ArgumentPermalink {
  id            String   @id @default(cuid())
  
  // The argument this permalink refers to
  argumentId    String   @unique
  argument      Argument @relation(fields: [argumentId], references: [id], onDelete: Cascade)
  
  // Short code for URLs (e.g., "a7f3x2")
  shortCode     String   @unique
  
  // Human-readable slug (e.g., "climate-evidence-supports-action")
  slug          String?
  
  // Full permalink URL
  permalinkUrl  String
  
  // Version tracking (bump when argument significantly changes)
  version       Int      @default(1)
  
  // Access tracking
  accessCount   Int      @default(0)
  lastAccessedAt DateTime?
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@index([shortCode])
  @@index([slug])
}

/// Citation analytics/metrics per argument
model ArgumentCitationMetrics {
  id                    String   @id @default(cuid())
  
  // The argument these metrics are for
  argumentId            String   @unique
  argument              Argument @relation(fields: [argumentId], references: [id], onDelete: Cascade)
  
  // Total citations received
  totalCitations        Int      @default(0)
  
  // Citations by type
  supportCitations      Int      @default(0)
  extensionCitations    Int      @default(0)
  contrastCitations     Int      @default(0)
  rebuttalCitations     Int      @default(0)
  
  // Cross-deliberation citations (from other deliberations)
  externalCitations     Int      @default(0)
  
  // Self-citations (from same author)
  selfCitations         Int      @default(0)
  
  // Last recalculated
  lastCalculatedAt      DateTime @default(now())
  
  @@index([totalCitations])
}
