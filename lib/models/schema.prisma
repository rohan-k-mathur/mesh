generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
  engineType      = "library"
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  directUrl  = env("DIRECT_URL")
  extensions = [uuid_ossp(map: "uuid-ossp", schema: "extensions"), vector]
}

/// This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
model User {
  id                        BigInt                    @id @default(autoincrement())
  auth_id                   String                    @unique
  created_at                DateTime                  @default(now()) @db.Timestamptz(6)
  updated_at                DateTime?                 @default(now()) @updatedAt @db.Timestamptz(6)
  username                  String                    @db.VarChar
  name                      String
  image                     String?
  bio                       String?
  onboarded                 Boolean                   @default(false)
  archivedPosts             ArchivedPost[]
  archivedRealtimePosts     ArchivedRealtimePost[]
  conversationsUser1        Conversation[]            @relation("ConversationUser1")
  conversationsUser2        Conversation[]            @relation("ConversationUser2")
  conversation_participants ConversationParticipant[]
  favoriteItems             FavoriteItem[]
  following                 Follow[]                  @relation("FollowingRelation")
  followers                 Follow[]                  @relation("FollowerRelation")
  friendSuggestionsTarget   FriendSuggestion[]        @relation("SuggestionsTarget")
  friendSuggestionsCreated  FriendSuggestion[]        @relation("SuggestionsCreator")
  integrations              Integration[]
  likes                     Like[]
  linkedAccounts            LinkedAccount[]
  messages                  Message[]
  sentNotifications         Notification[]            @relation("NotificationActor")
  receivedNotifications     Notification[]            @relation("NotificationUser")
  productReviewVotes        ProductReviewVote[]
  productReviewVouches      ProductReviewVouch[]
  productReviews            ProductReview[]
  realtimeedges             RealtimeEdge[]
  realtimeLikes             RealtimeLike[]
  realtimeposts             RealtimePost[]
  feedPosts                 FeedPost[]
  libraryPosts              LibraryPost[]
  stacks                    Stack[]
  portfolioPages            PortfolioPage[] // 👈 back-relation
  annotations               Annotation[]
  realtimeRoomInviteTokens  RealtimeRoomInviteToken[]
  recommendationClicks      RecommendationClick[]
  attributeEdits            UserAttributeEdit[]
  userAttributes            UserAttributes?
  userEmbedding             UserEmbedding?
  createdPredictionMarkets  PredictionMarket[]        @relation("CreatedPredictionMarkets")
  oraclePredictionMarkets   PredictionMarket[]        @relation("OraclePredictionMarkets")
  trades                    Trade[]                   @relation("UserTrades")
  wallet                    Wallet?
  resolutionLogs            ResolutionLog[]
  realtimerooms             UserRealtimeRoom[]
  workflows                 Workflow[]
  stalls                    Stall[]
  offers                    Offer[]
  bids                      Bid[]
  orders                    Order[]
  StallMessage              StallMessage[]
  cartItems                 CartItem[]
  carts                     Cart[]
  settings                  UserSettings?
  Auction                   Auction[]
  StackCollaborator         StackCollaborator[]
  StackSubscription         StackSubscription[]
  SheafAudienceList         SheafAudienceList[]
  roles                     UserRole[]
  reactions                 MessageReaction[]
  driftMembers              DriftMember[]
  MessageMention            MessageMention[]
  // Stars & Bookmarks back-relations
  messageStars              MessageStar[]
  bookmarks                 Bookmark[]
  ActivityPubKey            ActivityPubKey[]
  ApFollower                ApFollower[]
  ApFollowing               ApFollowing[]
  ApOutboxActivity          ApOutboxActivity[]
  mergedReceipts            MergeReceipt[]            @relation("UserMergedReceipts")
  proposalSignals           ProposalSignal[]          @relation("UserProposalSignals")

  @@map("users")
}

model UserAttributes {
  id                  BigInt     @id @default(autoincrement())
  user_id             BigInt     @unique
  created_at          DateTime   @default(now()) @db.Timestamptz(6)
  artists             String[]
  albums              String[]
  songs               String[]
  interests           String[]
  movies              String[]
  birthday            DateTime?
  communities         String[]
  hobbies             String[]
  location            String?
  books               String[]
  events_visibility   visibility @default(PUBLIC)
  tv_visibility       visibility @default(PUBLIC)
  podcasts_visibility visibility @default(PUBLIC)
  updated_at          DateTime   @default(now()) @updatedAt @db.Timestamptz(6)
  user                User       @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@map("user_attributes")
}

/// This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
model Like {
  id           BigInt    @id @default(autoincrement())
  created_at   DateTime  @default(now()) @db.Timestamptz(6)
  score        Int
  type         like_type @default(LIKE)
  user_id      BigInt
  updated_at   DateTime? @default(now()) @updatedAt @db.Timestamptz(6)
  feed_post_id BigInt
  feedPost     FeedPost  @relation(fields: [feed_post_id], references: [id], onDelete: Cascade)
  user         User      @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([feed_post_id, user_id])
  @@map("likes")
}

model FeedPost {
  id BigInt @id @default(autoincrement())

  created_at DateTime       @default(now()) @db.Timestamptz(6)
  updated_at DateTime?      @default(now()) @updatedAt @db.Timestamptz(6)
  author_id  BigInt
  type       feed_post_type
  content    String?
  image_url  String?
  portfolio  Json? // <-- add this

  video_url        String?
  caption          String?
  isPublic         Boolean           @default(true)
  like_count       Int               @default(0)
  expiration_date  DateTime?
  author           User              @relation(fields: [author_id], references: [id])
  predictionMarket PredictionMarket? @relation("FeedPostPrediction")
  productReview    ProductReview?
  libraryPost      LibraryPost?      @relation(fields: [library_post_id], references: [id], onDelete: SetNull, onUpdate: Cascade)
  stack            Stack?            @relation(fields: [stack_id], references: [id], onDelete: SetNull, onUpdate: Cascade)
  articleId        String?           @unique
  thumbnailKey     String? // 4:3 hero variant stored in CDN
  tldr             String? // 280-char summary
  parent_id        BigInt?
  pluginData       Json?
  pluginType       String?
  feedPost         FeedPost?         @relation("FeedPostChildren", fields: [parent_id], references: [id], onDelete: Restrict)
  children         FeedPost[]        @relation("FeedPostChildren")
  Like             Like[]

  library_post_id String?
  stack_id        String?

  @@index([created_at])
  @@index([library_post_id])
  @@index([stack_id])
  @@index([author_id])
  @@map("feed_posts")
}

enum feed_post_type {
  TEXT
  VIDEO
  IMAGE
  LIVESTREAM
  IMAGE_COMPUTE
  COLLAGE
  GALLERY
  PORTAL
  AUDIO
  DRAW
  LIVECHAT
  DOCUMENT
  THREAD
  CODE
  PORTFOLIO
  LLM_INSTRUCTION
  PREDICTION
  PLUGIN
  PRODUCT_REVIEW
  ENTROPY
  MUSIC
  ROOM_CANVAS
  ARTICLE
  LIBRARY
}

model RealtimeLike {
  id               BigInt       @id @default(autoincrement())
  created_at       DateTime     @default(now()) @db.Timestamptz(6)
  score            Int
  type             like_type    @default(LIKE)
  user_id          BigInt
  realtime_post_id BigInt
  updated_at       DateTime?    @default(now()) @updatedAt @db.Timestamptz(6)
  realtime_post    RealtimePost @relation(fields: [realtime_post_id], references: [id], onDelete: Cascade)
  user             User         @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([realtime_post_id, user_id])
  @@map("realtime_likes")
}

model RealtimeRoom {
  id                       String                    @id
  created_at               DateTime                  @default(now()) @db.Timestamptz(6)
  room_icon                String
  isLounge                 Boolean                   @default(false)
  isPublic                 Boolean                   @default(false)
  realtimeedges            RealtimeEdge[]
  realtimeposts            RealtimePost[]
  realtimeRoomInviteTokens RealtimeRoomInviteToken[]
  members                  UserRealtimeRoom[]

  @@map("realtime_rooms")
}

model RealtimePost {
  id                 BigInt             @id @default(autoincrement())
  created_at         DateTime           @default(now()) @db.Timestamptz(6)
  content            String?
  image_url          String?
  video_url          String?
  caption            String?
  author_id          BigInt
  updated_at         DateTime?          @default(now()) @updatedAt @db.Timestamptz(6)
  like_count         Int                @default(0)
  x_coordinate       Decimal
  y_coordinate       Decimal
  type               realtime_post_type @default(TEXT)
  realtime_room_id   String
  locked             Boolean
  collageLayoutStyle String?
  collageColumns     Int?
  collageGap         Int?
  isPublic           Boolean            @default(false)
  parent_id          BigInt?
  expiration_date    DateTime?
  pluginData         Json?
  pluginType         String?
  room_post_content  Json?
  productReview      ProductReview?
  predictionMarket   PredictionMarket?  @relation(fields: [predictionMarketId], references: [id])
  outgoing_edges     RealtimeEdge[]     @relation("RealtimeEdgeToSourceRealtimePost")
  incoming_edges     RealtimeEdge[]     @relation("RealtimeEdgeToTargetRealtimePost")
  likes              RealtimeLike[]
  author             User               @relation(fields: [author_id], references: [id])
  realtimePost       RealtimePost?      @relation("RealtimePostChildren", fields: [parent_id], references: [id], onDelete: Restrict)
  children           RealtimePost[]     @relation("RealtimePostChildren")
  realtimeroom       RealtimeRoom       @relation(fields: [realtime_room_id], references: [id])
  predictionMarketId String?

  @@map("realtime_posts")
}

model RealtimeEdge {
  id               BigInt       @id @default(autoincrement())
  created_at       DateTime     @default(now()) @db.Timestamptz(6)
  updated_at       DateTime?    @default(now()) @updatedAt @db.Timestamptz(6)
  source_node_id   BigInt
  target_node_id   BigInt
  author_id        BigInt
  realtime_room_id String
  author           User         @relation(fields: [author_id], references: [id])
  realtimeroom     RealtimeRoom @relation(fields: [realtime_room_id], references: [id])
  sourceNode       RealtimePost @relation("RealtimeEdgeToSourceRealtimePost", fields: [source_node_id], references: [id])
  targetNode       RealtimePost @relation("RealtimeEdgeToTargetRealtimePost", fields: [target_node_id], references: [id])

  @@unique([source_node_id, target_node_id])
  @@map("realtime_edges")
}

model UserRealtimeRoom {
  id               BigInt       @id @default(autoincrement())
  user_id          BigInt
  realtime_room_id String
  joined_at        DateTime     @default(now()) @db.Timestamptz(6)
  realtime_room    RealtimeRoom @relation(fields: [realtime_room_id], references: [id], onDelete: Cascade)
  user             User         @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([user_id, realtime_room_id])
  @@map("users_realtime_rooms")
}

model RealtimeRoomInviteToken {
  id               BigInt       @id @default(autoincrement())
  token            String       @unique
  created_at       DateTime     @default(now()) @db.Timestamptz(6)
  expiration_date  DateTime?
  realtime_room_id String
  inviting_user_id BigInt
  inviting_user    User         @relation(fields: [inviting_user_id], references: [id], onDelete: Cascade)
  realtime_room    RealtimeRoom @relation(fields: [realtime_room_id], references: [id], onDelete: Cascade)

  @@map("realtime_room_invite_tokens")
}

model Follow {
  id           BigInt   @id @default(autoincrement())
  follower_id  BigInt
  following_id BigInt
  created_at   DateTime @default(now()) @db.Timestamptz(6)
  follower     User     @relation("FollowingRelation", fields: [follower_id], references: [id], onDelete: Cascade)
  following    User     @relation("FollowerRelation", fields: [following_id], references: [id], onDelete: Cascade)

  @@unique([follower_id, following_id])
  @@map("follows")
}

model ArchivedPost {
  id               BigInt    @id @default(autoincrement())
  original_post_id BigInt    @unique
  created_at       DateTime  @db.Timestamptz(6)
  content          String
  author_id        BigInt
  updated_at       DateTime? @db.Timestamptz(6)
  parent_id        BigInt?
  like_count       Int       @default(0)
  expiration_date  DateTime?
  archived_at      DateTime  @default(now()) @db.Timestamptz(6)
  author           User      @relation(fields: [author_id], references: [id])

  @@map("archived_posts")
}

model ArchivedRealtimePost {
  id                 BigInt             @id @default(autoincrement())
  original_post_id   BigInt             @unique
  created_at         DateTime           @db.Timestamptz(6)
  content            String?
  image_url          String?
  video_url          String?
  caption            String?
  author_id          BigInt
  updated_at         DateTime?          @db.Timestamptz(6)
  like_count         Int                @default(0)
  x_coordinate       Decimal
  y_coordinate       Decimal
  type               realtime_post_type @default(TEXT)
  realtime_room_id   String
  locked             Boolean            @default(false)
  collageLayoutStyle String?
  collageColumns     Int?
  collageGap         Int?
  isPublic           Boolean            @default(false)
  pluginType         String?
  pluginData         Json?
  parent_id          BigInt?
  expiration_date    DateTime?
  archived_at        DateTime           @default(now()) @db.Timestamptz(6)
  author             User               @relation(fields: [author_id], references: [id])

  @@map("archived_realtime_posts")
}

model UserEmbedding {
  user_id    BigInt   @id
  embedding  Float[]
  updated_at DateTime @default(now()) @updatedAt @db.Timestamptz(6)
  user       User     @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@map("user_embeddings")
}

model FriendSuggestion {
  id                BigInt   @id @default(autoincrement())
  user_id           BigInt
  suggested_user_id BigInt
  score             Float
  created_at        DateTime @default(now()) @db.Timestamptz(6)
  suggestedUser     User     @relation("SuggestionsTarget", fields: [suggested_user_id], references: [id], onDelete: Cascade)
  user              User     @relation("SuggestionsCreator", fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([user_id, suggested_user_id])
  @@map("friend_suggestions")
}

model Workflow {
  id              BigInt   @id @default(autoincrement())
  owner_id        BigInt
  name            String
  is_active       Boolean  @default(true)
  current_version Int      @default(1)
  created_at      DateTime @default(now()) @db.Timestamptz(6)
  updated_at      DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  versions           WorkflowVersion[]
  runs               WorkflowRun[]
  scheduledWorkflows ScheduledWorkflow[]
  // keep these if you still use the state-machine builder:
  states             WorkflowState[]
  transitions        WorkflowTransition[]

  owner User @relation(fields: [owner_id], references: [id], onDelete: Cascade)

  @@map("workflows")
}

model WorkflowVersion {
  id          BigInt   @id @default(autoincrement())
  workflow_id BigInt
  version     Int
  dsl         Json // { steps: Step[], edges: Edge[] } for the linear builder
  created_at  DateTime @default(now()) @db.Timestamptz(6)
  created_by  BigInt?

  workflow Workflow @relation(fields: [workflow_id], references: [id], onDelete: Cascade)

  @@unique([workflow_id, version])
  @@map("workflow_versions")
}

enum WorkflowRunStatus {
  PENDING
  RUNNING
  SUCCEEDED
  FAILED
  CANCELLED
  PAUSED
}

model WorkflowRun {
  id              BigInt            @id @default(autoincrement())
  workflow_id     BigInt
  version         Int
  status          WorkflowRunStatus @default(PENDING)
  trigger_kind    String? // "cron" | "webhook" | "manual"
  trigger_payload Json?
  started_at      DateTime          @default(now()) @db.Timestamptz(6)
  finished_at     DateTime?         @db.Timestamptz(6)
  error           Json?

  workflow Workflow          @relation(fields: [workflow_id], references: [id], onDelete: Cascade)
  steps    WorkflowRunStep[]

  @@index([workflow_id, started_at])
  @@map("workflow_runs")
}

enum StepStatus {
  PENDING
  RUNNING
  SUCCEEDED
  FAILED
  SKIPPED
}

model WorkflowRunStep {
  id          BigInt     @id @default(autoincrement())
  run_id      BigInt
  step_id     String // DSL Step.id
  action_ref  String?
  status      StepStatus @default(PENDING)
  input       Json?
  output      Json?
  error       Json?
  attempt     Int        @default(0)
  started_at  DateTime?  @db.Timestamptz(6)
  finished_at DateTime?  @db.Timestamptz(6)
  duration_ms Int?

  run WorkflowRun @relation(fields: [run_id], references: [id], onDelete: Cascade)

  @@index([run_id, step_id])
  @@map("workflow_run_steps")
}

model WorkflowState {
  id              BigInt               @id @default(autoincrement())
  workflow_id     BigInt
  version         Int
  graph           Json
  created_at      DateTime             @default(now()) @db.Timestamptz(6)
  updated_at      DateTime?            @default(now()) @updatedAt @db.Timestamptz(6)
  workflow        Workflow             @relation(fields: [workflow_id], references: [id], onDelete: Cascade)
  fromTransitions WorkflowTransition[] @relation("WorkflowTransitionFromState")
  toTransitions   WorkflowTransition[] @relation("WorkflowTransitionToState")

  @@unique([workflow_id, version])
  @@map("workflow_states")
}

model WorkflowTransition {
  id            BigInt        @id @default(autoincrement())
  workflow_id   BigInt
  from_state_id BigInt
  to_state_id   BigInt
  version       Int
  created_at    DateTime      @default(now()) @db.Timestamptz(6)
  fromState     WorkflowState @relation("WorkflowTransitionFromState", fields: [from_state_id], references: [id])
  toState       WorkflowState @relation("WorkflowTransitionToState", fields: [to_state_id], references: [id])
  workflow      Workflow      @relation(fields: [workflow_id], references: [id], onDelete: Cascade)

  @@map("workflow_transitions")
}

model UserAttributeEdit {
  id         BigInt   @id @default(autoincrement())
  user_id    BigInt
  created_at DateTime @default(now()) @db.Timestamptz(6)
  user       User     @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@map("user_attribute_edits")
}

model RecommendationClick {
  id                  BigInt   @id @default(autoincrement())
  user_id             BigInt
  recommended_user_id BigInt?
  recommended_room_id String?
  created_at          DateTime @default(now()) @db.Timestamptz(6)
  user                User     @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@map("recommendation_clicks")
}

model ScheduledWorkflow {
  id          BigInt   @id @default(autoincrement())
  workflow_id BigInt
  cron        String?
  trigger     String? // e.g., "webhook" (plus secret in metadata)
  metadata    Json?
  created_at  DateTime @default(now()) @db.Timestamptz(6)
  updated_at  DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  workflow Workflow @relation(fields: [workflow_id], references: [id], onDelete: Cascade)

  @@map("scheduled_workflows")
}

enum IntegrationStatus {
  CONNECTED
  NEEDS_REAUTH
  REVOKED
}

model Integration {
  id                   BigInt            @id @default(autoincrement())
  user_id              BigInt
  service              String
  external_account_id  String? // e.g. shop domain, gmail address, stripe_account id
  scopes               String[]          @default([]) // least-privilege scope list
  access_token_cipher  Bytes?
  refresh_token_cipher Bytes?
  expires_at           DateTime?         @db.Timestamptz(6)
  status               IntegrationStatus @default(CONNECTED)
  metadata             Json?

  // legacy field during transition (can remove after backfill)
  credential String

  created_at DateTime @default(now()) @db.Timestamptz(6)
  updated_at DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([user_id, service, external_account_id])
  @@index([user_id, service])
  @@map("integrations")
}

model LinkedAccount {
  id            BigInt    @id @default(autoincrement())
  user_id       BigInt
  provider      String
  access_token  String
  refresh_token String
  expires_at    DateTime? @db.Timestamptz(6)
  created_at    DateTime  @default(now()) @db.Timestamptz(6)
  user          User      @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([user_id, provider])
  @@index([user_id])
  @@map("linked_accounts")
}

model ProductReview {
  id               BigInt               @id @default(autoincrement())
  realtime_post_id BigInt?              @unique
  feed_post_id     BigInt?              @unique
  author_id        BigInt
  product_name     String
  rating           Int
  summary          String?
  created_at       DateTime             @default(now()) @db.Timestamptz(6)
  updated_at       DateTime             @default(now()) @updatedAt @db.Timestamptz(6)
  product_link     String?
  image_urls       String[]
  claims           ProductReviewClaim[]
  author           User                 @relation(fields: [author_id], references: [id], onDelete: Cascade)
  realtime_post    RealtimePost?        @relation(fields: [realtime_post_id], references: [id])
  feed_post        FeedPost?            @relation(fields: [feed_post_id], references: [id])

  @@map("product_reviews")
}

model ProductReviewClaim {
  id              BigInt               @id @default(autoincrement())
  review_id       BigInt
  text            String
  created_at      DateTime             @default(now()) @db.Timestamptz(6)
  helpful_count   Int                  @default(0)
  unhelpful_count Int                  @default(0)
  vouch_total     Int                  @default(0)
  review          ProductReview        @relation(fields: [review_id], references: [id], onDelete: Cascade)
  votes           ProductReviewVote[]
  vouches         ProductReviewVouch[]

  @@map("product_review_claims")
}

model ProductReviewVote {
  id         BigInt             @id @default(autoincrement())
  claim_id   BigInt
  user_id    BigInt
  type       String
  created_at DateTime           @default(now()) @db.Timestamptz(6)
  claim      ProductReviewClaim @relation(fields: [claim_id], references: [id], onDelete: Cascade)
  user       User               @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([claim_id, user_id])
  @@map("product_review_votes")
}

model ProductReviewVouch {
  id         BigInt             @id @default(autoincrement())
  claim_id   BigInt
  user_id    BigInt
  amount     Int
  created_at DateTime           @default(now()) @db.Timestamptz(6)
  claim      ProductReviewClaim @relation(fields: [claim_id], references: [id], onDelete: Cascade)
  user       User               @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([claim_id, user_id])
  @@map("product_review_vouches")
}

model Conversation {
  id              BigInt                    @id @default(autoincrement())
  user1_id        BigInt?
  user2_id        BigInt?
  created_at      DateTime                  @default(now()) @db.Timestamptz(6)
  updated_at      DateTime                  @default(now()) @updatedAt @db.Timestamptz(6)
  title           String?
  is_group        Boolean                   @default(false)
  user1           User?                     @relation("ConversationUser1", fields: [user1_id], references: [id])
  user2           User?                     @relation("ConversationUser2", fields: [user2_id], references: [id])
  messages        Message[]
  notifications   Notification[]            @relation("NotificationConversation")
  participants    ConversationParticipant[]
  drifts          Drift[]                   @relation("ConversationDrifts")
  proposalSignals ProposalSignal[]          @relation("ConversationProposalSignals")

  @@unique([user1_id, user2_id])
  @@index([user1_id])
  @@index([user2_id])
  @@map("conversations")
}

model ConversationParticipant {
  id              BigInt       @id @default(autoincrement())
  conversation_id BigInt
  user_id         BigInt
  joined_at       DateTime     @default(now()) @db.Timestamptz(6)
  conversation    Conversation @relation(fields: [conversation_id], references: [id], onDelete: Cascade)
  user            User         @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([conversation_id, user_id])
  @@index([user_id])
  @@map("conversation_participants")
}

model MessageAttachment {
  id         BigInt   @id @default(autoincrement())
  created_at DateTime @default(now()) @db.Timestamptz(6)
  message_id BigInt
  path       String
  type       String
  size       Int
  metadata   Json?
  message    Message  @relation(fields: [message_id], references: [id], onDelete: Cascade)

  @@index([message_id])
  @@map("message_attachments")
}

model Message {
  id              BigInt              @id @default(autoincrement())
  conversation_id BigInt
  sender_id       BigInt
  text            String?
  created_at      DateTime            @default(now()) @db.Timestamptz(6)
  conversation    Conversation        @relation(fields: [conversation_id], references: [id], onDelete: Cascade)
  sender          User                @relation(fields: [sender_id], references: [id], onDelete: Cascade)
  notifications   Notification[]      @relation("NotificationMessage")
  attachments     MessageAttachment[]

  // moderation / lifecycle
  is_redacted Boolean   @default(false)
  edited_at   DateTime? @db.Timestamptz(6)
  deleted_at  DateTime? @db.Timestamptz(6)
  client_id   String?   @db.VarChar(64)

  // Drifts & Threads
  drift_id        BigInt? // FK column
  reply_to        BigInt?
  reply_count     Int              @default(0)
  last_reply_at   DateTime?
  anchoredDrift   Drift?           @relation("DriftAnchor")
  proposalSignals ProposalSignal[] @relation("MessageProposalSignals")

  // Misc
  meta Json?

  // relations

  reactions        MessageReaction[]
  SheafFacet       SheafFacet[]
  SheafMessageMeta SheafMessageMeta[]

  // 👇 exactly ONE relation field to Drift, named `drift` (or `Drift`, but only once)
  drift          Drift?           @relation("DriftMessages", fields: [drift_id], references: [id])
  MessageMention MessageMention[]

  // Stars & Bookmarks back-relations
  stars     MessageStar[]
  bookmarks Bookmark[]

  // --- GitChat receipts ---
  mergeReceipts MergeReceipt[]

  @@unique([conversation_id, client_id])
  @@index([conversation_id, created_at])
  @@index([drift_id])
  @@index([reply_to])
  @@map("messages")
}

enum DriftKind {
  DRIFT
  THREAD
  PROPOSAL
}

model Drift {
  id                BigInt    @id @default(autoincrement())
  conversation_id   BigInt
  created_by        BigInt
  title             String
  created_at        DateTime  @default(now()) @db.Timestamptz(6)
  updated_at        DateTime  @updatedAt @db.Timestamptz(6)
  is_closed         Boolean   @default(false)
  is_archived       Boolean   @default(false)
  message_count     Int       @default(0)
  last_message_at   DateTime?
  anchor_message_id BigInt?   @unique
  kind              DriftKind @default(DRIFT)
  root_message_id   BigInt? // <— root message for kind=THREAD

  // relations
  conversation   Conversation @relation("ConversationDrifts", fields: [conversation_id], references: [id], onDelete: Cascade)
  anchor_message Message?     @relation("DriftAnchor", fields: [anchor_message_id], references: [id], onDelete: Cascade)

  // 👇 inverse side of the relation; MUST use the same name "DriftMessages"
  messages Message[] @relation("DriftMessages")

  members DriftMember[]

  @@unique([conversation_id, root_message_id, kind], map: "uniq_thread_per_root")
  @@index([root_message_id, kind]) // ✅ add this line here
  @@index([conversation_id])
  @@index([root_message_id])
  @@map("drifts")
}

model DriftMember {
  id           BigInt    @id @default(autoincrement())
  drift_id     BigInt
  user_id      BigInt
  joined_at    DateTime  @default(now()) @db.Timestamptz(6)
  collapsed    Boolean   @default(true)
  pinned       Boolean   @default(false)
  muted        Boolean   @default(false)
  last_read_at DateTime?

  drift Drift @relation(fields: [drift_id], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([drift_id, user_id])
  @@index([user_id])
  @@map("drift_members")
}

enum PollKind {
  OPTIONS
  TEMP
}

model Poll {
  id              BigInt    @id @default(autoincrement())
  conversation_id BigInt
  message_id      BigInt
  created_by_id   BigInt
  kind            PollKind
  options         String[]  @default([])
  max_options     Int       @default(1)
  closes_at       DateTime? @db.Timestamptz(6)
  anonymous       Boolean   @default(false)
  created_at      DateTime  @default(now()) @db.Timestamptz(6)

  votes PollVote[]

  @@index([conversation_id])
  @@map("polls")
}

model PollVote {
  id         BigInt   @id @default(autoincrement())
  poll_id    BigInt
  user_id    BigInt
  option_idx Int?
  value      Int?
  created_at DateTime @default(now()) @db.Timestamptz(6)

  poll Poll @relation(fields: [poll_id], references: [id], onDelete: Cascade)

  @@unique([poll_id, user_id])
  @@map("poll_votes")
}

model CanonicalMedia {
  id            String         @id
  title         String
  mediaType     String
  metadata      Json?
  embedding     Float[]
  updatedAt     DateTime       @updatedAt
  favoriteItems FavoriteItem[]

  @@map("canonical_media")
}

model FavoriteItem {
  mediaId String
  rating  Int?
  addedAt DateTime       @default(now())
  userId  BigInt
  media   CanonicalMedia @relation(fields: [mediaId], references: [id], onDelete: Cascade)
  user    User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, mediaId])
  @@index([userId])
  @@map("favorite_items")
}

model Notification {
  id              BigInt            @id @default(autoincrement())
  user_id         BigInt
  actor_id        BigInt
  type            notification_type
  conversation_id BigInt?
  message_id      BigInt?
  market_id       String?
  trade_id        String?
  created_at      DateTime          @default(now()) @db.Timestamptz(6)
  read            Boolean           @default(false)
  actor           User              @relation("NotificationActor", fields: [actor_id], references: [id], onDelete: Cascade)
  conversation    Conversation?     @relation("NotificationConversation", fields: [conversation_id], references: [id], onDelete: Cascade)
  message         Message?          @relation("NotificationMessage", fields: [message_id], references: [id], onDelete: Cascade)
  market          PredictionMarket? @relation("PredictionMarketNotifications", fields: [market_id], references: [id])
  trade           Trade?            @relation("TradeNotifications", fields: [trade_id], references: [id])
  user            User              @relation("NotificationUser", fields: [user_id], references: [id], onDelete: Cascade)

  @@index([user_id])
  @@map("notifications")
}

/// --- Stars & Bookmarks ---
model MessageStar {
  user_id    BigInt
  message_id BigInt
  created_at DateTime @default(now()) @db.Timestamptz(6)

  user    User    @relation(fields: [user_id], references: [id], onDelete: Cascade)
  message Message @relation(fields: [message_id], references: [id], onDelete: Cascade)

  @@id([user_id, message_id])
  @@index([user_id, created_at])
  @@map("message_stars")
}

model Bookmark {
  id         BigInt   @id @default(autoincrement())
  user_id    BigInt
  message_id BigInt
  label      String?
  created_at DateTime @default(now()) @db.Timestamptz(6)

  user    User    @relation(fields: [user_id], references: [id], onDelete: Cascade)
  message Message @relation(fields: [message_id], references: [id], onDelete: Cascade)

  @@unique([user_id, message_id])
  @@index([user_id, created_at])
  @@map("bookmarks")
}

model PortfolioPage {
  id         BigInt   @id @default(autoincrement())
  slug       String   @unique
  html       String
  css        String
  tsx        String? // existing
  payload    Json? // <‑‑ NEW (optional)
  snapshot   String? // <‑‑ NEW (optional helper)
  created_at DateTime @default(now()) @db.Timestamptz(6)
  owner_id   BigInt?
  owner      User?    @relation(fields: [owner_id], references: [id], onDelete: Cascade)

  @@index([owner_id, created_at])
  @@map("portfolio_pages")
}

// prisma/schema.prisma
model ProfileSite {
  id        BigInt   @id @default(autoincrement())
  slug      String   @unique
  ownerId   BigInt   @map("owner_id")
  title     String?
  caption   String?
  pageUrl   String   @map("page_url")
  snapshot  String?
  isPublic  Boolean  @default(true) @map("is_public")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("profile_sites")
}

model scroll_events {
  id         BigInt   @id @default(autoincrement())
  user_id    String   @db.Uuid
  content_id String?  @db.Uuid
  dwell_ms   Int
  created_at DateTime @default(now()) @db.Timestamptz(6)

  @@index([user_id], map: "scroll_events_user_idx")
}

model user_taste_vectors {
  user_id    BigInt                @id
  taste      Unsupported("vector")
  traits     Json?                 @default("{}")
  updated_at DateTime              @default(now()) @db.Timestamptz(6)

  @@index([taste], map: "user_taste_vectors_ann")
}

model track_embedding {
  vector    Unsupported("vector")
  createdAt DateTime              @default(now())
  track_id  String                @id

  @@map("track_embedding")
}

model UserSimilarityKnn {
  user_id      BigInt
  neighbour_id BigInt
  sim          Float
  created_at   DateTime @default(now()) @db.Timestamptz(6)

  @@id([user_id, neighbour_id])
  @@map("user_similarity_knn")
}

model PredictionMarket {
  id         String          @id @default(cuid())
  postId     BigInt          @unique
  question   String          @db.VarChar(140)
  closesAt   DateTime
  closedAt   DateTime?
  resolvesAt DateTime?
  state      PredictionState @default(OPEN)
  outcome    MarketOutcome?
  b          Float           @default(100)
  yesPool    Float           @default(0)
  noPool     Float           @default(0)
  creatorId  BigInt
  oracleId   BigInt?

  trades         Trade[]
  notifications  Notification[]  @relation("PredictionMarketNotifications")
  post           FeedPost        @relation("FeedPostPrediction", fields: [postId], references: [id])
  creator        User            @relation("CreatedPredictionMarkets", fields: [creatorId], references: [id])
  oracle         User?           @relation("OraclePredictionMarkets", fields: [oracleId], references: [id])
  RealtimePost   RealtimePost[]
  resolutionLogs ResolutionLog[]

  @@map("prediction_markets")
}

model Trade {
  id        String        @id @default(cuid())
  marketId  String
  userId    BigInt
  side      MarketOutcome
  shares    Float
  price     Float
  cost      Int
  createdAt DateTime      @default(now()) @db.Timestamptz(6)

  market        PredictionMarket @relation(fields: [marketId], references: [id])
  user          User             @relation("UserTrades", fields: [userId], references: [id])
  notifications Notification[]   @relation("TradeNotifications")

  @@index([marketId])
  @@index([userId])
  @@index([marketId, userId], name: "idx_trade_market_user")
  @@map("prediction_trades")
}

model Wallet {
  userId       BigInt @id
  balanceCents Int    @default(0)
  lockedCents  Int    @default(0)

  user User @relation(fields: [userId], references: [id])

  @@map("wallet")
}

model ResolutionLog {
  id         BigInt            @id @default(autoincrement())
  market     PredictionMarket  @relation(fields: [marketId], references: [id])
  marketId   String
  resolver   User              @relation(fields: [resolverId], references: [id])
  resolverId BigInt
  outcome    ResolutionOutcome
  createdAt  DateTime          @default(now())

  @@map("resolution_log")
}

enum ResolutionOutcome {
  YES
  NO
  N_A
}

enum PredictionState {
  OPEN
  CLOSED
  RESOLVED
}

enum MarketOutcome {
  YES
  NO
}

enum like_type {
  LIKE
  DISLIKE
}

enum realtime_post_type {
  TEXT
  VIDEO
  IMAGE
  LIVESTREAM
  IMAGE_COMPUTE
  COLLAGE
  GALLERY
  PORTAL
  AUDIO
  DRAW
  LIVECHAT
  DOCUMENT
  THREAD
  CODE
  PORTFOLIO
  LLM_INSTRUCTION
  PREDICTION
  PLUGIN
  PRODUCT_REVIEW
  ENTROPY
  MUSIC
  ROOM_CANVAS
}

enum visibility {
  PUBLIC
  FOLLOWERS
  PRIVATE
}

enum notification_type {
  FOLLOW
  MESSAGE
  TRADE_EXECUTED
  MARKET_RESOLVED
}

model Section {
  id           BigInt   @id @default(autoincrement())
  x            Int
  y            Int
  visitors     Int      @default(0)
  liveCount    Int      @default(0)
  auctionCount Int      @default(0)
  created_at   DateTime @default(now()) @db.Timestamptz(6)
  updated_at   DateTime @default(now()) @updatedAt @db.Timestamptz(6)
  stalls       Stall[]

  @@unique([x, y])
  @@map("section") // 👈 tell Prisma the real table name
}

model Stall {
  id           BigInt         @id @default(autoincrement())
  section_id   BigInt?
  owner_id     BigInt
  name         String
  seller_id    BigInt?
  seller       Seller?        @relation(fields: [seller_id], references: [id])
  created_at   DateTime       @default(now()) @db.Timestamptz(6)
  updated_at   DateTime       @default(now()) @updatedAt @db.Timestamptz(6)
  section      Section?       @relation(fields: [section_id], references: [id])
  owner        User           @relation(fields: [owner_id], references: [id])
  items        Item[]
  auctions     Auction[]
  orders       Order[]
  images       StallImage[]
  StallMessage StallMessage[]
  live         Boolean        @default(false)
  liveSrc      String? // nullable -> no stream yet
  doc          Json?
  Offer        Offer[]

  @@unique([section_id, owner_id])
  @@index([section_id])
  @@index([owner_id, updated_at])
  @@map("stalls")
}

model StallImage {
  id         BigInt   @id @default(autoincrement())
  stall_id   BigInt
  url        String
  blurhash   String?
  created_at DateTime @default(now()) @db.Timestamptz(6)
  position   Int      @default(0)
  stall      Stall    @relation(fields: [stall_id], references: [id])

  @@index([stall_id, position])
  @@map("stall_image")
}

// ---------- ITEM ----------
model Item {
  id          BigInt   @id @default(autoincrement())
  stall_id    BigInt
  name        String
  description String
  price       Decimal? @db.Decimal(12, 2)
  currency    String   @default("usd")
  stock       Int
  images      String[] // PG array
  created_at  DateTime @default(now()) @db.Timestamptz(6)

  stall      Stall       @relation(fields: [stall_id], references: [id])
  offers     Offer[]
  auction    Auction?
  orderItems OrderItem[]
  cartItems  CartItem[]
  OrderLine  OrderLine[]

  @@index([stall_id])
  @@map("items")
}

model Seller {
  id                   BigInt  @id @default(autoincrement()) // <-- give Seller the ids
  stripeAccountId      String? @unique
  stripeChargesEnabled Boolean @default(false)
  stalls               Stall[]
  Offer                Offer[]
}

// ---------- OFFER ----------
model Offer {
  id            BigInt      @id @default(autoincrement())
  stall_id      BigInt
  item_id       BigInt?
  buyer_id      BigInt
  seller_id     BigInt
  amount        Decimal     @db.Decimal(12, 2)
  currency      String      @default("usd")
  status        OfferStatus @default(PENDING)
  counter_of_id BigInt?
  expires_at    DateTime?
  version       Int         @default(1)
  message       String?
  created_at    DateTime    @default(now()) @db.Timestamptz(6)
  updated_at    DateTime    @default(now()) @updatedAt @db.Timestamptz(6)

  stall  Stall  @relation(fields: [stall_id], references: [id])
  item   Item?  @relation(fields: [item_id], references: [id])
  buyer  User   @relation(fields: [buyer_id], references: [id])
  seller Seller @relation(fields: [seller_id], references: [id])

  counterOf Offer?  @relation("OfferCounters", fields: [counter_of_id], references: [id])
  counters  Offer[] @relation("OfferCounters")

  // reservation for checkout
  cart       Cart?        @relation("CartOffer")
  OfferEvent OfferEvent[]

  @@index([stall_id, status])
  @@index([buyer_id, status])
  @@index([item_id, status])
  @@map("offers")
}

enum OfferEventKind {
  CREATED
  COUNTERED
  ACCEPTED
  REJECTED
  EXPIRED
}

model OfferEvent {
  id         BigInt         @id @default(autoincrement())
  offer_id   BigInt
  kind       OfferEventKind
  payload    Json?
  created_at DateTime       @default(now()) @db.Timestamptz(6)

  offer Offer @relation(fields: [offer_id], references: [id])

  @@index([offer_id])
  @@map("offer_events")
}

// ---------- AUCTION / BID ----------
model Auction {
  id         BigInt        @id @default(autoincrement())
  item_id    BigInt        @unique
  stall_id   BigInt
  reserve    Decimal       @db.Decimal(12, 2)
  currency   String        @default("usd")
  ends_at    DateTime
  state      auction_state @default(LIVE)
  winner_id  BigInt?
  created_at DateTime      @default(now()) @db.Timestamptz(6)

  item   Item    @relation(fields: [item_id], references: [id])
  stall  Stall   @relation(fields: [stall_id], references: [id])
  winner User?   @relation(fields: [winner_id], references: [id])
  bids   Bid[]
  Order  Order[]

  @@index([stall_id])
  @@index([ends_at, state])
  @@map("auctions")
}

model Bid {
  id         BigInt   @id @default(autoincrement())
  auction_id BigInt
  bidder_id  BigInt
  amount     Decimal  @db.Decimal(12, 2)
  created_at DateTime @default(now()) @db.Timestamptz(6)

  auction Auction @relation(fields: [auction_id], references: [id])
  bidder  User    @relation(fields: [bidder_id], references: [id])

  @@index([auction_id, created_at])
  @@map("bids")
}

enum OfferStatus {
  PENDING
  ACCEPTED
  REJECTED
  EXPIRED
}

enum OrderStatus {
  PENDING_PAYMENT
  AUTHORIZED
  PAID
  FULFILLED
  RELEASED
  DISPUTED
  REFUNDED
  CANCELLED
}

// ---------- ORDERS / CART / ESCROW ----------
model Order {
  id           BigInt      @id @default(autoincrement())
  stall_id     BigInt
  buyer_id     BigInt?
  auction_id   BigInt?
  status       OrderStatus @default(PENDING_PAYMENT)
  subtotal     Decimal?    @db.Decimal(12, 2)
  shipping     Decimal?    @db.Decimal(12, 2)
  total        Decimal?    @db.Decimal(12, 2)
  currency     String      @default("usd")
  stripePI     String?
  pmId         String?
  fulfilled_at DateTime?
  released_at  DateTime?
  hold_days    Int         @default(3)
  created_at   DateTime    @default(now()) @db.Timestamptz(6)
  updated_at   DateTime    @default(now()) @updatedAt @db.Timestamptz(6)

  stall   Stall    @relation(fields: [stall_id], references: [id])
  buyer   User?    @relation(fields: [buyer_id], references: [id])
  auction Auction? @relation(fields: [auction_id], references: [id])

  items     OrderItem[]
  OrderLine OrderLine[]

  @@index([stall_id, status])
  @@map("orders")
}

model OrderItem {
  id         BigInt   @id @default(autoincrement())
  order_id   BigInt
  item_id    BigInt
  qty        Int
  unit_price Decimal? @db.Decimal(12, 2) // TEMP: nullable if you just added it
  created_at DateTime @default(now()) @db.Timestamptz(6)

  order Order @relation(fields: [order_id], references: [id])
  item  Item  @relation(fields: [item_id], references: [id])

  @@index([order_id])
  @@map("order_items")
}

model OrderLine {
  id          BigInt   @id @default(autoincrement())
  order_id    BigInt?
  item_id     BigInt?
  quantity    Int?
  price_cents Int?
  created_at  DateTime @default(now()) @db.Timestamptz(6)
  order       Order?   @relation(fields: [order_id], references: [id])
  item        Item?    @relation(fields: [item_id], references: [id])

  @@index([order_id])
  @@map("order_lines")
}

model StallMessage {
  id         BigInt   @id @default(autoincrement())
  stall_id   BigInt
  user_id    BigInt
  text       String
  created_at DateTime @default(now()) @db.Timestamptz(6)

  stall Stall @relation(fields: [stall_id], references: [id])
  user  User  @relation(fields: [user_id], references: [id])

  @@index([stall_id])
  @@map("stall_messages")
}

model CartItem {
  id         BigInt   @id @default(autoincrement())
  user_id    BigInt
  item_id    BigInt
  qty        Int      @default(1)
  created_at DateTime @default(now()) @db.Timestamptz(6)

  user User @relation(fields: [user_id], references: [id])
  item Item @relation(fields: [item_id], references: [id])

  @@unique([user_id, item_id])
  @@map("cart_items")
}

enum escrow_state {
  PENDING
  HELD
  RELEASED
  REFUNDED
}

// Offer reservation (one-per-offer)
model Cart {
  id         BigInt   @id @default(autoincrement())
  user_id    BigInt
  offer_id   BigInt   @unique
  deadline   DateTime @db.Timestamptz(6)
  created_at DateTime @default(now()) @db.Timestamptz(6)

  offer  Offer   @relation("CartOffer", fields: [offer_id], references: [id])
  user   User    @relation(fields: [user_id], references: [id])
  escrow Escrow? @relation("CartEscrow")

  @@index([user_id])
  @@map("cart")
}

model Escrow {
  id         BigInt       @id @default(autoincrement())
  cart_id    BigInt       @unique
  state      escrow_state @default(PENDING)
  tx_ref     String?
  created_at DateTime     @default(now()) @db.Timestamptz(6)
  updated_at DateTime     @default(now()) @updatedAt @db.Timestamptz(6)

  cart Cart @relation("CartEscrow", fields: [cart_id], references: [id])

  @@map("escrow")
}

model PartyPresence {
  id         String   @id @default(cuid())
  party_id   String
  user_id    BigInt
  x          Int
  y          Int
  updated_at DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([party_id])
  @@map("party_presence")
}

model StallHeat {
  id       BigInt @id @default(autoincrement())
  stall_id BigInt
  cell     Int
  views    Int

  @@unique([stall_id, cell], name: "stall_id_cell")
  @@map("stall_heat")
}

model GroupMeeting {
  id              String   @id @default(uuid())
  title           String?
  participantUids String[]
  origins         Json?
  votes           Json?
  status          String   @default("init")
  createdAt       DateTime @default(now())

  @@map("group_meetings")
}

model UserSettings {
  user_id    BigInt   @id
  prefs      Json     @default("{}")
  updated_at DateTime @updatedAt

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@map("user_settings")
}

model WorkspaceSettings {
  workspace_id BigInt   @id
  prefs        Json     @default("{}")
  updated_at   DateTime @updatedAt

  @@map("workspace_settings")
}

model Telemetry {
  id        BigInt   @id @default(autoincrement())
  event     String
  coords    String
  userId    BigInt?
  createdAt DateTime @default(now()) @db.Timestamptz(6)

  @@index([event, createdAt])
}

enum auction_state {
  LIVE
  CLOSED
}

enum ArticleStatus {
  DRAFT
  PUBLISHED
}

model LibraryPost {
  id          String   @id @default(cuid())
  uploader_id BigInt
  stack_id    String?
  title       String?
  page_count  Int
  file_url    String
  thumb_urls  String[]
  created_at  DateTime @default(now()) @db.Timestamptz(6)

  annotations Annotation[]
  stack       Stack?       @relation(fields: [stack_id], references: [id])
  uploader    User         @relation(fields: [uploader_id], references: [id], onDelete: Cascade)
  feedPosts   FeedPost[]

  @@index([uploader_id, created_at])
  @@index([stack_id])
  @@map("library_posts")
}

model Stack {
  id            String              @id @default(cuid())
  owner_id      BigInt
  name          String
  description   String?
  is_public     Boolean             @default(false)
  order         String[]
  created_at    DateTime            @default(now()) @db.Timestamptz(6)
  parent_id     String?
  slug          String?             @unique
  owner         User                @relation(fields: [owner_id], references: [id], onDelete: Cascade)
  posts         LibraryPost[]
  parent        Stack?              @relation("StackHierarchy", fields: [parent_id], references: [id])
  children      Stack[]             @relation("StackHierarchy")
  feedPosts     FeedPost[]
  collaborators StackCollaborator[]
  subscribers   StackSubscription[]

  @@unique([owner_id, name])
  @@map("stacks")
}

enum StackRole {
  OWNER
  EDITOR
  VIEWER
}

model StackCollaborator {
  stack_id   String
  user_id    BigInt
  role       StackRole @default(EDITOR)
  created_at DateTime  @default(now()) @db.Timestamptz(6)

  stack Stack @relation(fields: [stack_id], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@id([stack_id, user_id])
  @@index([user_id])
  @@index([stack_id])
  @@map("stack_collaborators")
}

model StackSubscription {
  stack_id   String
  user_id    BigInt
  created_at DateTime @default(now()) @db.Timestamptz(6)

  stack Stack @relation(fields: [stack_id], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@id([stack_id, user_id])
  @@index([user_id])
  @@index([stack_id])
  @@map("stack_subscriptions")
}

model Annotation {
  id         String   @id @default(cuid())
  post_id    String
  page       Int
  rect       Json
  text       String
  author_id  BigInt
  created_at DateTime @default(now()) @db.Timestamptz(6)

  post   LibraryPost @relation(fields: [post_id], references: [id], onDelete: Cascade)
  author User        @relation(fields: [author_id], references: [id])

  @@index([post_id])
  @@map("annotations")
}

model CommentThread {
  id        String    @id @default(cuid())
  articleId String
  article   Article   @relation(fields: [articleId], references: [id], onDelete: Cascade)
  anchor    Json // { startPath, startOffset, endPath, endOffset }
  resolved  Boolean   @default(false)
  createdBy String
  createdAt DateTime  @default(now())
  comments  Comment[]

  @@index([articleId])
}

model Comment {
  id        String        @id @default(cuid())
  threadId  String
  thread    CommentThread @relation(fields: [threadId], references: [id], onDelete: Cascade)
  body      String
  createdBy String
  createdAt DateTime      @default(now())
  upvotes   Int           @default(0)
  downvotes Int           @default(0)

  @@index([threadId])
}

model Article {
  id           String        @id @default(uuid())
  authorId     String
  title        String
  slug         String        @unique
  heroImageKey String?
  template     String        @default("standard")
  astJson      Json
  status       ArticleStatus @default(DRAFT)
  revisions    Revision[]
  analytics    Json?
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  excerpt      String?
  readingTime  Int? // minutes
  publishedAt  DateTime? // set on publish

  allowAnnotations Boolean         @default(true)
  revisionId       String?
  threads          CommentThread[]
  deletedAt        DateTime?

  @@index([authorId, deletedAt, updatedAt])
  @@index([authorId, status, updatedAt])
  @@map("articles")
}

model Revision {
  id        String   @id @default(uuid())
  articleId String
  astJson   Json
  createdAt DateTime @default(now())

  article Article @relation(fields: [articleId], references: [id], onDelete: Cascade)

  @@map("article_revisions")
}

/// ---------- SHEAF (facets layered on existing Message) ----------
model SheafFacet {
  id        BigInt  @id @default(autoincrement())
  messageId BigInt
  message   Message @relation(fields: [messageId], references: [id])

  audienceKind      AudienceKind
  audienceMode      AudienceMode
  audienceRole      String?
  audienceListId    String?
  snapshotMemberIds String[]
  listVersionAtSend Int?
  audienceUserIds   String[]

  sharePolicy SharePolicy
  expiresAt   DateTime?
  createdAt   DateTime    @default(now()) @db.Timestamptz(6)
  updatedAt   DateTime    @updatedAt

  body Json

  priorityRank  Int     @default(0)
  visibilityKey String?

  // ✅ opposite side of the relation:
  attachments      SheafAttachment[]
  SheafMessageMeta SheafMessageMeta[]

  reactions      MessageReaction[]
  MessageMention MessageMention[]
  LinkPreview    LinkPreview[]

  @@index([messageId])
  @@index([audienceKind, audienceMode])
  @@index([audienceRole])
  @@index([audienceListId])
  @@index([priorityRank, createdAt])
  @@map("sheaf_facets")
}

model SheafMessageMeta {
  // 1:1 with Message; keeps default facet without touching your Message shape
  messageId      BigInt      @id
  message        Message     @relation(fields: [messageId], references: [id], onDelete: Cascade)
  defaultFacetId BigInt?
  defaultFacet   SheafFacet? @relation(fields: [defaultFacetId], references: [id])

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@map("sheaf_message_meta")
}

model SheafAudienceList {
  id        String   @id @default(cuid())
  ownerId   BigInt
  owner     User     @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  name      String
  memberIds String[] // Postgres text[]
  version   Int      @default(1)
  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([ownerId])
  @@map("sheaf_audience_lists")
}

model SheafBlob {
  id        String   @id @default(cuid())
  sha256    String   @unique
  mime      String
  size      Int
  path      String?
  createdAt DateTime @default(now()) @db.Timestamptz(6)

  attachments SheafAttachment[]

  @@map("sheaf_blobs")
}

model SheafAttachment {
  id        BigInt   @id @default(autoincrement())
  facetId   BigInt
  blobId    String
  name      String
  createdAt DateTime @default(now()) @db.Timestamptz(6)

  facet SheafFacet @relation(fields: [facetId], references: [id], onDelete: Cascade)
  blob  SheafBlob  @relation(fields: [blobId], references: [id])

  @@index([facetId])
  @@index([blobId])
  @@map("sheaf_attachments")
}

enum SharePolicy {
  ALLOW
  REDACT
  FORBID
}

enum AudienceKind {
  EVERYONE
  ROLE
  LIST
  USERS
}

enum AudienceMode {
  DYNAMIC
  SNAPSHOT
}

model UserRole {
  userId    BigInt
  role      String
  createdAt DateTime @default(now()) @db.Timestamptz(6)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, role])
  @@index([role])
  @@map("user_roles")
}

model MessageReaction {
  id        BigInt  @id @default(autoincrement())
  messageId BigInt
  message   Message @relation(fields: [messageId], references: [id], onDelete: Cascade)

  /// Optional: the facet the viewer reacted to (safe to store; we filter on read)
  facetId BigInt?
  facet   SheafFacet? @relation(fields: [facetId], references: [id], onDelete: Cascade)

  userId BigInt
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  emoji     String
  createdAt DateTime @default(now())

  @@unique([messageId, facetId, userId, emoji], map: "uniq_reaction_per_facet")
  @@index([messageId])
  @@index([userId])
}

// --- Mentions ---
model MessageMention {
  id        BigInt   @id @default(autoincrement())
  messageId BigInt
  facetId   BigInt? // mention occurred in this facet body (optional for plain)
  userId    BigInt
  createdAt DateTime @default(now()) @db.Timestamptz(6)

  message Message     @relation(fields: [messageId], references: [id], onDelete: Cascade)
  facet   SheafFacet? @relation(fields: [facetId], references: [id], onDelete: Cascade)
  user    User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([messageId])
  @@index([facetId])
  @@map("message_mentions")
}

// --- Link preview cache (server-fetched, SSRF-safe) ---
model LinkPreview {
  urlHash   String   @id
  url       String
  title     String?
  desc      String?
  image     String?
  fetchedAt DateTime @default(now()) @db.Timestamptz(6)
  status    String // "ok" | "blocked" | "noindex" | "error"
  facetId   BigInt?

  facet SheafFacet? @relation(fields: [facetId], references: [id], onDelete: SetNull)

  @@index([facetId])
  @@index([fetchedAt])
  @@map("link_previews")
}

model ConversationState {
  conversationId BigInt
  userId         BigInt
  lastReadAt     DateTime @default(now()) @db.Timestamptz(6)

  @@id([conversationId, userId])
  @@index([userId])
  @@map("conversation_state")
}

model ActivityPubKey {
  user_id     BigInt   @id
  public_pem  String   @db.Text
  private_pem String   @db.Text
  created_at  DateTime @default(now()) @db.Timestamptz(6)
  updated_at  DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@map("activitypub_keys")
}

// --- ActivityPub federation state ---
enum ApFollowState {
  PENDING
  ACCEPTED
  REJECTED
}

model ApRemoteActor {
  id                BigInt    @id @default(autoincrement())
  url               String    @unique // canonical actor IRI
  inbox             String?
  sharedInbox       String?
  preferredUsername String?
  domain            String?
  publicKeyPem      String?   @db.Text
  lastSeen          DateTime? @db.Timestamptz(6)
  blocked           Boolean   @default(false)

  followers ApFollower[]
  following ApFollowing[]

  @@map("ap_remote_actors")
}

model ApFollower {
  id              BigInt        @id @default(autoincrement())
  user_id         BigInt
  remote_actor_id BigInt
  state           ApFollowState @default(ACCEPTED)
  created_at      DateTime      @default(now()) @db.Timestamptz(6)
  accepted_at     DateTime?     @db.Timestamptz(6)

  user   User          @relation(fields: [user_id], references: [id], onDelete: Cascade)
  remote ApRemoteActor @relation(fields: [remote_actor_id], references: [id], onDelete: Cascade)

  @@unique([user_id, remote_actor_id])
  @@index([user_id])
  @@map("ap_followers")
}

model ApFollowing {
  id              BigInt        @id @default(autoincrement())
  user_id         BigInt
  remote_actor_id BigInt
  state           ApFollowState @default(PENDING)
  created_at      DateTime      @default(now()) @db.Timestamptz(6)
  accepted_at     DateTime?     @db.Timestamptz(6)

  user   User          @relation(fields: [user_id], references: [id], onDelete: Cascade)
  remote ApRemoteActor @relation(fields: [remote_actor_id], references: [id], onDelete: Cascade)

  @@unique([user_id, remote_actor_id])
  @@index([user_id])
  @@map("ap_following")
}

model ApOutboxActivity {
  id            BigInt   @id @default(autoincrement())
  actor_user_id BigInt
  activity_json Json
  created_at    DateTime @default(now()) @db.Timestamptz(6)

  user User @relation(fields: [actor_user_id], references: [id], onDelete: Cascade)

  @@index([actor_user_id, created_at])
  @@map("ap_outbox")
}

enum ApDomainRuleMode {
  ALLOW
  DENY
}

model ApDomainRule {
  id         BigInt           @id @default(autoincrement())
  domain     String           @unique
  mode       ApDomainRuleMode
  created_at DateTime         @default(now()) @db.Timestamptz(6)

  @@map("ap_domain_rules")
}

model Room {
  id               String   @id @default(cuid())
  kind             RoomKind
  conversation_id  BigInt?
  realtime_room_id String?

  isSharded   Boolean @default(false)
  shardUrl    String?
  mediaBucket String?
  kmsKeyArn   String?

  created_at DateTime @default(now()) @db.Timestamptz(6)
  updated_at DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@unique([conversation_id], map: "uniq_room_conversation")
  @@unique([realtime_room_id], map: "uniq_room_realtime")
  @@index([isSharded])
}

enum RoomKind {
  CONVERSATION
  REALTIME
}

model BlockManifest {
  id         String   @id // nanoid
  ownerId    BigInt   @map("owner_id")
  component  String
  props      Json
  originSlug String?  @map("origin_slug")
  originElId String?  @map("origin_el_id")
  forkOfId   String?  @map("fork_of_id")
  isPublic   Boolean  @default(true) @map("is_public")
  thumbnail  String?  @map("thumbnail") // 👈 NEW
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")

  @@index([ownerId, createdAt])
  @@map("block_manifests")
}

model PageComment {
  id        BigInt   @id @default(autoincrement())
  pageSlug  String
  elementId String
  authorId  BigInt
  text      String
  xPct      Float
  yPct      Float
  createdAt DateTime @default(now())
}

model PagePatch {
  id        BigInt   @id @default(autoincrement())
  pageSlug  String
  elementId String
  authorId  BigInt
  patch     Json // Partial<ElementRecord>
  status    String // "proposed" | "accepted" | "rejected"
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Site {
  id        BigInt   @id @default(autoincrement())
  ownerId   BigInt
  slug      String   @unique
  theme     Json?
  createdAt DateTime @default(now())
}

model SitePage {
  id        BigInt   @id @default(autoincrement())
  siteId    BigInt
  slug      String // "home", "work", …
  payload   Json // CanvasState-like
  order     Int // nav order
  createdAt DateTime @default(now())

  @@unique([siteId, slug])
  @@index([siteId, order])
}

// ----------------------------------------------------------
// GitChat: Merge receipts (append-only audit of version merges)
// ----------------------------------------------------------
model MergeReceipt {
  id                BigInt   @id @default(autoincrement())
  message_id        BigInt
  version_hash      String   @db.VarChar(128)
  merged_at         DateTime @default(now()) @db.Timestamptz(6)
  parents           Json?
  approvals         Json?
  blocks            Json?
  policy_id         String?  @db.VarChar(64)
  prev_receipt_hash String?  @db.VarChar(128)
  snapshot          Json?
  signature         String?  @db.VarChar(512)

  merged_by BigInt
  // ⬇️ name the relation so we can specify the opposite on User
  mergedBy  User   @relation("UserMergedReceipts", fields: [merged_by], references: [id], onDelete: Cascade)

  message Message @relation(fields: [message_id], references: [id], onDelete: Cascade)

  @@index([message_id, merged_at])
  @@index([version_hash])
  @@map("merge_receipts")
}

// ----------------------------------------------------------
// GitChat: Proposal signals (Approve/Block per proposal facet)
// ----------------------------------------------------------
enum ProposalSignalKind {
  APPROVE
  BLOCK
}

model ProposalSignal {
  id              BigInt             @id @default(autoincrement())
  conversation_id BigInt
  message_id      BigInt
  facet_id        String             @db.VarChar(64)
  user_id         BigInt
  kind            ProposalSignalKind
  created_at      DateTime           @default(now()) @db.Timestamptz(6)

  // ⬇️ name each relation
  message      Message      @relation("MessageProposalSignals", fields: [message_id], references: [id], onDelete: Cascade)
  user         User         @relation("UserProposalSignals", fields: [user_id], references: [id], onDelete: Cascade)
  conversation Conversation @relation("ConversationProposalSignals", fields: [conversation_id], references: [id], onDelete: Cascade)

  @@unique([facet_id, user_id])
  @@index([message_id])
  @@index([conversation_id])
  @@map("proposal_signals")
}

model AgreementLock {
  id         BigInt   @id @default(autoincrement())
  message_id BigInt   @unique
  locked_by  BigInt
  locked_at  DateTime @default(now()) @db.Timestamptz(6)

  @@map("agreement_locks")
}

model AgreementAck {
  message_id BigInt
  user_id    BigInt
  ack_at     DateTime @default(now()) @db.Timestamptz(6)

  @@id([message_id, user_id])
  @@map("agreement_acks")
}

model Argument {
  id             String  @id @default(cuid())
  deliberationId String
  authorId       String
  text           String  @db.Text
  sources        Json?
  confidence     Float?
  isImplicit     Boolean @default(false)

  // NEW P1b metadata
  quantifier Quantifier?
  modality   Modality?
  mediaType  MediaType   @default(text)
  mediaUrl   String?

  createdAt DateTime @default(now())

  deliberation      Deliberation        @relation(fields: [deliberationId], references: [id], onDelete: Cascade)
  outgoingEdges     ArgumentEdge[]      @relation("fromArg")
  incomingEdges     ArgumentEdge[]      @relation("toArg")
  approvals         ArgumentApproval[]
  // (keep any other relations you already had)
  ViewpointArgument ViewpointArgument[]
  IssueLink         IssueLink[]

  @@index([deliberationId])
}

model ArgumentEdge {
  id             String   @id @default(cuid())
  deliberationId String
  fromArgumentId String
  toArgumentId   String
  type           EdgeType
  createdById    String
  createdAt      DateTime @default(now())

  deliberation Deliberation @relation(fields: [deliberationId], references: [id], onDelete: Cascade)
  from         Argument     @relation("fromArg", fields: [fromArgumentId], references: [id], onDelete: Cascade)
  to           Argument     @relation("toArg", fields: [toArgumentId], references: [id], onDelete: Cascade)

  @@index([deliberationId])
  @@index([fromArgumentId])
  @@index([toArgumentId])
}

model ArgumentApproval {
  id             String   @id @default(cuid())
  deliberationId String
  argumentId     String
  userId         String
  createdAt      DateTime @default(now())

  deliberation Deliberation @relation(fields: [deliberationId], references: [id], onDelete: Cascade)
  argument     Argument     @relation(fields: [argumentId], references: [id], onDelete: Cascade)

  @@unique([argumentId, userId])
  @@index([deliberationId, userId])
}

model ViewpointSelection {
  id             String             @id @default(cuid())
  deliberationId String
  rule           RepresentationRule
  k              Int
  coverageAvg    Float
  coverageMin    Float
  jrSatisfied    Boolean            @default(false)
  explainJson    Json
  createdById    String
  createdAt      DateTime           @default(now())

  deliberation  Deliberation        @relation(fields: [deliberationId], references: [id], onDelete: Cascade)
  viewpointArgs ViewpointArgument[]

  @@index([deliberationId, createdAt])
}

model ViewpointArgument {
  selectionId String
  argumentId  String
  viewpoint   Int // 0..k-1 index

  selection ViewpointSelection @relation(fields: [selectionId], references: [id], onDelete: Cascade)
  argument  Argument           @relation(fields: [argumentId], references: [id], onDelete: Cascade)

  @@id([selectionId, argumentId])
  @@index([viewpoint])
}

// --------- Clusters (basic) ----------
enum ClusterType {
  topic
  affinity
}

model Cluster {
  id          String        @id @default(cuid())
  type        ClusterType
  label       String
  createdAt   DateTime      @default(now())
  // optional: roomId scoping later
  UserCluster UserCluster[]
}

// Map users to clusters (for outside-cluster checks)
model UserCluster {
  id        String   @id @default(cuid())
  userId    String
  clusterId String
  createdAt DateTime @default(now())

  cluster Cluster @relation(fields: [clusterId], references: [id], onDelete: Cascade)

  @@unique([userId, clusterId])
}

// --------- Bridge Builder ----------
enum BridgeRequestStatus {
  open
  assigned
  completed
  expired
}

model BridgeRequest {
  id              String              @id @default(cuid())
  deliberationId  String
  requestedById   String
  targetClusterId String
  status          BridgeRequestStatus @default(open)
  expiresAt       DateTime?
  createdAt       DateTime            @default(now())

  assignments BridgeAssignment[]
}

model BridgeAssignment {
  id            String    @id @default(cuid())
  requestId     String
  assigneeId    String
  assignedAt    DateTime  @default(now())
  acceptedAt    DateTime?
  completedAt   DateTime?
  summaryCardId String?
  rewardCare    Int       @default(0)

  request BridgeRequest @relation(fields: [requestId], references: [id], onDelete: Cascade)
}

model AmplificationEvent {
  id             String   @id @default(cuid())
  deliberationId String?  // 👈 make optional for now
  hostType       ContentTargetType?
  hostId         String?
  eventType      String?  // 👈 make optional for now
  reason         String?
  payload        Json?
  createdById    String?
  createdAt      DateTime @default(now())
}


// --------- Briefs ----------
enum BriefStatus {
  draft
  published
}

enum Visibility {
  public
  unlisted
  room_only
}

model Brief {
  id               String      @id @default(cuid())
  roomId           String
  title            String
  slug             String      @unique
  status           BriefStatus @default(draft)
  visibility       Visibility  @default(public)
  createdById      String
  currentVersionId String?     @unique // 👈 must be unique
  createdAt        DateTime    @default(now())

  // Relation 1: one-to-one
  currentVersion BriefVersion? @relation("BriefCurrentVersion", fields: [currentVersionId], references: [id])

  // Relation 2: one-to-many
  versions BriefVersion[] @relation("BriefVersions")
}

model BriefVersion {
  id                         String   @id @default(cuid())
  briefId                    String
  number                     Int
  compiledFromDeliberationId String?
  sectionsJson               Json
  citations                  Json
  createdById                String
  createdAt                  DateTime @default(now())

  // Relation 1 (opposite of Brief.currentVersion)
  briefAsCurrent Brief? @relation("BriefCurrentVersion")

  // Relation 2 (opposite of Brief.versions)
  brief Brief @relation("BriefVersions", fields: [briefId], references: [id], onDelete: Cascade)

  links BriefLink[] @relation("BriefVersionLinks")

  @@unique([briefId, number])
}

enum BriefSourceType {
  card
  argument
  post
}

model BriefLink {
  id             String          @id @default(cuid())
  briefVersionId String
  sourceType     BriefSourceType
  sourceId       String

  version BriefVersion @relation("BriefVersionLinks", fields: [briefVersionId], references: [id], onDelete: Cascade)
}

model Issue {
  id             String    @id @default(cuid())
  deliberationId String
  label          String // e.g., "Image – Appropriateness", "Data validity", etc.
  description    String?
  state          String    @default("open") // "open" | "closed"
  createdById    String
  closedById     String?
  createdAt      DateTime  @default(now())
  closedAt       DateTime?

  deliberation Deliberation @relation(fields: [deliberationId], references: [id], onDelete: Cascade)
  links        IssueLink[]

  @@index([deliberationId, state])
}

model IssueLink {
  issueId    String
  argumentId String
  role       String @default("related") // "related" | "evidence" | etc.

  issue    Issue    @relation(fields: [issueId], references: [id], onDelete: Cascade)
  argument Argument @relation(fields: [argumentId], references: [id], onDelete: Cascade)

  @@id([issueId, argumentId])
}

// ---------- Enums ----------
enum ModerationStatus {
  OK
  NEEDS_SOURCES
  WORKSHOP
  OFF_TOPIC_REDIRECT
  DUPLICATE_MERGE
  DISPUTED
  OUT_OF_BOUNDS
}

enum ContentTargetType {
  article
  post
  room_thread
  deliberation
  argument
  card
  claim
  brief
  brief_version
}

enum PanelistRole {
  member
  chair
  observer
}

enum PanelDecisionType {
  APPROVE
  WORKSHOP
  REDIRECT
}

enum LogEntryType {
  STATUS_CHANGE
  PANEL_OPEN
  PANEL_CLOSE
  PANEL_DECISION
  POLICY_CHANGE
  NOTE
}

/// --- P1: Deliberation Core ---
enum DeliberationHostType {
  article
  post
  room_thread
  library_stack
  site
  inbox_thread
}

enum RepresentationRule {
  utilitarian
  harmonic
  maxcov
}

enum EdgeType {
  support
  rebut
  undercut
}

enum Quantifier {
  SOME
  MANY
  MOST
  ALL
}

enum Modality {
  COULD
  LIKELY
  NECESSARY
}

enum MediaType {
  text
  image
  video
  audio
}

model Deliberation {
  id          String               @id @default(cuid())
  hostType    DeliberationHostType
  hostId      String
  roomId      String?
  rule        RepresentationRule   @default(utilitarian)
  k           Int                  @default(3)
  createdById String
  createdAt   DateTime             @default(now())
  updatedAt   DateTime             @updatedAt

  arguments  Argument[]
  edges      ArgumentEdge[]
  approvals  ArgumentApproval[]
  selections ViewpointSelection[]
  Issue      Issue[]

  @@index([hostType, hostId])
  @@index([roomId])
}

// ---------- Governance core ----------
model DecisionReceipt {
  id         String            @id @default(cuid())
  roomId     String
  actorId    String
  action     String // e.g., "STATUS_CHANGE", "PANEL_DECISION"
  reason     String?
  targetType ContentTargetType
  targetId   String
  panelId    String?
  policyId   String?
  createdAt  DateTime          @default(now())

  panel Panel? @relation(fields: [panelId], references: [id])
}

model RoomLogbook {
  id        String       @id @default(cuid())
  roomId    String
  entryType LogEntryType
  summary   String
  payload   Json?
  createdAt DateTime     @default(now())
}

// Latest status for any polymorphic content in a room.
// History is kept via DecisionReceipt + RoomLogbook (immutable).
model ContentStatus {
  id            String            @id @default(cuid())
  roomId        String?
  targetType    ContentTargetType
  targetId      String
  currentStatus ModerationStatus
  prevStatus    ModerationStatus?
  reason        String?
  decidedById   String?
  panelId       String?
  createdAt     DateTime          @default(now())

  @@unique([targetType, targetId]) // one "current" row per target
}

model Panel {
  id        String            @id @default(cuid())
  roomId    String
  openedAt  DateTime          @default(now())
  closedAt  DateTime?
  panelists Panelist[]
  receipts  DecisionReceipt[]
}

model Panelist {
  id       String       @id @default(cuid())
  panelId  String
  userId   String
  role     PanelistRole @default(member)
  joinedAt DateTime     @default(now())

  panel Panel @relation(fields: [panelId], references: [id])

  @@unique([panelId, userId])
}

model DeliberationCard {
  id                        String   @id @default(cuid())
  deliberationId            String
  authorId                  String
  claimText                 String
  reasonsText               String[] @db.Text
  evidenceLinks             String[] @db.Text // URIs
  anticipatedObjectionsText String[] @db.Text
  counterText               String?
  confidence                Float?
  status                    String   @default("draft") // 'draft' | 'published'
  hostEmbed                 String? // 'article' | 'post' | 'room_thread'
  hostId                    String?
  moid                      String // content hash (fill server-side)
  createdAt                 DateTime @default(now())
  updatedAt                 DateTime @updatedAt

  cardCitations CardCitation[]
}

model CardCitation {
  id           String  @id @default(cuid())
  cardId       String
  uri          String
  locatorStart String? // e.g., CSS/XPath/char off
  locatorEnd   String?
  excerptHash  String?
  snapshotKey  String?
  cslJson      Json?

  card DeliberationCard @relation(fields: [cardId], references: [id], onDelete: Cascade)
}

model MissingPremise {
  id             String    @id @default(cuid())
  deliberationId String
  targetType     String // 'argument' | 'card'
  targetId       String
  proposedById   String
  text           String
  status         String    @default("proposed") // 'proposed'|'accepted'|'declined'
  premiseType    String    @default("premise") // 'premise'|'warrant'
  createdAt      DateTime  @default(now())
  decidedAt      DateTime?
}

// Optional storage for Rhetoric Lens v0 (client-heuristic can be ephemeral)
model ArgumentAnnotation {
  id          String   @id @default(cuid())
  targetType  String // 'argument' | 'card'
  targetId    String
  type        String // 'metaphor'|'analogy'|'hedge'|'intensifier'|'implicature'
  offsetStart Int
  offsetEnd   Int
  text        String
  source      String // 'heuristic'|'human'|'ml'
  createdAt   DateTime @default(now())
}
