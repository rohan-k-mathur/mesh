import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";
import { User } from "@/lib/AuthContext";
import {
  RealtimeChannel,
  RealtimePostgresChangesPayload,
  RealtimePresenceState,
} from "@supabase/supabase-js";
import { UserStatus } from "./definitions";
import { LiveCursorHandles } from "@/components/cursors/LiveCursors";
import { RefObject } from "react";
import { MOUSE_EVENT } from "@/constants";
import {
  convertPostToNode,
  convertRealtimeEdgeToEdge,
} from "./reactflow/reactflowutils";
import { RealtimeEdge, RealtimePost } from "@prisma/client";
import { AppEdge, AppNode } from "./reactflow/types";
import { supabase } from "./supabaseclient";

// generated by shadcn
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

// created by chatgpt
export function isBase64Image(imageData: string) {
  const base64Regex = /^data:image\/(png|jpe?g|gif|webp);base64,/;
  return base64Regex.test(imageData);
}

// created by chatgpt
export function formatDateString(dateString: string) {
  const options: Intl.DateTimeFormatOptions = {
    year: "numeric",
    month: "short",
    day: "numeric",
  };

  const date = new Date(dateString);
  const formattedDate = date.toLocaleDateString(undefined, options);

  const time = date.toLocaleTimeString([], {
    hour: "numeric",
    minute: "2-digit",
  });

  return `${time} - ${formattedDate}`;
}

// created by chatgpt
export function formatThreadCount(count: number): string {
  if (count === 0) {
    return "No Threads";
  } else {
    const threadCount = count.toString().padStart(2, "0");
    const threadWord = count === 1 ? "Thread" : "Threads";
    return `${threadCount} ${threadWord}`;
  }
}

export function transformPresenceState(
  presenceState: RealtimePresenceState<UserStatus>
): UserStatus[] {
  // First, flatten the presenceState values (which are arrays of UserStatus)
  const flattenedArray = Object.values(presenceState).flat();

  // Then, dedupe based on userId
  return flattenedArray.reduce(
    (accumulator: UserStatus[], current: UserStatus) => {
      // Check if the object with the specific key value is already in the accumulator
      if (!accumulator.some((item) => item.username === current.username)) {
        accumulator.push(current);
      }
      return accumulator;
    },
    []
  );
}

export function mergeArrays(
  originalArray: UserStatus[],
  newArray: UserStatus[]
): UserStatus[] {
  const map = new Map<string, UserStatus>();

  // Add original array items to the map
  originalArray.forEach((user) => map.set(user.username, user));

  // Add new array items to the map only if the username is not already present
  newArray.forEach((user) => {
    if (!map.has(user.username)) {
      map.set(user.username, user);
    }
  });

  // Convert the map back to an array
  return Array.from(map.values());
}

export function subscribeToRoom(
  room: RealtimeChannel,
  liveCursorsRef: RefObject<LiveCursorHandles>,
  user: User
) {
  room
    .on("presence", { event: "sync" }, () => {
      const otherUsers = transformPresenceState(room.presenceState()).filter(
        (userStatus) => userStatus.username !== user.username
      );
      if (liveCursorsRef.current) {
        liveCursorsRef.current.triggerUserJoin(otherUsers);
      }
    })
    .on("broadcast", { event: MOUSE_EVENT }, (broadcastMessage) => {
      if (broadcastMessage.payload.username === user.username) {
        return;
      }
      if (liveCursorsRef.current) {
        liveCursorsRef.current.triggerUserUpdate(broadcastMessage.payload);
      }
    })
    .on("presence", { event: "join" }, ({ key, newPresences }) => {
      const newUserStatuses = newPresences as unknown as UserStatus[];
      if (liveCursorsRef.current) {
        liveCursorsRef.current.triggerUserJoin(
          newUserStatuses.filter(
            (userStatus) => userStatus.username !== user.username
          )
        );
      }
    })
    .subscribe((status) => {
      if (status !== "SUBSCRIBED") {
        return;
      }
      const userStatus = {
        username: user.username!.toString(),
        onlineAt: new Date().toISOString(),
        mousePosition: { x: 250, y: 250 },
      };
      room.track(userStatus);
    });
}

export function subscribeToDatabaseUpdates(
  room: RealtimeChannel,
  roomId: string,
  addNode: (node: AppNode) => void,
  updateNode: (post: RealtimePost) => void,
  removeNode: (idToRemove: string) => void,
  addEdge: (edge: AppEdge) => void,
  updateEdge: (edge: AppEdge) => void,
  removeEdge: (idToRemove: string) => void
) {
  room
    .on(
      "postgres_changes",
      {
        event: "UPDATE",
        schema: "public",
        table: "realtime_posts",
        filter: `realtime_room_id=eq.${roomId}`,
      },
      (payload: RealtimePostgresChangesPayload<RealtimePost>) => {
        if (Object.keys(payload.new).length !== 0) {
          const updatedObject = payload.new as RealtimePost;
          updateNode(updatedObject);
        }
      }
    )
    .on(
      "postgres_changes",
      {
        event: "INSERT",
        schema: "public",
        table: "realtime_posts",
        filter: `realtime_room_id=eq.${roomId}`,
      },
      (payload: RealtimePostgresChangesPayload<RealtimePost>) => {
        if (Object.keys(payload.new).length !== 0) {
          const newObject = payload.new as RealtimePost;
          addNode(
            convertPostToNode({
              ...newObject,
              x_coordinate: Number(newObject.x_coordinate),
              y_coordinate: Number(newObject.y_coordinate),
            })
          );
        }
      }
    )
    .on(
      "postgres_changes",
      {
        event: "DELETE",
        schema: "public",
        table: "realtime_posts",
        filter: `realtime_room_id=eq.${roomId}`,
      },
      (payload: RealtimePostgresChangesPayload<RealtimePost>) => {
        if (Object.keys(payload.old).length !== 0) {
          const oldObject = payload.old as RealtimePost;
          removeNode(oldObject.id.toString());
        }
      }
    );
  room
    .on(
      "postgres_changes",
      {
        event: "UPDATE",
        schema: "public",
        table: "realtime_edges",
        filter: `realtime_room_id=eq.${roomId}`,
      },
      (payload: RealtimePostgresChangesPayload<RealtimeEdge>) => {
        if (Object.keys(payload.new).length !== 0) {
          const updatedObject = payload.new as RealtimeEdge;
          updateEdge(convertRealtimeEdgeToEdge(updatedObject));
        }
      }
    )
    .on(
      "postgres_changes",
      {
        event: "INSERT",
        schema: "public",
        table: "realtime_edges",
        filter: `realtime_room_id=eq.${roomId}`,
      },
      (payload: RealtimePostgresChangesPayload<RealtimeEdge>) => {
        if (Object.keys(payload.new).length !== 0) {
          const newObject = payload.new as RealtimeEdge;
          addEdge(convertRealtimeEdgeToEdge(newObject));
        }
      }
    )
    .on(
      "postgres_changes",
      {
        event: "DELETE",
        schema: "public",
        table: "realtime_edges",
        filter: `realtime_room_id=eq.${roomId}`,
      },
      (payload: RealtimePostgresChangesPayload<RealtimeEdge>) => {
        if (Object.keys(payload.old).length !== 0) {
          const oldObject = payload.old as RealtimeEdge;
          removeEdge(oldObject.id.toString());
        }
      }
    )
    .subscribe();
}

export async function uploadFileToSupabase(file: File) {
  const { data, error } = await supabase.storage
    .from("realtime_post_images")
    .upload(`public/${file.name}`, file);
  if (!error) {
    return {
      fileURL: process.env.NEXT_PUBLIC_SUPABASE_BUCKET_URL + data.fullPath,
      error: null,
    };
  } else {
    console.error(error);
    alert("Failed to upload image");
    return { fileURL: "", error: error };
  }
}
