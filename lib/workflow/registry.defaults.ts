// lib/workflow/registry.defaults.ts
import { registerAction, registerTrigger } from "@/lib/workflow/registry";
import { sendEmail } from "@/lib/actions/gmail.actions";
import { appendRow, createSpreadsheet, readRange } from "@/lib/actions/googleSheets.actions";
import { requireScopes } from "@/lib/connections/service";

// -------- Triggers --------

// Manual click trigger (useful in builder / tests)
registerTrigger({
  id: "trigger.onClick",
  displayName: "Manual Trigger",
  inputs: [], // no fields
});

// Cron trigger (cron expression is stored; your scheduler reads it from DB)
registerTrigger({
  id: "trigger.cron",
  displayName: "Cron",
  inputs: [
    { key: "cron", label: "Cron expression", type: "string", required: true, placeholder: "0 */2 * * *" },
    { key: "timezone", label: "Timezone (IANA)", type: "string", placeholder: "America/Los_Angeles" },
  ],
});

// Webhook trigger (a secret is stored; your API route validates it)
registerTrigger({
  id: "trigger.webhook",
  displayName: "Webhook",
  inputs: [
    { key: "path", label: "Path (read-only)", type: "string", placeholder: "/api/triggers/webhook/:workflowId/:secret" },
    { key: "secret", label: "Shared Secret", type: "string", required: true, placeholder: "autogenerated-uuid" },
  ],
});

// -------- Actions --------

// Delay (useful control primitive)
registerAction({
  id: "control.delay",
  displayName: "Control · Delay",
  inputs: [{ key: "ms", label: "Milliseconds", type: "number", required: true, placeholder: "1000" }],
  run: async (ctx, inputs) => {
    const ms = Number(ctx.eval(inputs.ms));
    await new Promise(r => setTimeout(r, ms));
    return { waitedMs: ms };
  },
});

// Gmail send
registerAction({
  id: "gmail.sendEmail",
  displayName: "Gmail · Send Email",
  provider: "gmail",
  inputs: [
    { key: "to",      label: "To",      type: "email",  required: true,  placeholder: "{{payload.customer.email}}" },
    { key: "subject", label: "Subject", type: "string", required: true },
    { key: "message", label: "Message", type: "text",   required: true },
    { key: "from",    label: "From (optional)", type: "email", placeholder: "(defaults to connected account)" },
  ],
  requiredScopes: ["gmail.send"],
  run: async (ctx, inputs) => {
    const conn = ctx.creds;
    requireScopes(conn, ["gmail.send"]);
    const to = ctx.eval(inputs.to);
    const subject = ctx.eval(inputs.subject);
    const message = ctx.eval(inputs.message);
    const from = ctx.eval(inputs.from) || conn?.metadata?.email || conn?.accountLabel;

    if (!conn?.accessToken) throw new Error("Gmail connection missing accessToken");
    if (!from) throw new Error("No 'from' address available (supply in inputs or store in connection metadata)");

    await sendEmail({ from, to, subject, message, accessToken: conn.accessToken });
    return { delivered: true, to, subject };
  },
});

// Google Sheets · Create Spreadsheet
registerAction({
  id: "sheets.createSpreadsheet",
  displayName: "Google Sheets · Create Spreadsheet",
  provider: "googleSheets",
  inputs: [{ key: "title", label: "Title", type: "string", required: true }],
  run: async (ctx, inputs) => {
    const conn = ctx.creds;
    if (!conn?.accessToken) throw new Error("Google Sheets connection missing accessToken");
    const title = ctx.eval(inputs.title);
    const id = await createSpreadsheet({ title, accessToken: conn.accessToken });
    return { spreadsheetId: id };
  },
});

// Google Sheets · Append Row
registerAction({
  id: "sheets.appendRow",
  displayName: "Google Sheets · Append Row",
  provider: "googleSheets",
  inputs: [
    { key: "spreadsheetId", label: "Spreadsheet ID", type: "string", required: true },
    { key: "range", label: "Range (e.g. Sheet1!A1:C1)", type: "string", required: true },
    { key: "values", label: "Comma separated values", type: "string", required: true, placeholder: "{{payload.id}},{{payload.email}},{{payload.total}}" },
  ],
  run: async (ctx, inputs) => {
    const conn = ctx.creds;
    if (!conn?.accessToken) throw new Error("Google Sheets connection missing accessToken");
    const spreadsheetId = ctx.eval(inputs.spreadsheetId);
    const range = ctx.eval(inputs.range);
    const values = String(ctx.eval(inputs.values)).split(",").map(s => s.trim());
    await appendRow({ spreadsheetId, range, values, accessToken: conn.accessToken });
    return { appended: values.length, spreadsheetId, range };
  },
});

// Google Sheets · Read Range
registerAction({
  id: "sheets.readRange",
  displayName: "Google Sheets · Read Range",
  provider: "googleSheets",
  inputs: [
    { key: "spreadsheetId", label: "Spreadsheet ID", type: "string", required: true },
    { key: "range", label: "Range (e.g. Sheet1!A1:C10)", type: "string", required: true },
  ],
  run: async (ctx, inputs) => {
    const conn = ctx.creds;
    if (!conn?.accessToken) throw new Error("Google Sheets connection missing accessToken");
    const spreadsheetId = ctx.eval(inputs.spreadsheetId);
    const range = ctx.eval(inputs.range);
    const data = await readRange({ spreadsheetId, range, accessToken: conn.accessToken });
    return { data };
  },
});
