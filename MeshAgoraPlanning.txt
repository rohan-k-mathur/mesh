Amazing‚Äîthanks for the code drop. I read through the three bundles and mapped them to the research roadmap so we can wire features precisely where they belong.
Below is a refined, file‚Äëaware roadmap with surgical code changes (diffs/snippets) for the current Mesh/Agora codebase. I cite your files inline so you can see exactly what I‚Äôm building on.

0) What‚Äôs already in place (from your code)
	‚Ä¢	Move API: POST /api/dialogue/move already accepts kind: 'ASSERT'|'WHY'|'GROUNDS'|'RETRACT'|'CONCEDE'|'CLOSE', synthesizes acts (including daimon for CLOSE), dedups via a signature, compiles designs, and optionally steps the interaction; it emits bus events (dialogue:changed, dialogue:moves:refresh). It also normalizes CONCEDE to ASSERT with payload.as='CONCEDE'. The payload leverages locusPath, and there‚Äôs a TTL for WHY. 
	‚Ä¢	Legal‚Äëmoves API (basic): GET /api/dialogue/legal-moves currently:
	‚ó¶	lists GROUNDS for open CQs (by key),
	‚ó¶	allows WHY when there is no open WHY for that key,
	‚ó¶	always offers CONCEDE and RETRACT,
	‚ó¶	optionally offers CLOSE (‚Ä†) when stepper hints the locus is closable (via daimonHints).‚Ä®This is a great skeleton to formalize R‚Äërules, relevance hints, and ‚Äúforce‚Äù classification. 
	‚Ä¢	Open CQ helper: /api/dialogue/open-cqs returns the set of open CQ keys for a target (WHY not yet answered by later GROUNDS). 
	‚Ä¢	Dialogue ‚Äúforum‚Äù: /api/dialogue/forum threads ASSERT/WHY/GROUNDS by nearest prior ASSERT with same locusId. (Good quick view; we‚Äôll tighten this once we record explicit reply targets.) 
	‚Ä¢	Lib building blocks:
	‚ó¶	lib/dialogue/moves.ts centralizes signatures and act synthesis; CLOSE produces daimon. Use this to keep POST signature logic consistent across endpoints. 
	‚ó¶	lib/dialogue/legalMoves.ts and lib/dialogue/legalAttacks.ts already detect shapes (conditional, ‚àÄ/‚àÉ, disjunction, conjunction, presupposition cue) and propose attack templates‚Äîperfect to enrich /legal-moves with R‚Äëshaped options and presupposition challenges. 
	‚ó¶	BAF/AF infra and selection (VAF‚Äëadjacent) are present via lib/deepdive/*. Prisma has Argument/ArgumentEdge (+ EdgeType support|rebut|undercut|concede) and helpers to derive ClaimEdge rows. We‚Äôll reuse these for support edges and AF reductions. 

1) Phase 1 ‚Äî Protocol hardening (R1‚ÄìR7), force chips, and status
Goal: Make the existing endpoints enforce the liberal protocol (explicit replies; attack vs surrender; no self‚Äëreply; no duplicates; no attack after surrender; R7 acceptance guard), expose turn and branch status, and annotate legal moves with force and relevance hints.
1.1 Add explicit reply targeting (non‚Äëbreaking)
	‚Ä¢	Body (optional, additive) for POST /api/dialogue/move:
	‚ó¶	replyToMoveId?: string
	‚ó¶	replyTarget?: 'claim'|'argument'|'premise'|'link'|'presupposition'‚Ä®If absent, we keep current targetType/targetId + payload.locusPath behavior. (UI can start sending replyToMoveId when available.)
Why now? It lets us enforce per‚Äëmove invariants (R4 ‚Äúno duplicate reply to this exact target‚Äù and R5 ‚Äúno attack after surrender on this node‚Äù) without disturbing your current ‚ÄútargetType/targetId‚Äù shape.
Minimal zod tweak (excerpt):
// app/api/dialogue/move/route.ts
const Body = z.object({
  deliberationId: z.string().min(1),
  targetType: z.enum(['argument','claim','card']),
  targetId: z.string().min(1),
  kind: z.enum(['ASSERT','WHY','GROUNDS','RETRACT','CONCEDE','CLOSE']),
  payload: z.any().optional(),
  autoCompile: z.boolean().optional().default(true),
  autoStep: z.boolean().optional().default(true),
  phase: z.enum(['focus-P','focus-O','neutral']).optional().default('neutral'),
  // üëá new, optional
  replyToMoveId: z.string().optional(),
  replyTarget: z.enum(['claim','argument','premise','link','presupposition']).optional(),
});

1.2 Enforce R‚Äërules at the API boundary
Create a small validator that runs before insert and returns reason codes. The checks rely on:
	‚Ä¢	replyToMoveId when present (precise),
	‚Ä¢	else fallback to targetType/targetId + current branch state and open CQ map (which you already compute in /legal-moves and /open-cqs). 
Reason codes (suggested):
	‚Ä¢	R1_TURN_VIOLATION
	‚Ä¢	R2_INVALID_SHAPE (e.g., GROUNDS without open WHY for key)
	‚Ä¢	R3_SELF_REPLY
	‚Ä¢	R4_DUPLICATE_REPLY
	‚Ä¢	R5_AFTER_SURRENDER
	‚Ä¢	R6_INITIAL_MOVE_VIOLATION
	‚Ä¢	R7_ACCEPT_ARGUMENT_REQUIRED
Validator stub (drop‚Äëin):
// lib/dialogue/validate.ts
export type ReasonCode = 'R1_TURN_VIOLATION'|'R2_INVALID_SHAPE'|'R3_SELF_REPLY'|
  'R4_DUPLICATE_REPLY'|'R5_AFTER_SURRENDER'|'R6_INITIAL_MOVE_VIOLATION'|'R7_ACCEPT_ARGUMENT_REQUIRED';

export async function validateMove(input: {
  deliberationId: string;
  actorId: string;
  kind: 'ASSERT'|'WHY'|'GROUNDS'|'RETRACT'|'CONCEDE'|'CLOSE';
  targetType: 'argument'|'claim'|'card';
  targetId: string;
  replyToMoveId?: string | null;
  replyTarget?: string | null;
  payload: any;
}) : Promise<{ ok: true } | { ok: false; reasons: ReasonCode[] }> {
  const reasons: ReasonCode[] = [];

  // R3 self-reply (when precise replyTo available)
  if (input.replyToMoveId) {
    const m = await prisma.dialogueMove.findUnique({ where: { id: input.replyToMoveId }, select: { actorId: true, kind: true, payload: true }});
    if (m && m.actorId === input.actorId) reasons.push('R3_SELF_REPLY');

    // R7: trying to CONCEDE œÜ after ARGUE that answered a WHY œÜ ‚Üí must ACCEPT_ARGUMENT instead
    if ((input.kind === 'CONCEDE' || input.payload?.as === 'CONCEDE') && m?.kind === 'GROUNDS') {
      // (You can refine by checking that m is the answer to a WHY for same cq/key/claim)
      reasons.push('R7_ACCEPT_ARGUMENT_REQUIRED');
    }
  }

  // R4 duplicate reply (signature already helps for WHY/GROUNDS; enforce for others)
  // Quick check: is there an existing move with same signature or same (replyToMoveId, kind, replyTarget)?
  // ... add your query here ...

  // R5: no attack after surrender ‚Äî if target is surrendered/closed, block WHY/GROUNDS/ASSERT (attacks)
  // ... read branch state cache or scan for recent CONCEDE/CLOSE on same node/locus ...

  // R1, R2, R6 can be layered here or in Phase 1.3 (legal-moves)
  return reasons.length ? { ok:false, reasons } : { ok:true };
}
Then in POST /api/dialogue/move:
const legal = await validateMove({ deliberationId, actorId, kind, targetType, targetId, replyToMoveId, replyTarget, payload });
if (!('ok' in legal) || !legal.ok) {
  return NextResponse.json({ ok:false, reasonCodes: legal.reasons }, { status: 409 });
}

‚úÖ This places R7 exactly where your code already maps CONCEDE to ASSERT‚Ä¶as='CONCEDE', so we can convert the attempted concession into an ACCEPT_ARGUMENT flow in the UI (see 1.4).
1.3 Upgrade /api/dialogue/legal-moves: force + relevance + shapes
We‚Äôll enrich the existing endpoint instead of introducing a new one.
	‚Ä¢	Add force: 'ATTACK'|'SURRENDER'|'NEUTRAL'.
	‚Ä¢	Add relevance: 'likely'|'unlikely'|null (soft relevance).
	‚Ä¢	For targetType='claim'|'argument', look up the text and feed it into lib/dialogue/legalMoves or legalAttacks to provide shape‚Äëspecific prompts (including presupposition challenge). 
Diff sketch:
// app/api/dialogue/legal-moves/route.ts
type Move = {
  kind: 'ASSERT'|'WHY'|'GROUNDS'|'RETRACT'|'CONCEDE'|'CLOSE';
  label: string;
  payload?: any;
  disabled?: boolean;
  reason?: string;
  // üëá new
  force?: 'ATTACK'|'SURRENDER'|'NEUTRAL';
  relevance?: 'likely'|'unlikely'|null;
};

...
// Fetch target text to detect shapes
let targetText: string | null = null;
if (targetType === 'claim') {
  const row = await prisma.claim.findUnique({ where: { id: targetId }, select: { text: true }});
  targetText = row?.text ?? null;
} else if (targetType === 'argument') {
  const row = await prisma.argument.findUnique({ where: { id: targetId }, select: { text: true }});
  targetText = row?.text ?? null;
}
// Derive shape-based suggestions (optional: merge into WHY label choices)
if (targetText) {
  const { on, options } = legalAttacksFor(targetText); // from lib/dialogue/legalMoves.ts
  // e.g., if on === 'presupposition', push a WHY with a "Challenge presupposition" label
}

...
// force tagging
for (const m of moves) {
  if (m.kind === 'WHY' || m.kind === 'GROUNDS') m.force = 'ATTACK';
  else if (m.kind === 'CONCEDE' || m.kind === 'RETRACT' || m.kind === 'CLOSE') m.force = 'SURRENDER';
  else m.force = 'NEUTRAL';
}

// soft relevance (cheap): if a branch is already "closed", any ATTACK is unlikely relevant
for (const m of moves) {
  m.relevance = m.force === 'ATTACK' ? (/* open? */ 'likely' : 'unlikely') : null;
}
You already compute CLOSE (‚Ä†) legality from stepInteraction‚Äîwe‚Äôll keep that as is and simply tag force.
1.4 R7 UX: offer Accept Argument instead of Concede œï
In the composer UI (where you render the /legal-moves list), when a CONCEDE is disabled due to R7_ACCEPT_ARGUMENT_REQUIRED, present an ACCEPT_ARGUMENT action that posts:
// POST /api/dialogue/move
// keep existing shape, but mark as acceptance
{ kind: 'ASSERT', payload: { as:'ACCEPT_ARGUMENT', locusPath, expression: 'accept: <arg-id or brief>' } }
This reuses your ASSERT path and signatures while distinguishing in payload.as. Later, we can add a first‚Äëclass kind: 'ACCEPT_ARGUMENT' enum once DB/everything is ready.
1.5 Dialogue status endpoint for clients
Add:‚Ä®GET /api/dialogues/[id]/status ‚Üí { turnHolders: string[]; branches: Array<{ locusPath: string; open: boolean }>; terminatedFor?: string[] }
	‚Ä¢	Turn model: after move 2, include both participants (you already pass phase and use stepper; we‚Äôll keep turn logic simple and auditable in this endpoint).
	‚Ä¢	A simple branch cache can be derived by scanning latest surrender vs attack events per locus (or by asking the stepper for daimonHints and open loci). 

2) Phase 2 ‚Äî Commitments (use what you have) + viewer
You already apply to the Commitment Store in POST /api/dialogue/answer-and-commit, calling applyToCS and emitting events (dialogue CS refresh). Let‚Äôs reuse that path rather than invent a new table right now.
	‚Ä¢	Add: GET /api/dialogue/commitments?deliberationId=‚Ä¶&owner=Proponent|Opponent to return the current CS snapshot (adapter around applyToCS‚Äôs storage schema).
	‚Ä¢	UI: commitments popover on participant chips (lists entries; show ‚Äúvia argument ‚Ä¶‚Äù when we have a justification ref).
Later, if we do persist CS to Prisma, we can keep the adapter API stable.

3) Phase 3 ‚Äî Relevance (soft now, strict later)
	‚Ä¢	Soft relevance is already wired in 1.3.
	‚Ä¢	Strict relevance auditor: a small worker that simulates whether a candidate move could change the dialogical status; annotate moves with strictRelevant: boolean asynchronously and emit dialogue:status:refresh.
Nothing in your current endpoints conflicts with this; we only add the annotation channel.

4) Phase 4 ‚Äî Values (VAF) + Support (BAF)
We can stand this up quickly with models and libs you already have:
	‚Ä¢	Arguments & edges: Prisma models (Argument, ArgumentEdge, EdgeType support|rebut|undercut|concede) and claim‚Äëedge helpers are present. We‚Äôll use these to power support relations in the UI and propagate them into the AF projection when desired. 
	‚Ä¢	AF engine (lib/argumentation/afEngine.ts) and selection (lib/deepdive/selection.ts) are ready to compute preferred extensions / viewers for RightRail. We‚Äôll add a minimal Audience store + ordering and compute objective/subjective acceptance tags. 

5) Phase 5 ‚Äî Presuppositions & divergence (Ludics polish)
	‚Ä¢	You already detect presupposition cues in lib/dialogue/legalMoves.ts. We will:
	‚ó¶	surface a ‚ÄúChallenge presupposition‚Äù legal option in /legal-moves,
	‚ó¶	add a replyTarget: 'presupposition' when the user picks it, so analytics and guards can reason about it. 
	‚Ä¢	Divergence: when a reply maps to no valid locus (no dual), return a gentle ‚Äúrepair‚Äù reason from the validator and show a rephrase prompt. (The stepper/daimon hints you‚Äôre already using will help here.) 

6) Phase 6 ‚Äî Asymmetric burden of proof (room pref)
	‚Ä¢	Add prefs.asymmetricProof on the deliberation/room and switch aggregation rules in the status computation. (No API changes to /move; only status/outcome labels change.)

7) Phase 7 ‚Äî Exports (AIF, DSS/DML)
	‚Ä¢	With Argument/Claim/Edges and DialogueMove in place, the exporter can be added as two GET endpoints that traverse your existing graph and pack I/S nodes (AIF) and DSS/DML instances.

8) ‚ÄúGlue‚Äù changes (diff‚Äëstyle) you can drop in now
8.1 Strengthen signature & unique index
You‚Äôre already relying on a composite unique (deliberationId, signature) (see dm_unique_signature usage). Double‚Äëcheck Prisma has that unique declared on DialogueMove. If not, add:
// schema.prisma
model DialogueMove {
  id              String   @id @default(cuid())
  deliberationId  String
  targetType      String
  targetId        String
  kind            String
  payload         Json?
  actorId         String
  signature       String   // sha or compact signature

  createdAt       DateTime @default(now())

  @@unique([deliberationId, signature], name: "dm_unique_signature")
}
This matches the P2002 handling in POST /api/dialogue/move.
8.2 Extend /legal-moves with force/relevance and shape prompts
 // app/api/dialogue/legal-moves/route.ts
+ import { legalAttacksFor } from '@/lib/dialogue/legalMoves';

 type Move = {
   kind: 'ASSERT'|'WHY'|'GROUNDS'|'RETRACT'|'CONCEDE'|'CLOSE';
   label: string;
   payload?: any;
   disabled?: boolean;
   reason?: string;
+  force?: 'ATTACK'|'SURRENDER'|'NEUTRAL';
+  relevance?: 'likely'|'unlikely'|null;
 };

 export async function GET(req: NextRequest) {
   ...
+  // fetch target text
+  let targetText: string | null = null;
+  if (targetType === 'claim') {
+    const row = await prisma.claim.findUnique({ where: { id: targetId }, select: { text: true }});
+    targetText = row?.text ?? null;
+  } else if (targetType === 'argument') {
+    const row = await prisma.argument.findUnique({ where: { id: targetId }, select: { text: true }});
+    targetText = row?.text ?? null;
+  }

   const moves: Move[] = [];
   ...
   // existing WHY/GROUNDS/CONCEDE/RETRACT/CLOSE logic

+  // mark force
+  for (const m of moves) {
+    m.force = (m.kind === 'WHY' || m.kind === 'GROUNDS') ? 'ATTACK'
+            : (m.kind === 'CONCEDE' || m.kind === 'RETRACT' || m.kind === 'CLOSE') ? 'SURRENDER'
+            : 'NEUTRAL';
+  }
+  // soft relevance
+  const branchOpen = true; // TODO: compute from branch cache or last surrender
+  for (const m of moves) m.relevance = m.force === 'ATTACK' ? (branchOpen ? 'likely' : 'unlikely') : null;

+  // shape-based prompts (presuppositions etc.)
+  if (targetText) {
+    const { on, options } = legalAttacksFor(targetText);
+    if (on === 'presupposition') {
+      moves.unshift({ kind:'WHY', label:'Challenge presupposition', payload:{ cqId:'presup' }, force:'ATTACK', relevance:'likely' });
+    }
+    // (optionally add finer-grained WHY labels based on options[])
+  }
   return NextResponse.json({ ok:true, moves }, { headers: { 'Cache-Control': 'no-store' } });
 }
8.3 Add validator call to /move (R‚Äërules)
 // app/api/dialogue/move/route.ts
+ import { validateMove } from '@/lib/dialogue/validate';

 // actor
 const userId = await getCurrentUserId().catch(() => null);
 const actorId = String(userId ?? 'unknown');

+ // R-rules guard
+ const legal = await validateMove({
+   deliberationId, actorId, kind, targetType, targetId,
+   replyToMoveId: (parsed.data as any).replyToMoveId,
+   replyTarget: (parsed.data as any).replyTarget ?? null,
+   payload
+ });
+ if (!('ok' in legal) || !legal.ok) {
+   return NextResponse.json({ ok:false, reasonCodes: legal.reasons }, { status: 409 });
+ }


9) Forum threading (quick win)
Your /api/dialogue/forum currently attaches WHY/GROUNDS to the nearest prior ASSERT with the same locusId. Once replyToMoveId lands, switch to that (with fallback to locusId). This aligns the visible tree with the explicit reply structure our legality engine uses.

10) Acceptance checklist (for this pass)
	‚Ä¢	R7 guard: Attempting CONCEDE œÜ immediately after an ARGUE answering WHY œÜ returns 409 with reasonCodes:['R7_ACCEPT_ARGUMENT_REQUIRED']; UI offers Accept Argument alternative. 
	‚Ä¢	No self‚Äëreply / no duplicate reply / no attack after surrender: guarded via validateMove() with precise reasons; dedup remains via signature.
	‚Ä¢	Legal‚Äëmoves shows force and soft relevance; includes presupposition challenge when detected from target text.
	‚Ä¢	Status endpoint returns turn holders (after move 2, both) and branch open/close. (‚Ä† remains surfaced from stepper hints.) 
	‚Ä¢	Commitments: a read endpoint reflects updates made by answer-and-commit. 

11) What I‚Äôll use next from your code (to keep momentum)
	‚Ä¢	Prisma models for Arguments/Edges/Claims to stand up support edges and the AF projection for RightRail acceptance chips. 
	‚Ä¢	lib/argumentation/afEngine.ts + lib/deepdive/selection.ts to compute viewer sets and integrate the Audience lens for VAF. 

Want me to produce the concrete validateMove() with queries tailored to your tables (including R5 ‚Äúsurrendered/closed‚Äù detection by scanning recent CONCEDE|CLOSE on the same target/locus) and the /dialogues/[id]/status route stub? I can draft those against these files so you can drop them in with minimal edits.

Fantastic‚Äîthanks for sharing MeshResearchNotes.txt. I read it closely and folded its Ludics‚Äëcentric insights, protocol nuances, and interop goals into a concrete, implementation‚Äëready roadmap that plugs directly into your current codebase (routes, libs, Prisma). I‚Äôve annotated key items with inline citations back to the compendium and to the relevant code surfaces you already have.

Digital Agora ‚Äî Roadmap v3 (incorporating MeshResearchNotes)
Phase 0 ‚Äî Commit to public semantics, name the invariants (short spike)
Why: The notes emphasize the design choice between public and private semantics; Agora should be explicitly public so moderation and auditability remain tractable. „ÄêPublic vs private semantics, implication for Mesh. „Äë
Work
	‚Ä¢	Add a Room Policy flag dialogueSemantics = 'public' (default) and document it in the room‚Äôs settings/help.
	‚Ä¢	Server: log this in /api/dialogue/* responses (meta.semantics: 'public').
	‚Ä¢	UI: small banner in the Dialogical panel that reads ‚ÄúPublic semantics: legality computed from the public record.‚Äù
Acceptance
	‚Ä¢	Policy shows in the room config; responses include meta.semantics.
	‚Ä¢	Moderator guide references public semantics explicitly. „ÄêDesign implication spelled out. „Äë

Phase 1 ‚Äî Protocol core: reply structure, acts, daimon close, soft legality
Why: The compendium pushes us to represent interventions as sequences of acts at loci, and to make reply‚Äëto + attack/surrender first‚Äëclass. It also specifies terminal CLOSE/CONCEDE ‚áí convergence (‚Ä† daimon). „ÄêLudics acts/loci/trace & convergence with ‚Ä†; acceptance examples. „Äë
What we already have to leverage
	‚Ä¢	POST /api/dialogue/move accepts/derives payload.acts, maps CLOSE to a daimon act, and dedups by signature; it also recompiles and steps the Ludics designs. „ÄêRoute behavior, synthesizeActs, CLOSE mapping, compileFromMoves/stepInteraction wired. „Äë
	‚Ä¢	GET /api/dialogue/legal-moves suggests WHY/GROUNDS/CONCEDE/RETRACT, and conditionally CLOSE by probing daimon hints from a step trace. „ÄêLegal moves w/ daimon‚Äëenabled CLOSE. „Äë
	‚Ä¢	lib/dialogue/moves.ts provides the shared synthesizeActs/makeSignature helpers we can extend. 
Work
	1	Reply targeting & loci
	‚Ä¢	Extend DialogueMove persistence to always carry payload.acts[] with locusPath + openings (already modeled in the notes) and a justifiedBy (reply‚Äëto locusPath). „ÄêMulti‚Äëact payload shape and locus ramifications. „Äë
	‚Ä¢	Enforce: every non‚Äëinitial move replies to a specific locus (explicit reply structure). „ÄêImportance of explicit reply structure for legality/backtracking/parallel lines. „Äë
	2	Attack vs surrender typing
	‚Ä¢	In POST /api/dialogue/move, classify moves as attack (WHY, GROUNDS) vs surrender (CONCEDE, RETRACT) to drive open/closed branch UI and legality. „ÄêAttack vs surrender as formal properties. „Äë
	3	Terminal close (‚Ä†)
	‚Ä¢	Keep current CLOSE ‚áí daimon behavior, and surface it clearly in the trace UI as Convergent. „ÄêCLOSE/CONCEDE ‚áí Convergent trace (‚Ä†) acceptance criteria. „Äë
	4	Soft legal moves
	‚Ä¢	Keep GET /api/dialogue/legal-moves fast; annotate ‚Äúlikely relevant‚Äù (soft) based on open branches/loci; wire strict checking later (Phase 4).
Acceptance
	‚Ä¢	A WHY followed by a GROUNDS compiles to paired -/+ acts on the same locus (e.g., 0.1) and shows as such in the trace. „ÄêConcrete acceptance example. „Äë
	‚Ä¢	A CLOSE or CONCEDE leads the stepper to report a convergent trace with ‚Ä†. „ÄêTrace status/daimon. „Äë
	‚Ä¢	Legal‚Äëmoves API includes CLOSE only when the stepper hints that locus is closable. 

Phase 2 ‚Äî UI surfaces for Ludics: Trace Ribbon, Locus Heatmap, Additive choice
Why: The notes call for rendering the abstruse Ludics machinery as intuitive UI: narrated trace, heatmaps of loci, and enforced additive choices (‚äï). „ÄêTrace ribbon, locus heatmap, additive picker. „Äë
Work
	‚Ä¢	NegotiationDrawer.tsx: add a Trace Ribbon showing ‚ÄúP challenges at 0.1‚Äù / ‚ÄúO defends at 0.1‚Äù, highlighting decisive indices. „ÄêUI/acceptance and decisive indices. „Äë
	‚Ä¢	LociTreeWithControls.tsx: render heatmap intensity by act frequency; highlight hot spots. 
	‚Ä¢	Additive Choice Picker: when a positive act opens multiple openings with isAdditive=true, prompt the opponent to pick a branch; persist the chosen branch (usedAdditive). 
	‚Ä¢	Delocation/Faxing: expose a moderator action to delocate a congested branch to a fresh base locus‚Äîtie to an API (see Phase 3). „ÄêDelocation design + acceptance. „Äë
Acceptance
	‚Ä¢	The Trace Ribbon narrates moves as in the examples; the Additive picker blocks progress until a branch is chosen; a mod can delocate a branch. „ÄêAll three acceptance bullets. „Äë

Phase 3 ‚Äî Operational tools: Delocation route + Receipts
Why: The compendium proposes delocation as a formal remedy for ‚Äúdirectory clashes‚Äù and suggests recording these as procedural receipts. „ÄêDelocation (faxing) and affected surfaces. „Äë
Work
	‚Ä¢	Add /api/ludics/delocate that clones a design and shifts a branch to a fresh base address. „ÄêProposed route. „Äë‚Ä®Note: you already have a panel delocation action wired as /api/dialogue/panel/delocate; we can either alias or migrate to the Ludics namespace so both the panel and NegotiationDrawer call the same service. 
	‚Ä¢	Create a DecisionReceipt entry when delocation occurs (subject=locus), so the audit trail is append‚Äëonly. 
Acceptance
	‚Ä¢	Calling the delocate API produces a new base (e.g., 0.tag), emits SSE to refresh, and writes a procedural receipt. 

Phase 4 ‚Äî Relevance & termination semantics (gradual)
Why: Strict relevance (legality only if the move can flip the dialogical status) is powerful but expensive; adopt a soft‚Äënow / strict‚Äëlater posture. „ÄêStrict relevance is costly; use as a later layer. „Äë
Work
	‚Ä¢	Soft relevance (real‚Äëtime): label moves ‚Äúlikely relevant‚Äù if they target an open locus that still influences the root status; show a subtle warning when not.
	‚Ä¢	Strict relevance (batch): offline job recomputes dialogical status and annotates moves/branches; room policy can enforce strict mode for high‚Äëstakes rooms.
Acceptance
	‚Ä¢	Soft chip appears immediately; strict annotations land asynchronously and can be toggled in filters. „ÄêRelevance discussion and cost. „Äë

Phase 5 ‚Äî Evidence ‚Üí Rule heuristics (CBR‚Äëinspired)
Why: When users attach evidence, they are often implicitly proposing a defeasible rule (e.g., ‚Äúwhen {A, B}, usually C‚Äù). Surface this as a guided suggestion. „ÄêCBR heuristics; evidence implies rules; suggest generalization. „Äë
Work
	‚Ä¢	In CitePicker / composer, after adding a citation, prompt: ‚ÄúExtract a general rule?‚Äù with a structured form to mint a reusable pattern; store alongside the argument as a warrant/background rule.
	‚Ä¢	Allow distinguish/‚Äúdoesn‚Äôt apply because‚Ä¶‚Äù counters that target the rule‚Äôs factors, not just the conclusion. „ÄêDialectical multi‚Äëargument structure of precedents; fine‚Äëgrained cite‚Äëportions. „Äë
Acceptance
	‚Ä¢	Posting a citation can create a rule; later counters can distinguish by contesting the rule‚Äôs factors.

Phase 6 ‚Äî Interop: AIF export (and later import)
Why: Avoid a walled garden; AIF is the standard for moving structured debates between tools. „ÄêAIF rationale + endpoint sketch and acceptance. „Äë
Work
	‚Ä¢	Implement GET /api/deliberations/[id]/aif with an I‚ÄëNode/S‚ÄëNode mapping from your Claim/Argument+scheme metadata. Create lib/export/aif.ts.
Acceptance
	‚Ä¢	Exported AIF JSON validates and opens in OVA+/Carneades. 

Phase 7 ‚Äî Representative Viewpoints 2.0 (expose what we already compute)
Why: You already have foundational models and selection routines for viewpoints; surface them in the Agora context to show plural extensions and audience coverage. „ÄêModels & selection pipeline ‚Äì components and route sketch. „Äë
Work
	‚Ä¢	Add /api/deliberations/[id]/viewpoints/select that calls the selection routine; render in components/deepdive/RepresentativeViewpoints.tsx with coverage metrics and conflict pairs.
	‚Ä¢	Reuse your AF/VAF/BAF helpers for edges (support vs rebut/undercut) so views can be filtered by edge semantics.
Acceptance
	‚Ä¢	Users can toggle between 1..k representative views; coverage/min coverage reported; top conflict pairs highlighted.

Phase 8 ‚Äî Metrics & outcomes (make progress legible)
Why: The notes propose a solid set of metrics to validate the multi‚Äëlayered approach (dialogical vs monological). „ÄêProposed metrics list. „Äë
Work
	‚Ä¢	Add a Deliberation Metrics panel: Argument Quality (defended rate), Deliberation Depth, User Engagement (challenges/undercuts), Resolution Rate (convergent branches), Persuasive Efficacy (opt‚Äëin survey). 
Acceptance
	‚Ä¢	Metrics visible per deliberation; resolution rate aligns with trace convergence; depth >1 on non‚Äëtrivial topics.

File‚Äëlevel changes & where they land
	‚Ä¢	API
	‚ó¶	/api/dialogue/move: keep signature/dedup & CLOSE‚áí‚Ä†; require reply locus for non‚Äëinitial; persist acts[] fully. 
	‚ó¶	/api/dialogue/legal-moves: continue soft legality; add ‚Äúlikely relevant‚Äù hint; preserve CLOSE via stepper hints. 
	‚ó¶	/api/ludics/delocate: new route (alias/migrate from panel delocate for consistency).
	‚ó¶	/api/deliberations/[id]/aif: new export route. 
	‚ó¶	/api/deliberations/[id]/viewpoints/select: selection endpoint. 
	‚Ä¢	Lib
	‚ó¶	packages/ludics-engine/compileFromMoves & stepper: keep as the source of truth for compile/step; expose decisive indices/daimon‚Äëhints in the trace payload. 
	‚ó¶	lib/dialogue/moves.ts: extend synthesizeActs to include openings, isAdditive, justifiedBy. 
	‚ó¶	lib/export/aif.ts: new serializer. 
	‚ó¶	lib/deepdive/*: reuse AF/selection helpers for Representative Viewpoints. 
	‚Ä¢	DB (Prisma)
	‚ó¶	Ensure DialogueMove.payload is canonical acts[] (notes show target shape). 
	‚ó¶	Add receipts for delocation (if not already present as DecisionReceipt). 
	‚Ä¢	UI
	‚ó¶	components/map/NegotiationDrawer.tsx: Trace Ribbon + decisive index markers; ‚ÄúResolve (‚Ä†)‚Äù indicator on convergent branches. 
	‚ó¶	components/ludics/LociTreeWithControls.tsx: heatmap + additive choice UI. 
	‚ó¶	components/deepdive/RepresentativeViewpoints.tsx: surface k‚Äëviews with coverage stats. 

Risks & mitigations
	‚Ä¢	Performance (relevance, step‚Äëtraces): keep strict relevance offline; paginate long traces; cache daimon hints per locus. „ÄêStrict relevance cost note. „Äë
	‚Ä¢	UX complexity: start with soft chips (relevance / convergence) and progressive disclosure; use the Trace Ribbon as the primary explainer. 
	‚Ä¢	Interop drift: validate AIF export against OVA+/Carneades samples as part of CI. 

What‚Äôs different vs. the prior roadmap
	‚Ä¢	Moves are multi‚Äëact at explicit loci (not monolithic), enabling additive choices and presupposition/ramification handling. „ÄêMulti‚Äëact interventions & ramifications. „Äë
	‚Ä¢	We surface a Convergence/Daimon vocabulary in UI/metrics so people can tell why a thread is ‚Äúdone.‚Äù „ÄêConvergence with ‚Ä† in acceptance. „Äë
	‚Ä¢	We add CBR‚Äëstyle evidence ‚Üí rule prompts to make implicit warrants explicit. „ÄêEvidence ‚áí rule heuristic. „Äë
	‚Ä¢	We prioritize AIF export and Representative Viewpoints to connect Agora to the broader ecosystem and to show plural, defensible summaries. 

Suggested PR sequence (low‚Äërisk chunks)
	1	Acts + Reply invariants (API/DB; small UI affordance).
	2	Trace Ribbon (read‚Äëonly) + CLOSE (‚Ä†) polish. 
	3	Additive picker and soft relevance chips.
	4	Delocation route + receipt; wire to NegotiationDrawer and Panel.
	5	Evidence ‚Üí rule prompt in composer. 
	6	AIF export (JSON) + Representative Viewpoints surface. 
	7	Metrics panel (depth, convergence rate, defended rate). 
This plan stays true to MeshResearchNotes while aligning with the code you‚Äôve already shipped (/api/dialogue/move, /api/dialogue/legal-moves, Ludics compile/step, panel tools). If you want, I can start with (1) and (2)‚Äîthe minimal changes that unlock the rest‚Äîusing the exact files/paths cited above.

Absolutely‚Äîhere‚Äôs a full second‚Äëpass ‚Äúcomb through‚Äù of MeshResearchNotes.txt, pulling in everything it covers (not just Ludics) and tying each theme to a crisp takeaway we can carry into the Agora roadmap.

1) Formal dialogue systems (beyond Ludics)
Prakken‚Äëstyle persuasion protocols (PPD).‚Ä®The notes stress the explicit reply structure (every move replies to a specific prior move), the distinction between attacks (WHY/ARGUE) that keep a branch open and surrenders (CONCEDE/RETRACT) that close it, and the role of relevance (a move is legal only if it can change the root‚Äôs dialogical status). Termination and liberal back‚Äëreplying/parallel lines are part of the model, not UI polish. This is the bedrock for IN/OUT computation and backtracking in Agora.
Event Calculus (EC) implementations.‚Ä®The notes highlight EC as a declarative way to encode turn‚Äëtaking, legality, and status‚Äîlegality persists by inertia until terminated (e.g., by surrender or by making the move). That matters for a fast, cacheable ‚Äúdialogue consultant‚Äù on the server (who has the turn, which replies are legal now, was move X legal then?).
Public vs. private semantics (design choice).‚Ä®The document calls out that we should commit to public semantics (legality and status from the public record), in contrast to systems where legality depends on an agent‚Äôs private beliefs (PWA). This is essential for auditability, moderation, and shared ground truth.
Legal reasoning patterns (beyond ‚Äúlogic‚Äù).‚Ä®A deeper nuance: case‚Äëbased reasoning (analogize/distinguish) is treated as heuristics that introduce defeasible rules into the dialogue‚Äînot just ‚Äúmore content.‚Äù When a user cites a precedent, they‚Äôre often proposing a general rule. The notes recommend prompting users to surface that rule explicitly (‚ÄúIn contexts with {A,B}, usually C‚Äù), making the implicit defeasible commitment visible and debatable.

2) Structured & abstract argumentation (AFs) and a database‚Äënative path
AFs as databases (repairs = extensions).‚Ä®The notes include a strong, implementable angle: represent attack graphs relationally and compute preferred/stage/semi‚Äëstable extensions via consistent query answering (repairs satisfying FDs/IDs), not just in memory. Benefits: scalability, integrity, and richer queries (e.g., ‚Äúdefended against X but not Y‚Äù), with a clean mapping between AF semantics and DB constraints.

3) Discourse & rhetoric (RST, concessions, coherence)
RST‚Äëdriven structure suggestions in the Composer.‚Ä®The notes detail how an RST parser can detect nucleus/satellite relations (Evidence/Justify/Elaboration/Contrast/Condition) and auto‚Äëpropose Claim/Grounds scaffolding, map rhetorical relations to support/rebut/undercut, and even combine (‚Äúglue‚Äù) adjacent segments into a single argumentative unit (ADU). This reduces cognitive load and raises structural quality.
‚ÄúYes, but‚Ä¶‚Äù scaffolding (Concession ‚Üí rebuttal).‚Ä®Automatic detection of Concession turns on a two‚Äëmove template: first a concede to the opponent‚Äôs point, then a targeted rebut‚Äîexplicitly wiring the dialogical move sequence the protocol expects.
Coherence scoring.‚Ä®An RST‚Äëbased ‚Äúcoherence score‚Äù can flag fragmented drafts and suggest connective cues (‚Äúbecause/however‚Äù)‚Äîuseful, low‚Äëfriction feedback while composing.

4) Interoperability & knowledge ecosystem
AIF import/export.‚Ä®Adopt AIF to avoid a walled garden: map our Claims/Arguments/Edges to AIF I‚Äënodes/S‚Äënodes, expose an export route, and ensure round‚Äëtrip with OVA+/Carneades. This gives Agora scholarly and toolchain interop.

5) Synthesis & representation of viewpoints
Representative Viewpoints (RV) and entailment UI.‚Ä®The notes include a concrete plan for viewpoint selection (route + algorithms + UI) and a SequentBadge for entailment (Œì ‚ä¢ Œî), so the system can present small, representative sets of arguments and show what they jointly support. This couples argumentation semantics with an audience‚Äëfriendly presentation layer.

6) Metrics & evaluation (to prove it works)
What to measure beyond monological outputs.‚Ä®Track Argument Quality (defended vs defeated), Deliberation Depth (length of attack/defense chains), User Engagement (WHY/rebut/undercut rates), Consensus/Resolution Rate (stable statuses), and Persuasive Efficacy (belief change). These metrics are specific to dialogical/rhetorical systems and are explicitly proposed in the notes as our yardstick.

7) Advanced Ludics hooks the notes mention (to round the picture)
Daimon closure (‚Ä†) and ‚Äúdelocation.‚Äù‚Ä®Beyond the basic compile/step, the notes identify (a) making CLOSE (‚Ä†) an explicit move when the locus is closable and (b) a delocation operation to resolve additive collisions by shifting a design to a fresh branch. These are operational levers for real dialogues (and show how the Ludics layer complements PPD/AF/RST rather than replacing them).

8) Research‚Äëops: how we keep our work grounded
NotebookLM setup and guardrails.‚Ä®There‚Äôs a concrete plan to use NotebookLM with our schema/routes/components so analyses always cite the real files, plus a prompt library and guardrails (‚Äúmap ideas to Claims/Edges/CQStatus/DialogueMove, Ludics compile/step/trace, RV selection, AF labels; use CQ guard; name components to touch‚Äù). This is about reproducible, source‚Äëgrounded research engineering.

9) What this adds to the roadmap (delta from the first pass)
	‚Ä¢	Public semantics as a formal principle (documented and enforced): legality/status computed from the public record + commitments; no hidden belief bases. 
	‚Ä¢	Dialogue consultant endpoints (turn holders, legal moves by locus, status ‚Äúthen/now‚Äù) backed by EC‚Äëstyle persistence rules. 
	‚Ä¢	RST pipeline in the Composer: structure suggestions, ‚ÄúYes, but‚Ä¶‚Äù template, glue operation, coherence scoring. 
	‚Ä¢	CBR prompts on citation: when a source is attached, offer to surface a proposed defeasible rule. 
	‚Ä¢	Database‚Äënative AF module (optional path) for large rooms: compute extensions as DB repairs; enable richer queries. 
	‚Ä¢	AIF export route + serializer; RV selection route + UI with SequentBadge. 
	‚Ä¢	Metrics suite (quality, depth, resolution, engagement, persuasion) in dashboards. 
	‚Ä¢	Ludics quality‚Äëof‚Äëlife: expose CLOSE (‚Ä†) when legal; enable delocation ops for additive collisions. 

TL;DR
The notes cover a complete stack for deliberation:
	‚Ä¢	Procedural (PPD+EC), structural (AFs, DB‚Äënative), rhetorical (RST, concession/glue/coherence), interoperability (AIF), synthesis (RV/Œì‚ä¢Œî), evaluation (dialogical metrics), and advanced interaction (‚Ä†/delocation)‚Äîwith research‚Äëops to keep us honest. If we reflect all of these in the roadmap, we get a platform that‚Äôs not just argument‚Äëmapped, but dialogue‚Äësound, rhetorically aware, scalable, exportable, and measurable. 
If you want, I can fold these deltas directly into the step‚Äëby‚Äëstep implementation plan you approved earlier so we have one unified, engineering‚Äëready roadmap.

Perfect‚Äîhere‚Äôs a short ‚Üí long‚Äëterm roadmap that folds in all the context you shared (research compendia + current Mesh codepaths). I‚Äôve aligned it to what you already have in app/api/dialogue/*, Prisma models, and the deep‚Äëdive libs, and I‚Äôve organized it into PR‚Äësized steps with crisp acceptance criteria.

Guiding principles (grounded in your current code & prior v2 plan)
	‚Ä¢	Public semantics, explicit reply, idempotent moves. Keep the debate state computable from the public record, enforce explicit replies, and make every move idempotent via signatures. Your current /api/dialogue/move already synthesizes acts, dedups on a unique signature, and compiles/steps Ludics on write‚Äîgreat foundation to harden. 
	‚Ä¢	Protocol first, then semantics, then geometry. Phase 1: hard rules for legal moves. Phase 2: dialectical semantics (AF). Phase 3: Ludics geometry surfaced in UI. This sequencing matches the ‚ÄúUnified Discourse Core ‚Üí Semantics ‚Üí Ludics‚Äù strategy in your v2 roadmap. 
	‚Ä¢	Re‚Äëuse what‚Äôs in repo. You already ship legal-moves, open-cqs, Ludics compile/step, AF semantics helpers, and a representative‚Äëviewpoints selector‚Äîthis roadmap wires and hardens them rather than reinventing.

Phase 0 (Week 0‚Äì1): Hardening & alignment
0.1 Unify signatures & act synthesis (eliminate drift).
	‚Ä¢	Replace route‚Äëlocal makeSignature/synthesizeActs with the single source of truth in lib/dialogue/moves.ts (and/or lib/dialogue/signature.ts if you standardize on sha256). Guard to keep dm_unique_signature stable. Acceptance: round‚Äëtrip creates identical signatures for the same payload; duplicate POST returns {dedup:true}.
0.2 Normalize WHY TTL & CLOSE gating.
	‚Ä¢	Move WHY_TTL_HOURS into a server config; annotate WHY payloads with deadlineAt consistently (already done), and keep CLOSE (‚Ä†) eligibility via stepper daimon hints (already implemented in legal-moves). Add tests. 
0.3 Align edge types across layers.
	‚Ä¢	Ensure ArgumentEdge.type (rebut/undercut/support) is canonical, and keep ClaimEdge derivation in sync via maybeUpsertClaimEdgeFromArgumentEdge. Acceptance: creating a rebut/undercut edge auto‚Äëmaterializes the corresponding ClaimEdge with correct attackType/targetScope.
0.4 Bus/SSE topic hygiene.
	‚Ä¢	Standardize on dialogue:changed, dialogue:moves:refresh, decision:changed as emitted today; document payload contracts. 

Phase 1 (Weeks 1‚Äì3): Protocol & invariants
1.1 Legal‚Äëmoves engine v1 (explicit reply surface).
	‚Ä¢	/api/dialogue/legal-moves currently proposes WHY/answer/CONCEDE/RETRACT and CLOSE (if closable). Extend it to accept a concrete locusPath and encode minimal invariants: no duplicate same‚ÄëCQ WHY, GROUNDS only for open CQs, and block attacks on surrendered nodes. Add unit tests. 
	‚Ä¢	UI: render LegalMoveChips in your composer (e.g., DeliberationComposer.tsx) using this endpoint. Acceptance: chips reflect open‚ÄëCQ state from open-cqs and expose CLOSE when daimonHints allow. 
1.2 Attack granularity in the UI (rebut vs undercut).
	‚Ä¢	Use lib/dialogue/legalAttacks.ts / legalMoves.ts to propose move‚Äëspecific scaffolds (e.g., ‚Äúchallenge antecedent‚Äù, ‚Äúask witness‚Äù), tagging the move payload so the server can record intended attack scope (premise/inference/conclusion). Acceptance: posting a counter from these options writes an ArgumentEdge with the proper type/targetScope and triggers ClaimEdge upsert.
1.3 Commitments (thin slice).
	‚Ä¢	Start with the route you already have‚Äî/api/dialogue/answer-and-commit‚Äîto record a GROUNDS + commitment in one transaction. Expose a read‚Äëonly Commitments pane per participant (derived from moves/receipts) and a minimal ‚Äúretract commitment‚Äù act that toggles state. Acceptance: answering a WHY via this route both closes the CQ and creates a visible commitment record for the chosen owner (P/O). 

Phase 2 (Weeks 3‚Äì6): CQ wiring & dialectical status
2.1 CQs as first‚Äëclass moves.
	‚Ä¢	Replace ‚Äútoggle satisfied‚Äù UX with ASK/ANSWER wiring you already model: clicking a CQ spawns a WHY (with schemeKey/cqId in payload). Answering is a GROUNDS move to the same locus (the server already dedups by signature). Acceptance: open-cqs shows no key after a valid GROUNDS; the Dialogical/RightRail reflects that the virtual attacker is OUT. 
2.2 Dialectical labels (AF preferred/grounded).
	‚Ä¢	Implement /api/deliberations/[id]/dialectic using lib/deepdive/af.ts: build attack map from ArgumentEdge (rebut/undercut), compute preferred/grounded, and return IN/OUT/UNDEC per node. UI: badges on cards and filters in RightRail. Acceptance: cycles marked UNDEC (preferred), unattacked nodes IN, attacked‚Äëby‚ÄëIN nodes OUT. 
2.3 Protocol presets (room pref).
	‚Ä¢	Add a deliberation.prefs flag for asymmetric proof and strict relevance (feature flag off by default). For now, only show soft relevance warnings client‚Äëside based on unresolved loci; strict relevance can be an offline auditor later (Phase 4). Acceptance: toggling asymmetricProof changes labels for edge cases in AF (documented examples). 

Phase 3 (Weeks 6‚Äì10): Ludics geometry ‚Üí usable tools
3.1 Compile & step already‚Äëthere Ludics.
	‚Ä¢	/api/dialogue/move is already compiling designs and stepping interaction (‚Ä† close hints). Add a Trace Ribbon and Locus Heatmap to NegotiationDrawer to visualize traces and hotspots; annotate indices where convergence/divergence is determined. Acceptance: after a sequence WHY‚ÜíGROUNDS, the ribbon shows paired acts at the shared locus (e.g., 0.1) and the CLOSE chip appears when daimon conditions are met. 
3.2 Delocation (faxing) as moderator tool.
	‚Ä¢	Wire /api/dialogue/panel/delocate (already implemented) into a small moderator UI control to ‚Äúmove‚Äù a congested branch to a fresh base locus; log via ludicDecisionReceipt. Acceptance: clicking Delocate clones & shifts design, produces a procedural receipt, and emits refresh events. 
3.3 Panel receipts (auditable actions).
	‚Ä¢	Use /api/dialogue/panel/confirm to mint epistemic/procedural/policy receipts for ‚Äúwe consider branch X resolved‚Äù operations; show on the deliberation timeline. Acceptance: receipts render with subject, rationale, and link back to nodes. 

Phase 4 (Weeks 10‚Äì14): Value lenses, support edges, relevance auditor
4.1 Support edges & value lenses.
	‚Ä¢	Extend UI to create support edges distinctly from defenses; in AF, keep support out of conflict but surface as strength cues. Add a minimal Audience/Value selector (start with a static ordering per room) to color chips per audience, matching the v2 roadmap concept. Acceptance: arguments display support counters and audience‚Äëspecific ‚Äúaccepted‚Äù chips. 
4.2 Offline relevance auditor.
	‚Ä¢	Batch job: simulate potential moves to compute strict relevance (expensive) and annotate nodes with ‚Äústrictly relevant/irrelevant‚Äù. Client continues to use soft gating; moderators see strict labels. Acceptance: nightly task writes annotations; UI shows a subtle badge; no sync path blocking. 

Phase 5 (Weeks 14‚Äì20): Synthesis & decision support
5.1 Representative viewpoints.
	‚Ä¢	Expose /api/deliberations/[id]/viewpoints/select backed by lib/deepdive/selection.ts (utilitarian/harmonic/maxcov), using approvals as utility signal. Render 2‚Äì5 Viewpoint cards with coverage stats and an optional DecisionReceipt when one is adopted. Acceptance: top‚Äëk viewpoints computed; coverageAvg/min surfaced; adopting a viewpoint creates a receipt.
5.2 Briefs from deliberations.
	‚Ä¢	Use existing Brief/BriefVersion/BriefLink models to compile a brief from a deliberation (current selection or AF IN‚Äëset). Acceptance: clicking Compile Brief creates a version with links to arguments/claims; renders in Brief viewer. 

Phase 6 (20+ weeks): Interop & research‚Äëgrade features
6.1 AIF export/import.
	‚Ä¢	Add /api/deliberations/[id]/aif to serialize I‚Äënodes/S‚Äënodes from your internal graph; basic import for OVA/Carneades. Acceptance: round‚Äëtrip a small map. 
6.2 Case‚Äëbased reasoning helpers.
	‚Ä¢	When a citation is attached, prompt to induce a defeasible rule (analogize/distinguish) and store as warrant metadata; surface ‚Äúdistinguish‚Äù affordances on follow‚Äëup claims. (Research flag.) 

Cross‚Äëcutting engineering tasks
	‚Ä¢	Migrations & indexes. Confirm uniqueness on (deliberationId, signature) for DialogueMove and ensure fast lookups for findMany in /moves with composite [createdAt,id] order. 
	‚Ä¢	Test kit. Route unit tests for /move, /legal-moves, /moves, /open-cqs, AF engine golden cases (A‚ÜîB cycle), and viewpoint selector.
	‚Ä¢	UX fit‚Äëand‚Äëfinish. LegalMoveChips, CQ chips, AF status badges, receipts timeline, and Ludics trace/heatmap in NegotiationDrawer. (You can crib labels from lib/dialogue/legalAttacks.ts/legalMoves.ts.) 
	‚Ä¢	Observability. Log structured audit events for every dialogue mutation + receipt issuance; show them in a developer ‚ÄúEvents‚Äù pane. (Your merge/receipt style in other areas is a good pattern.) 

What ‚Äúdone‚Äù looks like at each horizon
	‚Ä¢	Short term (‚â§ 3 weeks): Stable legal‚Äëmoves flow with explicit replies and CQ closure; dedup/idempotent moves; CLOSE (‚Ä†) shows up when appropriate; commitments pane; AF labels visible.
	‚Ä¢	Mid term (‚âà 6‚Äì10 weeks): Ludics trace + heatmap in UI; delocation and panel receipts; support edges & value lens; nightly relevance auditor annotates threads.
	‚Ä¢	Long term (‚âà 14‚Äì20+ weeks): Representative viewpoints & decision receipts integrated; brief compilation; AIF interop; optional CBR prompts for evidence‚Äëto‚Äërule induction.

Why this is safe and efficient for your codebase
It stays inside the lanes you already paved‚Äîyour API routes, Prisma models, and deep‚Äëdive libs‚Äîand layers theory‚Äëdriven features in a way that always leaves the platform in a working, incrementally better state. The plan also matches the architectural direction of your Roadmap v2 while being concrete about files, endpoints, and acceptance checks.
If you want, I can start by opening the Phase 0/1 PR set (signatures alignment + legal‚Äëmoves invariants + UI chips) since all the touchpoints are already in app/api/dialogue/* and lib/dialogue/*.

Absolutely‚Äîhere‚Äôs a tight, third‚Äëpass audit across the research compendia and your current Agora code to catch anything still missing or under‚Äëspecified. I‚Äôve organized it as (A) theory items we should surface explicitly, (B) what your code already covers (with gaps), and (C) concrete ‚Äúdelta‚Äù tasks to eliminate the omissions. Citations point to the passages in your compendia and the relevant code files I inspected.

A) Theory details that must be first‚Äëclass (and how they alter the plan)
	1	Game‚Äëtheoretic links between AF semantics and dialogue play‚Ä®The compendium spells out that winning strategies for PRO under different semantics (grounded vs. preferred credulous/skeptical) correspond to different legality / repetition constraints in the dialogue game. That‚Äôs more than a nice‚Äëto‚Äëhave; it means Agora should let a room choose a semantics and then enforce the corresponding move constraints (e.g., who may repeat which arguments). Add a Semantics preset that maps to grounded or preferred (credulous/skeptical) and adjusts legality accordingly.
	2	Case‚ÄëBased Reasoning (CBR) as premise‚Äëintroduction moves‚Ä®The ‚Äúanalogize / broaden / distinguish‚Äù repertoire isn‚Äôt just annotations‚Äîit‚Äôs a procedural layer for growing the rule pool during the dispute. We should expose these as explicit composer templates (CBR palette) with structured payloads, and evaluate dialogical status relative to the dynamically introduced rules.
	3	Precedent as a dialectical multi‚Äëargument structure (not a single fact)‚Ä®Evidence should be linkable to another deliberation‚Äôs winning and defeated lines (with priority reasons), so a participant can cite parts of a precedent or distinguish it precisely. This argues for first‚Äëclass cross‚Äëdeliberation links + ‚Äúimport a sub‚Äëtree‚Äù affordances in the editor.
	4	Schemes + CQs: make the prompts do real work‚Ä®Schemes come with critical questions; we should attach those CQs to WHY/GROUNDS guidance and drive one‚Äëclick legal move scaffolds (e.g., ‚Äúexpert opinion ‚Üí ask for domain, track record, consensus‚Äù). Your current open‚ÄëCQ plumbing is a good start; pair it with scheme libraries. 
	5	Public vs. private semantics (make it explicit)‚Ä®Your architecture implicitly uses public semantics (good), but we should declare and enforce it at the API boundary (legality depends only on public record, not private beliefs) and keep ‚Äúprivate scratchpads‚Äù as authoring aids only.
	6	Dialectical asymmetry (‚Äústrict defeat‚Äù for the proponent)‚Ä®For legal/policy modes, the proponent must strictly defeat the opponent; the opponent need only defeat. This should be a room preference that changes status aggregation and legality (e.g., what counts as a successful defense).
	7	Relevance = ‚Äúcan flip the root‚Äôs dialogical status‚Äù (costly)‚Ä®True relevance requires simulating the move‚Äôs impact on status; it is heavy and was explicitly hard in the EC formalization. Keep soft relevance (fast, UI warning) and batch a strict auditor that annotates threads post‚Äëhoc.
	8	Priority rules are themselves debatable‚Ä®Defeat via rebut/undercut and priority are objects of argument too. We should allow users to argue a priority between rules/arguments and reflect that in status updates. 

B) Where the code stands (and what that implies)
1) Dialogue Move pipeline
	‚Ä¢	Route: /api/dialogue/move normalizes payloads, generates a signature (idempotent insert), enforces WHY TTL, synthesizes Ludics acts (including CLOSE/‚Ä†), compiles/steps designs, and emits SSE. Good foundation. Gap: the signature logic here differs from lib/dialogue/signature.ts; unify to avoid drift and collisions. 
	‚Ä¢	Acts: synthesizeActs supports WHY/GROUNDS/CLOSE; extend to ‚ÄúAccept argument‚Äù vs ‚ÄúConcede claim‚Äù to enforce the R7‚Äëstyle guard (accept the argument when it‚Äôs a reply to WHY). 
2) Legality & CQs
	‚Ä¢	Route: /api/dialogue/legal-moves collects open CQs and exposes GROUNDS/WHY/CONCEDE/RETRACT; if a locusPath is provided, it calls the stepper and offers CLOSE (‚Ä†) when legal. Great. Gaps: (a) add ‚Äúduplicate‚Äëreply‚Äù and ‚Äúno attack after surrender‚Äù checks; (b) surface R7 (‚Äúconcede conclusion‚Äù blocked when you owe ‚Äúaccept argument‚Äù). 
	‚Ä¢	Route: /api/dialogue/open-cqs already computes open keys per target; hook scheme metadata here so CQs carry scheme‚Äëspecific prompts. 
3) AF / selection & clustering
	‚Ä¢	AF: lib/deepdive/af.ts builds Dung AFs; preferredExtensions enumerates/heuristically grows preferred sets; this is the right abstraction to back a Semantics toggle in the UI and status engine. 
	‚Ä¢	Selection: lib/deepdive/selection.ts already computes representative viewpoints with utilitarian/harmonic/maxcov rules‚Äîperfect to surface ‚Äúrepresentative bundles‚Äù and to wire audience/value lenses later. 
	‚Ä¢	Models: Prisma has Claim/Argument/Edges (rebuts/supports, targetScope), Clusters, BridgeRequests, Briefs/Versions, Issues‚Äîwe can align legal support edges (BAF) and future value lenses (VAF) on top of these. 
4) Attack suggestion helpers
	‚Ä¢	legalAttacks.ts / legalMoves.ts detect basic shapes (conditional/conjunction/disjunction/‚àÄ/‚àÉ/presupposition), returning move templates. Great seed for the attack palette and presupposition‚Äëchallenge chip. 
5) Panel actions & Ludics
	‚Ä¢	Confirm writes a decision receipt; Delocate clones/retags designs and records a procedural receipt, then refreshes moves. These are the right ‚Äúprocedural rails‚Äù to expose Resolve events and ‚Ä† closures in UI. 
6) AIF export stub in notes
	‚Ä¢	Your notes earmark lib/export/aif.ts‚Äîgood; let‚Äôs implement minimal AIF now so evidence/arguments can be exported cleanly. 

C) ‚ÄúDelta‚Äù checklist ‚Äî concrete items to eliminate omissions
Below are implementation‚Äësized tasks with where they live and what to change.
Protocol invariants & guards
	‚Ä¢	Duplicate reply (R4) & ‚Äúno attack after surrender‚Äù (R5): add to /api/dialogue/legal-moves (and server guard shared util), backed by a small index over (replyTo, kind) in moves, plus a branch‚Äëstate cache. 
	‚Ä¢	R7‚Äëstyle guard (‚ÄúAccept argument‚Äù vs ‚ÄúConcede claim‚Äù): extend synthesizeActs and legal‚Äëmoves so that when replying to WHY, ‚ÄúConcede‚Äù becomes ‚ÄúAccept this argument‚Äù (and closes the branch); block raw concede in that locus. 
Semantics & status
	‚Ä¢	AF semantics toggle (grounded / preferred‚Äëcredulous / preferred‚Äëskeptical):
	‚ó¶	Add a room pref.
	‚ó¶	In status computation, enforce repetition constraints and set evaluation accordingly; reuse preferredExtensions for preferred, and add a grounded labelling pass.
	‚Ä¢	Dialectical asymmetry: boolean pref to switch strict defeat for PRO in status/legality aggregation. 
	‚Ä¢	Relevance: keep soft relevance (target is unresolved/open) inline; write a batch auditor process that simulates potential moves on the AF to compute ‚Äústrict relevance‚Äù badges. 
CBR & cross‚Äëdebate evidence
	‚Ä¢	CBR palette (Analogize/Broaden/Distinguish templates) in the composer; persist as structured payloads; show rule deltas in the Right Rail. Evaluate status vs. the grown rule pool. 
	‚Ä¢	Cross‚Äëdeliberation evidence: allow citing portions of another deliberation‚Äôs tree (winning/defeated/priority nodes) as sources with deep links, not just URLs. 
Schemes, CQs & presuppositions
	‚Ä¢	Attach CQs to schemes in open-cqs (add scheme metadata) and populate composer prompts accordingly. 
	‚Ä¢	Presupposition chip: if legalMoves.detectShape === 'presupposition', show a ‚ÄúChallenge presupposition‚Äù quick action that spawns a targeted WHY. 
Interop & receipts
	‚Ä¢	AIF export minimal pass (I‚Äënodes/S‚Äënodes) for arguments and citations; wire to Briefs. 
	‚Ä¢	Resolve / CLOSE (‚Ä†) UX: promote your legal‚Äëmoves ‚ÄúCLOSE‚Äù suggestion into a visible Resolve branch button; log a procedural receipt (you already do for panel ops). 
Consistency & signatures
	‚Ä¢	Unify signatures: replace custom makeSignature in the route with computeDialogueMoveSignature from lib/dialogue/signature.ts (or vice‚Äëversa) to guarantee idempotence across services.

D) Tiny but important UX clarifications we should add
	‚Ä¢	Open vs. closed branch pills + ‚ÄúShow full chain‚Äù / ‚ÄúCollapse chain‚Äù (you already do variants in Forum): mirror that in deliberation trees, tied to surrenders and CLOSE (‚Ä†). 
	‚Ä¢	Attack palette always contextualized by shape (IF/AND/OR/‚àÄ/‚àÉ) and CQs; it should never suggest illegal attacks (e.g., on a surrendered target). 
	‚Ä¢	Public semantics notice in-room: ‚ÄúLegality is computed from the public record; drafts don‚Äôt affect it.‚Äù 

E) Why this closes the remaining theoretical gaps
	‚Ä¢	It binds semantics (grounded/preferred) to protocol behavior, aligning UI options with formal games. 
	‚Ä¢	It turns CBR from narrative advice into concrete legal moves that dynamically alter what‚Äôs in play. 
	‚Ä¢	It makes priorities and relevance explicit, auditable, and (for relevance) pragmatically computed.
	‚Ä¢	It upgrades evidence to structured, cross‚Äëdebate citations that match the legal‚Äëstyle dialectical model. 

Quick ‚Äúfirst PRs‚Äù I can cut immediately (each is bite‚Äësized)
	1	R4/R5 legality guards + R7 accept‚Äëargument gate in /api/dialogue/legal-moves (+ shared util) and synthesizeActs.
	2	Semantics toggle (grounded/preferred) wired through AF status using af.ts + selection heuristics. 
	3	CBR move templates in the composer (broaden/distinguish) with rule‚Äëpool deltas in the Right Rail. 
	4	AIF export minimal I/S‚Äënodes for arguments/citations. 
	5	Signature unification to ensure idempotent inserts are consistent system‚Äëwide. 
If you want me to start cutting code for (1) and (5) first, I‚Äôll deliver those changes in the existing files you‚Äôve shared (/api/dialogue/legal-moves, /api/dialogue/move, lib/dialogue/signature.ts, lib/dialogue/moves.ts). The rest can follow in the order above.


Here‚Äôs a final audit pass‚Äîtight, implementation‚Äëready, and cross‚Äëchecked against your research compendia and the current Agora code. I‚Äôve grouped the findings into (A) theory guarantees we must uphold, (B) what the codebase already does, (C) gaps + exact fixes (files to touch), and (D) a short PR stack with crisp acceptance checks.

A) Theory guarantees we must uphold (non‚Äënegotiables)
	‚Ä¢	Explicit reply structure (tree), not just sequence. Every non‚Äëinitial move must reply to a specific prior move; attacks keep a branch open, surrenders close it; legality and status (IN/OUT) depend on this tree. Back‚Äëreplies and parallel attacks must be legal. 
	‚Ä¢	Protocol rules R4/R5/R7, turn model, termination. No duplicate replies to the same target (R4); after surrender, further attacks on that target are illegal (R5); if an argument was offered in answer to why œÜ, you can‚Äôt jump to concede œÜ‚Äîyou must accept the argument, not just the conclusion (R7). After the first two moves, both players ‚Äúhave the turn‚Äù (no simultaneous speech), and a dialogue terminates when a turn‚Äëholder has no legal moves. These drive the legality oracle and UI affordances. 
	‚Ä¢	Public semantics by design. All legality and status are derived from the public record, not private beliefs (PWA is a different, private‚Äësemantics family). This matches the Agora transparency ideal. 
	‚Ä¢	Relevance (soft now, strict later). True relevance = ‚Äúcould this move flip the root‚Äôs status?‚Äù‚Äîpowerful but expensive; run soft guards in realtime, strict validator offline. 
	‚Ä¢	Dialects & values. Asymmetric burdens of proof (legal/policy rooms) and audience/value lenses (VAF) are first‚Äëclass roadmap items. 

B) What the codebase already does well (quick wins we can build on)
	‚Ä¢	Move API with idempotency for key kinds. /api/dialogue/move writes moves with a per‚Äëkind signature (idempotent for WHY/GROUNDS/CLOSE/CONCEDE mapping), TTL for WHY, auto‚Äëcompilation into Ludics designs, and optional stepping + SSE bus events. 
	‚Ä¢	Legal‚Äëmoves prototype. /api/dialogue/legal-moves proposes GROUNDS for open CQs, otherwise WHY, plus CONCEDE/RETRACT; it can gate CLOSE (‚Ä†) when the stepper signals a closable locus. 
	‚Ä¢	Shared helpers. lib/dialogue/moves.ts provides makeSignature/synthesizeActs; lib/dialogue/legalMoves.ts detects shapes (conditional, disjunction, presupposition, ‚Ä¶) to suggest attack options; lib/deepdive/af.ts computes preferred extensions for Dung AFs. 
	‚Ä¢	Prisma scaffolding for deliberation & synthesis. Argument/Edge with targetScope (premise/inference/conclusion), approvals, ViewpointSelection + ViewpointArgument, clusters/bridge‚Äëbuilder, and Decision receipts (the ‚Äúpanel confirm‚Äù route is in place). Great substrate for Representative Viewpoints + auditable decisions. 

C) Gaps & precise fixes (file‚Äëlevel actions)
The bullets below cite both the research intent and exact files requiring edits.
	1	Persist the reply structure (locus + reply‚Äëto) on every move.
	‚ó¶	Why: Our move rows have targetType/targetId and an optional payload.locusPath, but no durable field for the explicit reply locus / replied move. We need justifiedByLocus and/or replyToMoveId to make R4/R5/R7 enforceable and to support back‚Äëreplies and parallel lines cleanly.
	‚ó¶	Where: Prisma DialogueMove (add justifiedByLocus String?, replyToMoveId String? + FK), write path in /api/dialogue/move, and have composers set it.
	2	Enforce R4/R5/R7 and the turn model in the legality oracle.
	‚ó¶	Why: Current /api/dialogue/legal-moves is CQ‚Äëoriented and permissive; it doesn‚Äôt block duplicates (R4), post‚Äësurrender attacks (R5), or force ‚ÄúAccept argument‚Äù vs ‚ÄúConcede œÜ‚Äù (R7), nor does it encode the ‚Äúboth have the turn after move 2 / no simultaneous speech‚Äù model.
	‚ó¶	Where: Extend /api/dialogue/legal-moves to consult recent moves on the target locus/reply chain, refuse illegal acts, and surface ‚ÄúAccept argument‚Äù as a first‚Äëclass option when an argue answered a WHY. Use lib/dialogue/legalMoves.ts patterns to keep UX helpful, but make the server authoritative.
	3	Unify signatures & idempotency (eliminate drift).
	‚ó¶	Why: We now have two signature strategies: the bespoke makeSignature in the route and the deterministic computeDialogueMoveSignature utility; they don‚Äôt align, risking surprise dedup behavior across endpoints.
	‚ó¶	Where: Replace the ad‚Äëhoc per‚Äëroute signature with computeDialogueMoveSignature (or centralize in lib/dialogue/moves.ts) and ensure a unique index (deliberationId, signature) exists. Keep special‚Äëcase idempotency for WHY/GROUNDS/CLOSE by stabilizing payload fields used in the hash. 
	4	Add a Commitment store and derive it from moves.
	‚ó¶	Why: Public commitments are essential (concede/retract should update CS). This enables consistency checks and ‚Äúyou can‚Äôt concede ¬¨œÜ while committed to œÜ‚Äù room policies.
	‚ó¶	Where: Prisma: Commitment { deliberationId, participantId, proposition, isRetracted }. Update /api/dialogue/move to write commitments when CONCEDE/RETRACT land; add /api/dialogue/commitments. 
	5	Soft relevance now; strict relevance offline.
	‚ó¶	Why: True relevance (flip root‚Äôs status) is expensive but necessary for high‚Äëquality rooms. We can ship soft guards immediately (target unresolved loci), while a job recomputes strict relevance badges. 
	‚ó¶	Where: Extend /api/dialogue/legal-moves to mark moves ‚Äúlikely irrelevant‚Äù; add a nightly job to annotate moves with strict relevance results, and surface chips in the panel. 
	6	Asymmetric burden toggle & AF integration.
	‚ó¶	Why: Legal/policy rooms often require strict defeat for proponents; expose this as a room pref and reflect it in AF status/labels. 
	‚ó¶	Where: Add deliberation.prefs.asymmetricProof and adapt lib/deepdive/af.ts status computation (strict vs normal defeat). UI: badge in RightRail. 
	7	Presupposition challenges (already detected, not surfaced).
	‚ó¶	Why: lib/dialogue/legalMoves.ts can detect ‚Äúloaded‚Äù presupposition cues; hook this into the WHY/CQ flow so users can challenge presuppositions as first‚Äëclass attacks. 
	‚ó¶	Where: When detectShape(text) === 'presupposition', offer a ‚ÄúChallenge presupposition‚Äù WHY with a labeled payload; ensure /api/dialogue/legal-moves suggests it when relevant. 
	8	Support edges and VAF lens (planning hooks exist, finalize).
	‚ó¶	Why: Separate support from defense, and allow audience/value orderings (objective vs subjective acceptance). The Prisma + helper that maps ArgumentEdge‚ÜíClaimEdge is already moving in this direction‚Äîcomplete the loop. 
	‚ó¶	Where: Confirm EdgeType and ClaimAttackType enums cover support/rebut/undercut and scopes; add Value/Audience tables and minimal calculations for Obj/Sub acceptance chips. 
	9	Consistency & API cleanliness.
	‚ó¶	Bus usage: Standardize on one emitter (emitBus vs bus.emitEvent) so clients don‚Äôt miss events. 
	‚ó¶	Auth: legal-moves currently unauthenticated; if room policies vary by role/participant, require auth to compute permissible moves. 
	‚ó¶	Design selection: The stepInteraction fallback picks designs by naive order; resolve P/O by participant mapping for stability. 
	10	Interchange & synthesis.
	‚Ä¢	AIF export: Keep in the plan (not yet in code) so arguments/links map to I‚Äë/S‚Äënodes for external analysis. 
	‚Ä¢	Representative Viewpoints: You already have ViewpointSelection + Decision receipts; wire the selection service to AF status + approvals so ‚Äúreceipt ‚Üí chosen viewpoint ‚Üí AF snapshot‚Äù is fully auditable. 

D) Short PR stack (sequenced, low‚Äërisk, high‚Äëimpact)
	1	Reply structure & R4/R5/R7 guardrails
	‚ó¶	Files: Prisma (DialogueMove), /api/dialogue/move, /api/dialogue/legal-moves, lib/dialogue/legalMoves.ts.
	‚ó¶	Checks: Attempting an attack after surrender is blocked; attempting Concede œÜ when an argument answered why œÜ yields ‚ÄúAccept argument‚Äù action.
	2	Signature unification & unique index
	‚ó¶	Files: lib/dialogue/signature.ts, /api/dialogue/move (use the shared function), Prisma unique on (deliberationId, signature).
	‚ó¶	Checks: Double‚Äësubmit on WHY/GROUNDS/CLOSE dedups reliably; other kinds behave predictably.
	3	Commitment store
	‚ó¶	Files: Prisma (Commitment), /api/dialogue/move (derive), /api/dialogue/commitments (read).
	‚ó¶	Checks: CONCEDE adds a row; RETRACT flips isRetracted; commitments render in UI. 
	4	Soft relevance badges + presupposition challenges
	‚ó¶	Files: /api/dialogue/legal-moves, lib/dialogue/legalMoves.ts, UI badges.
	‚ó¶	Checks: Irrelevant moves get a warning; presupposition CQs appear when detected.
	5	Asymmetric burden toggle & AF
	‚ó¶	Files: Prisma (prefs), lib/deepdive/af.ts, UI chips.
	‚ó¶	Checks: Toggling flips certain branches IN‚ÜíOUT under strict defeat; labels update.
	6	Support/VAF minimal slice
	‚ó¶	Files: Prisma (values/audiences), AF adaptor, RightRail lens.
	‚ó¶	Checks: Selecting an audience re‚Äëcolors acceptance (Obj/Sub). 
	7	AIF export + Decision receipts wiring
	‚ó¶	Files: /api/deliberations/[id]/aif, serializer, DecisionReceipt ‚Üî selection pipeline.
	‚ó¶	Checks: Export imports cleanly in AIF tools; receipts link to AF snapshot and selected viewpoint.

Why I‚Äôm confident this is ‚Äúlast missing pieces‚Äù
	‚Ä¢	The research compendium gives us the exact invariants to enforce (reply tree, attack/surrender, R4/R5/R7, public semantics, relevance, turn/termination), and we‚Äôve mapped each to server/DB/UI changes. 
	‚Ä¢	The v2 roadmap already anticipates many of these (commitments, asymmetric proof, schemes/CQs as moves, Ludics hooks, AIF), and this audit just snaps them precisely to the code you‚Äôve uploaded.
	‚Ä¢	The current APIs/libs are close: idempotent inserts, CQ‚Äëaware legal moves, Ludics compile/step, AF utilities, claim‚Äëedge helpers, and decision receipts are all in reach‚Äîthis is wiring + invariants work, not a rewrite.
If you want, I can start with PR‚Äë1 (reply structure + R4/R5/R7) and PR‚Äë2 (signature unification) immediately; everything else chains cleanly from there.
